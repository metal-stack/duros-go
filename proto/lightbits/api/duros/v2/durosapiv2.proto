syntax = "proto3";

package lightbits.api.duros.v2;

option go_package = "duros/v2;v2";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/api/annotations.proto";
import "google/api/httpbody.proto";
import "grpc/gateway/protoc_gen_swagger/options/annotations.proto";
import "lightbits/api/duros/v2/statisticsapiv2.proto";
import "lightbits/api/duros/v2/schedule_policy.proto";
import "lightbits/api/duros/v2/security.proto";
import "lightbits/api/duros/v2/labels.proto";
import "lightbits/api/duros/v2/authz_mode.proto";
import "lightbits/api/duros/v2/proxy_info.proto";

service DurosAPI {
    rpc GetVersion(GetVersionRequest) returns (Version) {
        option (google.api.http) = {
            get: "/api/v2/version"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Product Version.";
            description: "Get product version information.";
        };
    }

    rpc CreateVolume(CreateVolumeRequest) returns (Volume) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/volumes"
            body: "*"
            additional_bindings {
                post: "/api/v2/volumes"
                body: "*"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create volume.";
            description: "A volume has a user defined name, capacity and a string-based Access Control List (ACL).\nUser can also select to enable compression and define IP-ACL (IP address-based control list).";
            tags: "create volume";
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters, \nsize is not a positive integer, \nreplica count is outside of a valid range, \nACL or IP-ACL is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteVolume(DeleteVolumeRequest) returns (DeleteVolumeResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/volumes/{UUID}"
            additional_bindings {
                delete: "/api/v2/volumes/{UUID}"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete volume.";
            description: "Deletes volume with provided UUID.\nDeletion of volume is a long operation. The status of deletion can be queried by GET operation on the volume. As long as the operation runs volume state is Deleting. When operation completed GET volume returns NotFound error response";
            tags: "delete volume";
            responses: {
                key: "404";
                value: {
                    description: "Volume with provided UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid UUID or a volume state does not allow deletion (Deleting/Failed).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Volume is in a temporal state that does not allow deletion currently (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the volume";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListVolumes(ListVolumeRequest) returns (ListVolumesResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/volumes"
            additional_bindings {
                get: "/api/v2/volumes"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List volumes.";
            description: "List can be filtered by failure domain. List can be partially returned by given offset UUID and size of the list. If offset is not provided, list is returned from the start. If offset UUID is provided, list starts from the next volume after the provided offset UUID. If limit is provided, length of the returned list is bounded by the limit. If limit is not provided, list is returned until the end. projectName is mandatory unless you are the admin. List can also be filtered by a specific source snapshot.";
            tags: "list volume";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/events"
            additional_bindings {
                get: "/api/v2/events"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get all Lightbits events from cluster";
            description:  "API to pull the events from the aggregated cluster event log";
            tags: "list events";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "project not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetHost(GetHostRequest) returns (ConnectedHost) {
        option (google.api.http) = {
            get: "/api/v2/connectedHosts/{hostNQN}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get connected host information.";
            description: "Get connected host information given by hostNQN.";
            tags: "get connected host";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided host NQN is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListHosts(ListHostsRequest) returns (ListHostsResponse) {
        option (google.api.http) = {
            get: "/api/v2/connectedHosts"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get list of connected hosts.";
            description: "List can be filtered by volume UUID.";
            tags: "get connected host";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided volume UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetVolume(GetVolumeRequest) returns (Volume) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/volumes/{UUID}"
            additional_bindings {
                get: "/api/v2/volumes/{UUID}"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get volume information";
            description: "Get volume information by provided UUID";
            tags: "get volume";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided volume UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListNodes(ListNodeRequest) returns (ListNodesResponse) {
        option (google.api.http) = {
            get: "/api/v2/nodes"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get list of nodes.";
            description: "A request to List Nodes is exposed via this API. An option to filter is done by the following parameters: 1. Name - e.g.  api/v2/nodes?Name=<Name> 2. UUID - e.g.  api/v2/nodes?UUID=<UUID> 3. FailureDomain - e.g.  api/v2/nodes?FailureDomain=<FailureDomain>";
            tags: "list nodes";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument, or several mutually exclusive arguments are provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetNode(GetNodeRequest) returns (DurosNodeInfo) {
        option (google.api.http) = {
            get: "/api/v2/nodes/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get node information.";
            description: "Get node information identified by UUID of the node";
            tags: "node";
            responses: {
                key: "404";
                value: {
                    description: "Node UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListNvmeDevices(ListNvmeDevicesRequest) returns (ListNvmeDevicesResponse) {
        option (google.api.http) = {
            get: "/api/v2/nvmeDevices"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve list of NVMe devices with filtering option.";
            description: "A request to list NVMe devices is exposed via this API. The list of NVMe devices can be filtered by the following parameters:  1. ServerUUID - e.g.  api/v2/nvmeDevices?ServerUUID=<UUID> 2. NodeUUID - e.g.  api/v2/nvmeDevices?NodeUUID=<UUID>";
            tags: "node";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetNvmeDevice(GetNvmeDeviceRequest) returns (UserNvmeDevicesResponse) {
        option (google.api.http) = {
            get: "/api/v2/nvmeDevices/{Serial}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve a specific NVMe device with filtering option";
            description: "Request NVMe device info by serial. Example usage: api/v2/nvmeDevices/15eb21c0-35ae-478d-b";
            tags: "get nvme-device";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Serial is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc FetchLogs(LogRequest) returns (stream google.api.HttpBody) {
        option (google.api.http) = {
            get: "/api/v2/logs"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve server logs and other information.";
            description: "Retrieve tarball file, generated by internal Lightbits script, that will contain server information and logs.";
            tags: "fetch logs";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetCluster(GetClusterRequest) returns (ClusterInfo) {
        option (google.api.http) = {
            get: "/api/v2/cluster"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve cluster information.";
            description: "Cluster information, e.g. cluster UUID and SubsystemNQN is exposed via this API.";
            tags: "get cluster";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetClusterInfo(GetClusterRequest) returns (ClusterInfoV2) {
        option (google.api.http) = {
            get: "/api/v2/clusterinfo"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve cluster information.";
            description: "Cluster information for tenants, e.g. cluster UUID and SubsystemNQN is exposed via this API.";
            tags: "get cluster";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateNvmeDevice(UpdateNvmeDeviceRequest) returns (UpdateNvmeDeviceResponse) {
        option (google.api.http) = {
            post: "/api/v2/nvmeDevices/{serialNumber}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update NVMe device on a node.";
            description: "Update NVMe device defined by serial number on a node defined by node UUID.";
            tags: "node";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Empty serial or empty node uuid is provided or device is already attached to another node or number of node's managed devices reached maximum or node is not listed as server's node for the server that device belongs to or node isn't active.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Serial or node uuid not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the device";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc AddNvmeDevice(AddNvmeDeviceRequest) returns (AddNvmeDeviceResponse) {
        option (google.api.http) = {
            post: "/api/v2/nvmeDevices"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Add NVMe device to a node.";
            description: "Add NVMe device defined by serial number to a node defined by node UUID. If NVMe device is already used by another node, or cannot be attached to the node, the command fails.";
            tags: "node";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Empty serial or empty node uuid is provided or device is already attached to another node or number of node's managed devices reached maximum or node is not listed as server's node for the server that device belongs to or node isn't active.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Serial or node uuid not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the device";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateVolume(UpdateVolumeRequest) returns (UpdateVolumeResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/volumes/{UUID}"
            body: "*"
            additional_bindings {
                put: "/api/v2/volumes/{UUID}"
                body: "*"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Update volume enable the change of the following attributes:\nACL list\nIP-ACL list.";
            summary: "Update volume.";
            tags: "echo rpc";
            responses: {
                key: "404";
                value: {
                    description: "Returned when the volume with given UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Volume is in temporal state and cannot be updated now (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument or a volume is in a state that cannot be updated (Deleting/Failed).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability (updating capacity).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the volume";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetServer(GetServerRequest) returns (Server) {
        option (google.api.http) = {
            get: "/api/v2/servers/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve a specific server info based on UUID";
            description: "Request server info identified by UUID.";
            tags: "server";
            responses: {
                key: "404";
                value: {
                    description: "Server with provided UUID does not exist.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListServers(ListServersRequest) returns (ListServersResponse) {
        option (google.api.http) = {
            get: "/api/v2/servers"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Retrieve servers list with filtering option.";
            summary: "A request to list servers is exposed via this API. The results can be filtered by supplying the following filters: 1. Name - e.g.  /api/v2/servers?Name=<Name> 2. UUID - e.g.  /api/v2/servers?UUID=<UUID>";
            tags: "list servers";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpgradeServer(UpgradeServerRequest) returns (UpgradeServerResponse) {
        option (google.api.http) = {
            post: "/api/v2/servers/{UUID}/upgrade"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Upgrade server.";
            description: "Upgrades server given by UUID with a package pointed by URI. Since upgrade is a long operation, the status of the upgrade shall be fetched from server object";
            tags: "upgrade";
            responses: {
                key: "404";
                value: {
                    description: "UUID not found";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid UUID or URI.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpgradeCluster(UpgradeClusterRequest) returns (UpgradeClusterResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/upgrade"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Upgrade cluster.";
            description: "Upgrades servers in the cluster one by one. Only servers that do not cause loss of service are upgraded. Since upgrade is a long operation, the status of the upgrade shall be fetched from server object";
            tags: "upgrade";
            responses: {
                key: "404";
                value: {
                    description: "One of the provided UUIDs is not found";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid UUID or URI.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableClusterEncryption(EnableClusterEncryptionRequest) returns (EnableClusterEncryptionResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/encryption/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable Cluster level encryption";
            description: "Enables cluster-level encryption. Once enabled, each volume will be encrypted with a Data Encryption Key (DEK), which is in turn encrypted by a Key Encryption Key (KEK). In the body, users can select the KeyStore type tpm or file. Note: cluster-encryption cannot be disabled once enabled.";
            tags: "encryption";
            responses: {
                key: "500";
                value: {
                    description: "System internal error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }
            }
        };
    }

    rpc CreateServer(CreateServerRequest) returns (Server) {
        option (google.api.http) = {
            post: "/api/v2/servers"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create Server.";
            description: "A request to create a new server.  The requires parameters in the body are:  1. serverEndpoints - url list of the new server ip addresses as well as etcd ports for peer communication e.g: http://10.0.0.1:2380";
            tags: "upgrade";
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Multiple endpoints provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Server with UUID or endpoint already exists (reuseIP flag was not used).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ReplaceNode(ReplaceNodeRequest) returns (ReplaceNodeResponse) {
        option (google.api.http) = {
            post: "/api/v2/nodes/{SrcNodeUUID}/replace"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Replace Node.";
            description: "The request is identified by the UUID of the replaced node (referred as SrcNodeUUID).\nThe required parameters in the body are:\n1. TargetNodeUUID - the UUID of the target node that replaces the src Node. The command shall succeed only if srcNode is Inactive, and targetNode is Unattached. So user shall disable the server of the srcNode (that will make the node Inactive), and assure that targetNode is Unattached (possibly as a new node without assigned PGs or by replacing its PG to another node)";
            tags: "replace node";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument provided. Source and target nodes are not in correct states.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "One of the provided UUIDs is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on one of the nodes";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "429";
                value: {
                    description: "Too many commands in progress.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteServer(DeleteServerRequest) returns (DeleteServerResponse) {
        option (google.api.http) = {
            delete: "/api/v2/servers/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete Server.";
            description: "A request to delete a server. This operation makes the system to delete information of a server with given UUID. The required parameters in the body are:  1. UUID - UUID of the server to delete";
            tags: "delete server";
            responses: {
                key: "404";
                value: {
                    description: "Server with UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Missing or Invalid UUID is provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableServer(EnableServerRequest) returns (Server) {
        option (google.api.http) = {
            post: "/api/v2/servers/{UUID}/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable Server";
            description: "Enable a disabled server. Enabling a server causes the server nodes to synchronize with their peers and rebuild the replicas they hold.";
            tags: "server";
            responses: {
                key: "404";
                value: {
                    description: "Server with UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Missing or Invalid UUID is provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableServer(DisableServerRequest) returns (DisableServerResponse) {
        option (google.api.http) = {
            post: "/api/v2/servers/{UUID}/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable server.";
            description: "Server is disabled from the cluster. Server nodes become Inactive and do not participate in data protection. If the 'evict' parameter is True, all data on the server is evicted from the server before it is disabled. Once a server is disabled it can be enabled and added back to the cluster or removed from the cluster completely.";
            tags: "echo rpc";
            responses: {
                key: "404";
                value: {
                    description: "Server with UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Bad request: Missing/Invalid UUID is provided or disable server may lead to risk of service loss.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }


    rpc CreateProject(CreateProjectRequest) returns (Project) {
        option (google.api.http) = {
            post: "/api/v2/projects"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create project.";
            description: "A project has a name, a description, and a default qos rate limit policy.";
            tags: "create project";
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateProject(UpdateProjectRequest) returns (UpdateProjectResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update Project Default Policy.";
            description: "Update project's default resource policy.";
            tags: "update project default policy";
            responses: {
                key: "400";
                value: {
                    description: "Mandatory argument is missing.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteProject(DeleteProjectRequest) returns (DeleteProjectResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete project.";
            description: "Deletes project with provided name.";
            tags: "delete project";
            responses: {
                key: "404";
                value: {
                    description: "Project with provided Name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid Name or the Project is not allowed to be deleted.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListProjects(ListProjectsRequest) returns (ListProjectsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List projects.";
            description: "list all projects";
            tags: "list projects";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetProject(GetProjectRequest) returns (Project) {
        option (google.api.http) = {
            get: "/api/v2/projects/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get project";
            description: "Get project by name";
            tags: "get project";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided project name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateCredential(CreateCredentialRequest) returns (Credential) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/credentials"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create credential.";
            description: "A credential has a name and description.";
            tags: "create credential";
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters, \nsize is not a positive integer, \nreplica count is outside of a valid range, \nACL or IP-ACL is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteCredential(DeleteCredentialRequest) returns (DeleteCredentialResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/credentials/{ID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete credential.";
            description: "Deletes credential with provided ID.";
            tags: "delete credential";
            responses: {
                key: "404";
                value: {
                    description: "Credential with provided ID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid Name or the Credential is not allowed to be deleted.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListCredentials(ListCredentialsRequest) returns (ListCredentialsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/credentials"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List credentials.";
            description: "TODO";
            tags: "list credentials";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetCredential(GetCredentialRequest) returns (Credential) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/credentials/{ID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get credential";
            description: "Get credential by ID";
            tags: "get credential";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided credential ID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetRole(GetRoleRequest) returns (GetRoleResponse) {
        option (google.api.http) = {
	     get: "/api/v2/projects/{projectName}/roles/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get role";
            description: "Get role by name";
            tags: "get role";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided role name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListRoles(ListRolesRequest) returns (ListRolesResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/roles"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List all roles defined in a project.";
            description: "TODO";
            tags: "list roles";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
     }

     rpc CreateAdminEndpoint(CreateAdminEndpointRequest) returns (AdminEndpoint) {
        option (google.api.http) = {
            post: "/api/v2/adminEndpoints"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create admin endpoint";
            description: "Allow access to specified port for all specified IPs";
            tags: "create admin endpoint";
            responses: {
                key: "409";
                value: {
                    description: "Port already exists";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteAdminEndpoint(DeleteAdminEndpointRequest) returns (DeleteAdminEndpointResponse) {
        option (google.api.http) = {
            delete: "/api/v2/adminEndpoints/{port}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete admin endpoint";
            description: "Delete endpoint corresponding to specified port";
            tags: "delete admin endpoint";
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Port does not have a corresponding endpoint";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Temporal state that does not allow deletion currently (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the port";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }

        };
    }

    rpc ListAdminEndpoints(ListAdminEndpointsRequest) returns (ListAdminEndpointsResponse) {
        option (google.api.http) = {
            get: "/api/v2/adminEndpoints"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List admin endpoints";
            description: "List can be filtered by port";
            tags: "list admin endpoint";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }


    rpc UpdateAdminEndpoint(UpdateAdminEndpointRequest) returns (AdminEndpoint) {
        option (google.api.http) = {
            put: "/api/v2/adminEndpoints/{port}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update admin endpoint";
            description: "Update list of ips that may access the specified port";
            tags: "update admin endpoint";
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Port does not have a corresponding endpoint";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Temporal state and cannot be updated now (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the port";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetAdminEndpoint(GetAdminEndpointRequest) returns (AdminEndpoint) {
        option (google.api.http) = {
            get: "/api/v2/adminEndpoints/{port}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get admin endpoint";
            description: "Get an endpoint corresponding to specified port";
            tags: "get admin endpoint";
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Port does not have a corresponding endpoint";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateResourcePolicy(CreateResourcePolicyRequest) returns (ResourcePolicy) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/resourcePolicies"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create a resource policy.";
            description: "A resource policy";
            tags: "create resource policy";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy with given resource UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreatePolicy(CreatePolicyRequest) returns (Policy) {
        option (google.api.http) = {
            post: "/api/v2/policies"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create a policy.";
            description: "A policy is a set of user-defined rules that should be applied to one or more objects in the system.";
            tags: "create policy";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \n invalid argument is provided \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "One of the given projects wasn't found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            // TODO: currently we don't enforce name uniqueness, but we may want to.
            responses: {
                key: "409";
                value: {
                    description: "Policy with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdatePolicy(UpdatePolicyRequest) returns (UpdatePolicyResponse) {
        option (google.api.http) = {
            put: "/api/v2/policies/{UUID}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a policy.";
            description: "Updates user pre-defined policy by overriding the existing properties with the given arguments.";
            tags: "update policy";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument(s) with one of the following reasons: \nmandatory argument is missing, \nmutually exclusive arguments were provided \ninvalid argument is provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "The given policy wasn't found or the request is not supported.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateResourcePolicy(UpdateResourcePolicyRequest) returns (UpdateResourcePolicyResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/resourcePolicies/{UUID}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a resource policy.";
            description: "update resource policy enable the change of the following attributes:\nretentionTime \nschedulePolicy \ndescription";
            tags: "update resource policy";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters, \ninvalid argument value.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetPolicy(GetPolicyRequest) returns (Policy) {
        option (google.api.http) = {
            get: "/api/v2/policies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get policy.";
            description: "A request to get policy by either name or UUID";
            tags: "get policy";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListPolicies(ListPoliciesRequest) returns (ListPoliciesResponse) {
        option (google.api.http) = {
            get: "/api/v2/policies"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List policies.";
            description: "A request to list policies. The result can be filtered by either name or UUID";
            tags: "list policies";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListResourcePolicies(ListResourcePoliciesRequest) returns (ListResourcePoliciesResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/resourcePolicies"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List resource policies.";
            description: "A request to list resource policies. The result can be filtered by either name or UUID";
            tags: "list resource policies";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetResourcePolicy(GetResourcePolicyRequest) returns (ResourcePolicy) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/resourcePolicies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get resource policy.";
            description: "Get resource policy information by provided UUID/name";
            tags: "get resource policy";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteResourcePolicy(DeleteResourcePolicyRequest) returns (DeleteResourcePolicyResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/resourcePolicies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete resource policy.";
            description: "Delete resource policy information by provided UUID/name";
            tags: "delete resource policy";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeletePolicy(DeletePolicyRequest) returns (DeletePolicyResponse) {
        option (google.api.http) = {
            delete: "/api/v2/policies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete policy.";
            description: "Delete policy information by provided policy UUID";
            tags: "delete policy";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "The given policy to delete wasn't found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateSnapshot(CreateSnapshotRequest) returns (Snapshot) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/snapshots"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create snapshot.";
            description: "A snapshot created from a volume";
            tags: "create snapshot";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the snapshot with given source-volume UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability (updating capacity).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetSnapshot(GetSnapshotRequest) returns (Snapshot) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/snapshots/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get snapshot.";
            description: "Get snapshot by UUID/Name.";
            tags: "get snapshot";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Snapshot with UUID/Name not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListSnapshots(ListSnapshotsRequest) returns (ListSnapshotsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/snapshots"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List snapshots.";
            description: "List can be filtered by UUID/Name.";
            tags: "list snapshot";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteSnapshot(DeleteSnapshotRequest) returns (DeleteSnapshotResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/snapshots/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete snapshot.";
            description: "Deletes snapshot with provided UUID.\nDeletion of a snapshot is a long operation. The status of deletion can be queried by GET operation on the snapshot. As long as the operation runs snapshot state is Deleting. When operation completed GET snapshot returns NotFound error response";
            tags: "delete snapshot";
            responses: {
                key: "404";
                value: {
                    description: "Snapshot with provided UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid UUID or a snapshot state does not allow deletion (Deleting/Failed).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Snapshot is in a temporal state that does not allow deletion currently (Creating/Updating and volume Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the snapshot";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetFeatureFlag(GetFeatureFlagRequest) returns (FeatureFlagStatus) {
        option (google.api.http) = {
            get: "/api/v2/featureFlags/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get feature flag status";
            description: "Get feature flag status enable / disable corresponding to given feature flag name";
            tags: "feature flag";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableFeatureFlag(EnableFeatureFlagRequest) returns (SetFeatureFlagResponse) {
        option (google.api.http) = {
            post: "/api/v2/featureFlags/{name}/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable feature flag";
            description: "Enable feature flag status corresponding to given feature flag name";
            tags: "feature flag";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableFeatureFlag(DisableFeatureFlagRequest) returns (SetFeatureFlagResponse) {
        option (google.api.http) = {
            post: "/api/v2/featureFlags/{name}/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable feature flag";
            description: "Disable feature flag status corresponding to given feature flag name";
            tags: "feature flag";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }
            }
        };
    }

    rpc ListFeatureFlags(ListFeatureFlagsRequest) returns (ListFeatureFlagsResponse) {
        option (google.api.http) = {
            get: "/api/v2/featureFlags"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List feature flags";
            description: "List feature flags";
            tags: "feature flag";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetClusterConfigParam(GetClusterConfigParamRequest) returns (ClusterConfigParam) {
        option (google.api.http) = {
            get: "/api/v2/clusterConfig/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get cluster configuration value according to a given parameter.";
            description: "Get cluster configuration value according to a given parameter.";
            tags: "get cluster config";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Cluster configuration parameter wasn't not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateClusterConfigParam(UpdateClusterConfigParamRequest) returns (UpdateClusterConfigParamResponse) {
        option (google.api.http) = {
            put: "/api/v2/clusterConfig/{configParam.name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update Cluster Config value.";
            description: "Update Cluster Config value.";
            tags: "update cluster config";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Cluster configuration parameter wasn't not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListClusterConfigParams(ListClusterConfigParamsRequest) returns (ListClusterConfigParamsResponse) {
        option (google.api.http) = {
            get: "/api/v2/clusterConfig"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List all cluster configuration parameters values.";
            description: "List all cluster configuration parameters values.";
            tags: "list cluster config";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc RollbackVolume(RollbackVolumeRequest) returns (RollbackVolumeResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/volumes/{UUID}/rollback"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Roll back a volume to a previous snapshot";
            description: "Roll back a volume to a previous snapshot";
            tags: "rollback volume";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Volume or snapshot UUID not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Cannot roll volume back. Volume is deleting.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListChangedBlocks(ListChangedBlocksRequest) returns (ListChangedBlocksResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/snapshots/diff/{snapshotUUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List changed LBAs between a volume's snapshots.";
            description: "List changed LBAs between a volume's snapshots (optionally list all snapshots LBAs)";
            tags: "list changed blocks";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments. Snapshot UUIDs are identical or they are no on same chain or offset-lba exceeds snapshot size";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find snapshot uuid or base snapshot uuid or project name.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal error of Lightbits.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc RotateClusterRootKey (RotateClusterRootKeyRequest) returns (RotateClusterRootKeyResponse){
        option (google.api.http) = {
            post: "/api/v2/cluster/clusterRootKey/rotate"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Rotate cluster root encryption key (Mock).";
            description: "Rotate the Cluster Level Encryption Key (KEK). After the rotation all the DEK's will be encrypted with the new KEK and the new KEK will be stored securely in the Cluster. Note: This feature is not readily available and offers only limited support for evaluative purposes.";
            tags: "encryption";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }

            }
        };
    }

    rpc GetClusterRootKey (GetClusterRootKeyRequest) returns (GetClusterRootKeyResponse){
        option (google.api.http) = {
            get: "/api/v2/cluster/clusterRootkey"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get cluster root encryption key.";
            description: "Securely export the Cluster-Level Encryption Key (KEK). As a security measure, the exported key in the response will be encrypted.";
            tags: "encryption";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }
            }
        };
    }

    rpc CreateIdpConfiguration(CreateIDPConfigurationRequest) returns (IDPConfiguration) {
        option (google.api.http) = {
            post: "/api/v2/cluster/IdpConfiguration"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create an IdP configuration.";
            description: "Create a configuration for a remote Identity Provider (IdP) that may be used to authorize access to the Lighbits cluster. Currently only a single IdP configuration is supported.";
            tags: "idp configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteIdpConfiguration(DeleteIDPConfigurationRequest) returns (DeleteIDPConfigurationResponse) {
        option (google.api.http) = {
            delete: "/api/v2/cluster/IdpConfiguration/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete an IdP configuration.";
            description: "Delete an IdP configuration.";
            tags: "idp configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "IdP configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateIdpConfiguration(UpdateIDPConfigurationRequest) returns (IDPConfiguration) {
        option (google.api.http) = {
            put: "/api/v2/cluster/IdpConfiguration"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update an IdP configuration.";
            description: "Update an IdP configuration.";
            tags: "idp configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "IdP configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListIdpConfigurations(ListIDPConfigurationsRequest) returns (ListIDPConfigurationsResponse) {
        option (google.api.http) = {
            get: "/api/v2/cluster/IdpConfiguration"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Listing IdP configurations.";
            description: "Listing IdP configurations.";
            tags: "idp configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetIdpConfiguration(GetIDPConfigurationRequest) returns (IDPConfiguration) {
        option (google.api.http) = {
            get: "/api/v2/cluster/IdpConfiguration/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get an IdP configuration.";
            description: "Get an IdP configuration.";
            tags: "idp configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "IdP configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateIdpClientConf(CreateIdpClientConfRequest) returns (IdpClientConf) {
        option (google.api.http) = {
            post: "/api/v2/cluster/idpClientConfs"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create an idp-client-configuration.";
            description: "Create an idp-client-configuration.";
            tags: "idp client configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteIdpClientConf(DeleteIdpClientConfRequest) returns (DeleteIdpClientConfResponse) {
        option (google.api.http) = {
            delete: "/api/v2/cluster/idpClientConfs/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete an idp-client-configuration.";
            description: "Delete an idp-client-configuration.";
            tags: "idp client configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "idp-client-configuration with the specidied name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateIdpClientConf(UpdateIdpClientConfRequest) returns (IdpClientConf) {
        option (google.api.http) = {
            put: "/api/v2/cluster/idpClientConfs/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update an idp-client-configuration.";
            description: "Update an idp-client-configuration.";
            tags: "idp client configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "idp-client-configuration with the specigied name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListIdpClientConfs(ListIdpClientConfsRequest) returns (ListIdpClientConfsResponse) {
        option (google.api.http) = {
            get: "/api/v2/cluster/idpClientConfs"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Listing idp-client-configurations.";
            description: "Listing idp-client-configurations.";
            tags: "idp client configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetIdpClientConf(GetIdpClientConfRequest) returns (IdpClientConf) {
        option (google.api.http) = {
            get: "/api/v2/cluster/idpClientConfs/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get an idp-client-configuration.";
            description: "Get an idp-client-configuration.";
            tags: "idp client configuration";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "idp-client-configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateAuthMapEntry(CreateAuthMapEntryRequest) returns (AuthMapEntry) {
        option (google.api.http) = {
            post: "/api/v2/cluster/authMaps"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create an authorization map entry.";
            description: "Create an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Auth map entry";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateAuthMapEntry(UpdateAuthMapEntryRequest) returns (AuthMapEntry) {
        option (google.api.http) = {
            put: "/api/v2/cluster/authMaps/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "update an authorization map entry";
            description: "Update an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Auth map entry";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Auth map entry not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteAuthMapEntry(DeleteAuthMapEntryRequest) returns (DeleteAuthMapEntryResponse) {
        option (google.api.http) = {
            delete: "/api/v2/cluster/authMaps/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete an authorization map entry";
            description: "Delete an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Auth map entry.";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Auth map entry not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetAuthMapEntry(GetAuthMapEntryRequest) returns (AuthMapEntry) {
        option (google.api.http) = {
            get: "/api/v2/cluster/authMaps/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get an authorization map entry.";
            description: "Get an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Auth map entry";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Auth map entry not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListAuthMapEntries(ListAuthMapEntriesRequest) returns (ListAuthMapEntriesResponse) {
        option (google.api.http) = {
            get: "/api/v2/cluster/authMaps"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List all authorization map entries.";
            description: "List all map entries between a clientID/claim/group and an access right (scope and role).";
            tags: "Auth map entry";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableClusterInBandAuth(EnableClusterInBandAuthRequest) returns (EnableClusterInBandAuthResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/inBandAuth/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable In-Band cluster authentication (Beta)";
            description: "Enables NVMe-oF In Band Authentication, This allows Lightbits cluster to selectively restrict the set of NVMe hosts (clients) that are allowed to connect to the NVMe target (Lightbits cluster), and also (optionally), restrict the set NVMe targets that a given NVMe host will trust and connect to. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "encryption";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableClusterInBandAuth(DisableClusterInBandAuthRequest) returns (DisableClusterInBandAuthResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/inBandAuth/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable In-Band cluster authentication (Beta)";
            description: "Disables NVMe-oF In Band Authentication, hosts may connect to Lightbits cluster without establishing trust (the default Lightbits cluster configuration). In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "encryption";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateTrustedHost(CreateTrustedHostRequest) returns (TrustedHost){
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/trustedHosts"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create a trusted host resource.";
            description: "Create a trusted host resource with configuration parameters needed for authentication and NVMe connectivity, When In-Band Authentication is enabled, only trusted hosts may connect to Lightbits cluster. For each trusted host an associated Lightbits resource must be created using this command. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Host with the provided host name and project name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteTrustedHost(DeleteTrustedHostRequest) returns (DeleteTrustedHostResponse){
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/trustedHosts/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete a host.";
            description: "Delete a trusted host configuration. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/ project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetTrustedHost(GetTrustedHostRequest) returns (TrustedHost){
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/trustedHosts/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get a host.";
            description: "Get a trusted host configuration. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/ project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListTrustedHosts(ListTrustedHostsRequest) returns (ListTrustedHostsResponse){
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/trustedHosts"
            additional_bindings {
                get: "/api/v2/hosts"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Return a list of trusted hosts configuration's.";
            description: "Return a list of trusted hosts configuration's. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/ project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateTrustedHost(UpdateTrustedHostRequest) returns (TrustedHost){
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/trustedHosts/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a host.";
            description: "Update a trusted host configuration, optionally modifying labels. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/ project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc SetTrustedHostSecret(SetTrustedHostSecretsRequest) returns (SetTrustedHostSecretsResponse){
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/trustedHostSecrets/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Set the secrets for a host.";
            description: "Set hosts secrets for a trusted host to allow trusted connectivity between Lightbits Cluster and hosts as part of In-Band Authentication support. Specifying a host secret is mandatory for trusted connect of host to Lightbits cluster, Specifying a target secret, either explicitly or by using auto-gen mode, is optional, allowing only trusted Lightbits cluster to connect to host, if no target secret is specified the target secret type will be set to disable. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/ project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetTrustedHostSecret(GetTrustedHostSecretsRequest) returns (GetTrustedHostSecretsResponse){
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/trustedHostSecrets/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get secrets of a host.";
            description: "Get a trusted host secrets required for authentication and connection. In-Band authentication functionality and its APIs are under development, available for evaluative purposes only and should not be used in production clusters.";
            tags: "authentication";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/ project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableFederatedAuthentication(EnableFederatedAuthenticationRequest) returns (EnableFederatedAuthenticationResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/federatedAuthentication/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable Federated Authentication.";
            description: "Enable Federated Authentication.";
            tags: "authentication";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find cluster.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableFederatedAuthentication(DisableFederatedAuthenticationRequest) returns (DisableFederatedAuthenticationResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/federatedAuthentication/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable Federated Authentication.";
            description: "Disable Federated Authentication.";
            tags: "authentication";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find cluster.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }
}


message LogRequest {
    // Optional SkipStatistics
    //
    // Fetch log will download by default all the statistics from the relevant server
    // By passing this parameter fetch logs will skip the statistics collect
    bool   SkipStatistics = 1;
    bool   CaptureCpuAndTcpDump = 2;
    uint32 NumOfDaysToCollectLogs = 3;
    bool   CollectServicesLbcliEtcd = 4;
    uint32 IntervalBetweenBEReadCycles = 5;
    bool   DontCollectlogs = 6;
    string LogFilename = 7;
    uint32 NumOfstatisticsToCapture = 8;
    bool   DontCompressOutput = 9;
    bool   IoNice = 10;
    bool   UseHighCompression = 11;
}

message AdminEndpoint {
    uint32 port = 1;
    repeated string ips = 2;
    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 3;
}


message GetAdminEndpointRequest {
    uint32 port = 1;
}

message ListAdminEndpointsResponse {
    repeated AdminEndpoint adminEndpoints = 1;
}

message ListAdminEndpointsRequest {
    uint32 port = 1;
}

message CreateAdminEndpointRequest {
    uint32 port = 1;
    repeated string ips = 2;
}

message UpdateAdminEndpointRequest {
    uint32 port = 1;
    repeated string ips = 2;
}

message DeleteAdminEndpointRequest {
    uint32 port = 1;
}

message DeleteAdminEndpointResponse {
}

enum CredsType {
    UnknownType = 0;
    RS256PubKey = 1;
    TlsCertChainPem = 2;
    TlsPrivKeyPem = 3;
}

message CreateCredentialRequest {
    string projectName = 1;
    string ID = 2;
    CredsType type = 3;
    bytes payload = 4;
}

// CredsKind specifies the intended usage and origin of the credentials. it can not be
// set directly by the user when uploading credentials and can't be modified at all after the
// credentials were created.
enum CredsKind {
    // Credentials directly managed by the users.
    UserCreds = 0;

    // Credentials that will be used by Lightbits Photon to submit requests either on
    // behalf of the Photon users, or for Photon requests to fetch the cluster metadata.
    //
    // These credentials can be viewed by the users, but can only be modified indirectly,
    // as part of the Beacon service configuration/management process.
    BeaconCreds = 2;

    // Lightbits server encountered credentials possibly created by a newer Lightbits
    // SW version than that running on the server itself.
    UnknownKind = 127;
}

message Credential {
    string projectName = 1;
    string ID = 2;
    CredsType type = 3;
    bytes payload = 4;

    // kind
    //
    // CredsKind specifies the origin and intended usage of the credentials.
    CredsKind kind = 5;
}

message DeleteCredentialRequest {
    string ID = 1;
    string projectName = 2;
}

message DeleteCredentialResponse {
}

message ListCredentialsRequest {
    string projectName = 1;
}

message ListCredentialsResponse {
    repeated Credential credentials = 1;
}

message GetCredentialRequest {
    string ID = 1;
    string projectName = 2;
}

message DefaultPolicy {
    // Policy Type
    //
    // Policy Type. Available types are 'QoS' or 'Snapshot'.
    PolicyType policyType = 1;
    // Policy UUID
    //
    // Policy UUID
    string policyUUID = 2;
}

message CreateProjectRequest {
    // Project Name
    //
    // Project Name
    string name = 1;
    // Project description
    //
    // Brief (up to 256B) description of the project.
    string description = 2;
    // Default policies
    //
    // List of default polices. As of the 2.3.16 release the only default policy that may be specified for project is a QoS policy.
    repeated DefaultPolicy defaultPolicies = 3;
}

message Project {
    // Project UUID
    //
    // Project UUID
    string UUID = 1;
    // Project Name
    //
    // Project Name
    string name = 2;
    // Project description
    //
    // Brief description of project
    string description = 3;
    // Default policies
    //
    // List of default polices specified for this project
    repeated DefaultPolicy defaultPolicies = 4;
}

message DeleteProjectRequest {
    string name = 1;
}

message DeleteProjectResponse {
}

message ListProjectsRequest {
}

message ListProjectsResponse {
    repeated Project projects = 1;
}

message GetProjectRequest {
    string name = 1;
}


message StringList {
    repeated string values = 1;
}

message GetVersionRequest {
}

message CreateVolumeRequest {
    enum SectorSizeEnum {
        sectorSize_Default = 0;
        sectorSize_512B = 512;
        sectorSize_4K = 4096;
    }

    string name = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {pattern: "^[a-zA-Z0-9-_\\.]{1,253}$"}];
    string size = 2;
    // acl
    //
    // Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
    StringList acl = 3;
    // compression
    //
    // valid values: true/enable/enabled or false/disable/disabled
    string compression = 4;
    // replicaCount
    //
    // The number of replicas a volume may have. Valid values are 1, 2, and 3.
    uint32 replicaCount = 5;
    // IPAcl
    //
    // Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE (optional, default: ALLOW_ANY)
    StringList IPAcl = 6;
    // minReplicas
    //
    // not used
    uint32 minReplicas = 7;
    // sectorSize
    //
    // volume sector size. Valid values: 4K (default), 512B
    SectorSizeEnum sectorSize = 8;
    // projectName
    //
    // project name
    string projectName = 9;
    // sourceSnapshotUUID
    //
    // Optionally specify source snapshot to create a clone from (specify either sourceSnapshotUUID or sourceSnapshotName)
    string sourceSnapshotUUID = 10;
    // sourceSnapshotName
    //
    // Optionally specify source snapshot to create a clone from (specify either sourceSnapshotUUID or sourceSnapshotName)
    string sourceSnapshotName = 11;
    // PlacementRestrictions
    //
    // Specify volume affinity labels for placement restrictions
    // This may only be specified for volumes of single replication (replicaCount=1), and where Dynamic Rebalance is disabled (feature flags FailInPlace and ProactiveRebalance, lbcli get feature-flag are false).
    repeated LabelMatchExpression placementRestrictions = 12;
    // qosPolicyID
    //
    // Optionally specify QoS policy to be used by volume (either name or UUID)
    oneof qosPolicyID {
        string qosPolicyUUID = 13;
        string qosPolicyName = 14;
    }
    // labels
    //
    // User defined labels are optional for a volume. Labels are key-value pairs. A volume can have up to 16 labels, label-key and label-value length must be between 1 and 253 characters and may contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and dot (.). When creating a clone, if labels are passed the clone will be created with them, otherwise, the labels are copied from the snapshot used for the clone.
    repeated Label labels = 15;
}

message DeleteVolumeRequest {
    string UUID = 1;
    string name = 2;
    string projectName = 3;
}

message DeleteVolumeResponse {
}

message EnableServerRequest {
    // UUID
    //
    // The server's UUID for the enable server request.
    string UUID = 1;

    // name
    //
    // The server's name for the enable server request.
    string name = 2;
}

message DisableServerRequest {
    // UUID
    //
    // The server's UUID for the disable server request.
    string UUID = 1;

    // ForceDisable
    //
    // When set to True the disable operation bypasses upgradeability (loss of service) check when disabling
    // server. If the evict flag is also set to True, will force eviction of all server data, even if it means losing single
    // replica volumes because they cannot be evicted to another server. Only set both "evict" and "ForceDisable"
    // to True if you are willing to lose your single-replica volumes.
    bool ForceDisable = 2;

    // name
    //
    // The server's name for the disable server request.
    string name = 3;

    // evictData
    //
    // Setting this to True to cause all server data to be evicted from the server.
    // Setting this to 'False' will disable the server while keeping all data on the server, so it will be there when you
    // re-enable it.
    // eviction may fail in some cases, e.g., in case of single replica volume that cant be
    // transferred to another server due to network issues between the servers, the eviction is expected to fail.
    // If you want the data eviction process, even at the risk of potentially losing some data that couldnt be evicted,
    // set both evictData and ForceDisable to True.
    bool evictData = 4;

    // permanentFailureTimeout
    //
    // Setting a value for this parameter will override the permanent failure timeout at the cluster level.
    // This may be used  when a user wants to take a server into maintenance state and avoid data migration
    // during this time. Valid values are 1 hour or longer, "0"  value should be used to specify an infinite timeout.
    // Permanent failure timeout is a string constructed by a decimal number followed
    // by the units: ns, us, ms, s, m, h. For example: 7200s, 120m, 2h
    // This value will be override once the server is re-enabled. Default value: null
    google.protobuf.Duration permanentFailureTimeout = 5;
}

message DeleteServerRequest {
    // UUID
    //
    // The server's UUID for the delete server request.
    string UUID = 1;

    // name
    //
    // The server's name for the delete server request.
    string name = 2;

    // forceDelete
    //
    // Optional. Setting forceDelete will override some of the delete
    // server pre-checks.
    // When set to False (default), a server cannot be deleted if
    // there are any resources attached to the server (e.g., node replace
    // was issued, server nodes entered permanent failure states and
    // resources were migrated.)
    // When set to True the delete operation bypasses checks to verify
    // if server still has any resources attached to it and starts the
    // delete operation in the background. The operation will not
    // complete and will remain in the background until the server
    // resources will have been detached from the server.
    // Note that a server with volumes/snapshots/clones with a single
    // replica cannot be deleted, even with forceDelete set to
    // True. You must remove the 1x replica volumes/snapshots/clones
    // before deleting the server.
    bool forceDelete = 3;
}

message ReplaceNodeRequest {
    string SrcNodeUUID = 1;
    string TargetNodeUUID = 2;
    bool   ReplaceWhileActive = 3;
}

message CreateServerRequest {
    // serverEndpoints
    //
    // Etcd member endpoint. In current version, only a single point is allowed.
    repeated string serverEndpoints = 1;
    string serverUUID = 2;
    // reuseIP
    //
    // Optional. When true, bypasses validation if given endpoint is used by another server
    bool reuseIP = 3;
    // extendCluster
    //
    // Optional. When true, the cluster is extended with new server and its resources, enabling new volumes placement on the server (nodes of this server will come up as active). Default is False (the nodes of this server will be added to cluster as unattached, and may be used to move over resources from an existing failed server using replace node api command).
    bool extendCluster = 4;
}

message UpdateVolumeRequest {
    string UUID = 1;
    // acl
    //
    // Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
    StringList acl = 2;
    // IPAcl
    //
    // Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE
    StringList IPAcl = 3;
    string size = 4;
    // compression
    //
    // valid values: true/enable/enabled or false/disable/disabled
    string compression = 5;
    // project name
    //
    string projectName = 6;
    // qos policy uuid
    //
    oneof qosPolicyID {
        string qosPolicyUUID = 7;
        string qosPolicyName = 8;
    }
    // Force
    //
    // To intentionally shrink volume size, provide updated volume size and set force to true
    bool Force = 9;
    string name = 10;

    // labels
    //
    // User defined labels are optional for a volume. Labels are key-value pairs. A volume can have up to 16 labels, label-key and label-value length must be between 1 and 253 characters and may contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and dot (.). If labels are passed during volume update the existing volume's labels are replaced with the new ones. Otherwise, the labels are untouched.
    repeated Label labels = 11;
}

message UpgradeServerRequest {
    string UUID = 1;
    // InstallPkgUri
    //
    // URI of Lightbits package to install
    string InstallPkgUri = 2;
    // ForceUpgrade
    //
    // Optional. When true, bypasses the upgradability (loss of service) check.
    bool ForceUpgrade = 3;
    // ProxyInfo
    //
    // Optional. Proxy server information for upgrade behind proxy.
    ProxyInfo ProxyInfo = 4;
}

message UpgradeClusterRequest {
    // InstallPkgUri
    //
    // URI of Lightbits package to install
    string InstallPkgUri = 1;
    // UUIDs
    //
    // Optional. Servers with given UUIDs are upgraded. If not given, all servers in the cluster are upgraded according to upgradability (loss of service) check.
    repeated string UUIDs = 2;
    // ProxyInfo
    //
    // Optional. Proxy server information for upgrade behind proxy.
    ProxyInfo ProxyInfo = 3;
}

message EnableClusterEncryptionRequest {
    enum KeyStore {
        file = 0;
        tpm = 1;
    }
    // KeyStore
    //
    // Optional. Where to store the Encryption KEK on file or in tpm.
    KeyStore keyStore = 1;
}

message GetClusterRequest {
}

message UpdateNvmeDeviceRequest {
    string serverUUID = 1;
    string serialNumber = 2;
    string ledPattern = 3;
}

message AddNvmeDeviceRequest {
    string serialNumber = 1;
    string nodeUUID = 2;
}


message GetHostRequest {
    string hostNQN = 1;
}

message ListHostsRequest {
    string hostNQN = 1;
    string volumeUUID = 2;
}

message ListHostsResponse {
	repeated ConnectedHost connectedHosts = 1;
}

message ListNodeRequest {
    string name = 1;
    string UUID = 2;
    string failureDomain = 3;
}

message ListEventsRequest {
    string projectName = 1;
    // nextToken
    //
    // Optional. Specifies the first event to return when using consecutive paginated requests. Use the nextToken returned in the response of the previous request as the indication for the first event new request should fetch. Usually, the value of nextToken is an event ID.
    string nextToken = 2;
    // since
    //
    // Optional. Return a list of events with a timestamp not earlier than the given timestamp. Timestamp format must be given in UTC Time in ISO-8601, e.g: 2000-01-01T12:00:00.000Z.
	string since = 3;
    // until
    //
    // Optional. Return a list of events with a timestamp not later than the given timestamp. Timestamp format must be given in UTC Time in ISO-8601, e.g: 2000-01-01T12:00:00.000Z.
	string until = 4;
    // limit
    //
    // Optional. Set a limit to number of events to be returned in this response.
	int64 limit = 6;
    // severity
    //
    // Optional. Return only events of the given severity.
	repeated string severity = 7;
    // component type
    //
    // Optional.Return only events of the given component type.
	string componentType = 8;
}

message ListEventsResponse {
    repeated Event events = 1;
    string nextToken = 2;
}

message GetVolumeRequest {
    string UUID = 1;
    string name = 2;
    string projectName = 3;
}

message GetNodeRequest {
    string UUID = 1;
}

message ListVolumeRequest {
    string UUID = 1;
    string name = 2;
    string failureDomain = 3;
    // offsetUUID
    //
    // Optional. When provided, returned list starts with next to offsetUUID volume.
    string offsetUUID = 4;
    // limit
    //
    // Optional. Limits the number of volumes in the response.
    int64 limit = 5;
    //
    string projectName = 6;
    // source snapshot UUID
    //
    // Optional. Return only volumes created from this source snapshot.
    string snapshotUUID = 7;
    // showAll
    //
    // Optional. Show also volumes in Deleting state
    bool showAll = 8;
}

message ListNvmeDevicesRequest {
    string nodeUUID = 1;
    string serverUUID = 2;
}

message GetNvmeDeviceRequest {
    string Serial = 1;
}

message ListNvmeDevicesResponse {
    repeated UserNvmeDevicesResponse NvmeDevices = 1;
}

message ConnectedHost {
    string hostNQN = 1;
    string iPAddress = 2;
    string hostname = 3;
    //volumeUUIDs
    //
    // list of volumes to which this host connects to
    repeated string volumeUUIDs = 4;
}

message UserNvmeDevicesResponse {
    enum StateEnum {
        None = 0;
        Healthy = 1;
        Adding = 2;
        Rebuilding = 3;
        Failed = 4;
    }

    // Total capacity of the device in bytes
    uint64 size = 1;
    // The NUMA node ID this device is associated with
    uint64 numaNodeID = 2;
    // model
    //
    // Model string of the device, if exists
    string model = 3;
    // serial
    //
    // Serial of the block device, if exists
    string serial = 4;
    // server uuid
    //
    // The UUID of the server to which the block device is installed
    string serverUUID = 5;
    // device state
    //
    // Describes the state of the device, unmanaged device state will be None
    StateEnum state = 6;
        // device time of failure
    //
    // Timestamp that will be updated in case the device has failed
    google.protobuf.Timestamp failureTime = 7;
    // device rebuild completion time
    //
    // Timestamp that will be updated once GFTL has completed
    // to rebuild all the data that the device had, and we are safe
    // for second failure
    google.protobuf.Timestamp rebuildCompletionTime = 8;
    // name
    //
    // Device name or address
    string name = 9;
    // node uuid that manages the device
    //
    // The UUID of the node that manages the device, empty string if the device is not managed
    string nodeUUID = 12;
    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 13;
    // Statistics
    //
    // Various nvme-device related statistics
    NvmeDeviceStatisticsApi statistics = 14;
}

message DurosNodeInfo {
    enum State {
        // 0
        //
        // reserved value, default should return error, rather than a true  state that is incorrect
        Unknown = 0;
        // 1
        //
        // node is completed join cluster flow
        Active = 1;
        // 2
        //
        // node is is the process of coming up (starting required services) and joining cluster
        Activating = 2;
        // 3
        //
        // node is is Inactive (this includes internal states Removing and failed)
        Inactive = 3;
        // 4
        //
        // node is not attached to cluster (none of cluster pgs contain this pg)
        Unattached = 4;
        // 6
        //
        // Attaching node to cluster ongoing (replacing old node in pgs with this node)
        Attaching = 6;
        // 7
        //
        // Detaching node from cluster ongoing (replacing this node in pgs with this a new node)
        Detaching = 7;
    }
    // machine readable internal state of the node we want to report to the cluster.
    enum StatusEnum {
        NoStatus = 0;
        // reported during NodeStateEnum==Adding
        ConnectivityOK = 1;
        ConnectivityProblem = 2;
        // reported during NodeStateEnum==Removing
        IssuedDeletePeer = 3;
    }
    string name = 1;
    string UUID = 2;
    State state = 3;
    StatusEnum status = 4;
    // peer <ip>:<port> service data-path IP
    string nvmeEndpoint = 5;
    repeated string failureDomains = 6;
    string failureInfo = 7;
    string hostname = 9;
    bool inLocalRebuild = 10;
    uint32 localRebuildProgress = 11;
    int32 numManagedDevices = 12;
    uint32 maxNvmeDevices = 13;
    bool ec = 14;
    NodeStatisticsApi statistics = 15;
    string serverUUID = 16;
    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 17;
    bool readOnly = 18;
    uint32 powerupProgress = 19;
    bool permanentFailure = 20;
}

message ListNodesResponse {
    repeated DurosNodeInfo nodes = 1;
}

message ListVolumesResponse {
    repeated Volume volumes = 1;
}

message UpdateNvmeDeviceResponse {}

message AddNvmeDeviceResponse {}

message UpdateVolumeResponse {}

message UpgradeServerResponse {}

message UpgradeClusterResponse {}

message EnableClusterEncryptionResponse {}

message ReplaceNodeResponse {}

message DeleteServerResponse {}

message DisableServerResponse {}

message ListServersRequest {
    string UUID = 1;
    string Name = 2;
    Server.RiskOfServiceLossEnum RiskOfServiceLoss = 3;
}

message GetServerRequest {
    string UUID = 1;
}

message ListServersResponse {
    repeated Server servers = 1;
}

message ClusterUpgradeStatusResponse {
    ClusterInfo cluster = 1;
}

message ListUpgradeStatusResponse {
    repeated Server servers = 1;
}

message Version {
    //latest user API version
    string apiVersion = 4;
}

message ClusterLastUpgrade {
    enum UpgradeStatusEnum {
        Unknown = 0;
        None = 1;
        UpgradeFailed = 2;
        Upgrading = 3;
    }

    // Status
    //
    // The status of the upgrade operation
    UpgradeStatusEnum Status = 1;

    // StartTime
    //
    // The time of the upgrade task start
    google.protobuf.Timestamp StartTime = 2;

    // EndTime
    //
    // The time of closing the upgrade task (completed or failed). Reset when next upgrade starts.
    google.protobuf.Timestamp EndTime = 3;

    // TargetVersion
    //
    // The version that shall be installed by the end of the process.
    string TargetVersion = 4;

    // ErrorMessage
    //
    // Free formatted text, describes the error if such occurred.
    string ErrorMessage = 5;

    // ProgressStep
    //
    // Current upgrade step. You can use ProgressTotal to calculate percentage as ProgressStep/ProgressTotal.
    uint32 ProgressStep = 6;

    // ProgressTotal
    //
    // Total possible upgrade progress steps.
    uint32 ProgressTotal = 7;
}

message ClusterInfo {
    enum AuthenticationMode {
        UnKnown = 0;
        Enabled  = 2;
        Disabled  = 3;
    }

    // cluster UUID
    //
    // UUID of cluster
    string UUID = 1;
    // subsystemNQN
    //
    // Subsystem NQN that shall be used by the hosts to connect to volumes on this cluster.
    string subsystemNQN = 2;
    // Current maximum number of replicas per volume
    //
    // A maximal number of replicas that a new volume can have, given current state of the nodes. This value depends on the healthiness of the nodes.
    uint32 currentMaxReplicas = 3;
    // Maximum number of replicas per volume supported by cluster.
    //
    // A maximal number of replicas that volume can have, given cluster installation parameters (Number of Servers, Failure Domains...).
    uint32 supportedMaxReplicas = 4;
    // cluster statistics
    //
    // cluster statistics (storage capacity, used storage, compression ration...)
    ClusterStatisticsApi statistics = 5;
    // Etag
    //
    // identifier for a specific version of a resource.
    string ETag = 6;
    // Cluster Health
    //
    // Cluster health: OK- cluster healthy, Warning - Inactive node(s) and/or degraded volumes in cluster, Error - ReadOnly/Unavailable volumes in cluster.
    ClusterHealth health = 7;
    // Minimal Lightbits version
    //
    // Lowest version of Lightbits running on one of the servers in cluster.
    string MinVersionInCluster = 8;
    // Minimal allowed Lightbits version
    //
    // For Lightbits internal use.
    string MinAllowedVersion = 9;
    // Maximal allowed Lightbits version
    //
    // Lightbits version this cluster may be upgraded to.
    string MaxAllowedVersion = 10;
    // Addresses of the API Service
    //
    // A list of REST/gRPC endpoints - <ip>:<port> pairs that the API listen on.
    // Example entries:
    // - 192.168.16.16:443
    // - 192.168.16.17:443
    repeated string apiEndpoints = 11;
    // Addresses of the Discovery Service
    //
    // A list of TCP endpoints - <ip>:<port> pairs that the Discovery Service listen on.
    // Example entries:
    // - 192.168.16.16:8009
    // - 192.168.16.17:8009
    repeated string discoveryEndpoints = 12;
    // cluster name
    //
    // cluster name.
    string clusterName = 13;

    // lastUpgrade
    //
    // Parameters of the last (or active) cluster upgrade process
    ClusterLastUpgrade lastUpgrade = 14;
    AuthenticationMode inBandAuthMode = 15;

    // encryptionStatus
    //
    // Information about the state of Cluster Level Encryption
    ClusterEncryptionStatus encryptionStatus = 16;

    // federatedAuthenticationStatus
    //
    // Information about the state of Federated Authentication
    FederatedAuthenticationStatus federatedAuthenticationStatus = 17;
}

message ClusterInfoV2 {
    // cluster UUID
    //
    // UUID of cluster
    string UUID = 1;
    // subsystemNQN
    //
    // Subsystem NQN that shall be used by the hosts to connect to volumes on this server.
    string subsystemNQN = 2;
    // Current maximum number of replicas per volume
    //
    // A maximal number of replicas that a new volume can have, given current state of the nodes. This value depends on the healthiness of the nodes.
    uint32 currentMaxReplicas = 3;
    // Maximum number of replicas per volume supported by cluster
    //
    // A maximal number of replicas that volume can have, given cluster installation parameters.
    uint32 supportedMaxReplicas = 4;
    // Etag
    //
    // identifier for a specific version of a resource.
    string ETag = 6;
    // Addresses of the API Service
    //
    // A list of REST/gRPC endpoints - <ip>:<port> pairs that the API listen on.
    // Example entries:
    // - 192.168.16.16:443
    // - 192.168.16.17:443
    repeated string apiEndpoints = 11;
    // Addresses of the Discovery Service
    //
    // A list of TCP endpoints - <ip>:<port> pairs that the Discovery Service listen on.
    // Example entries:
    // - 192.168.16.16:8009
    // - 192.168.16.17:8009
    repeated string discoveryEndpoints = 12;
    // Addresses of the NVMe endpoints
    //
    // A list of TCP endpoints - <ip>:<port> pairs that the NVMe targets listen on.
    // Example entries:
    // - 192.168.16.16:4420
    // - 192.168.16.17:4420
    repeated string nvmeEndpoints = 13;
    // cluster name
    //
    // cluster name.
    string clusterName = 14;

    // lastUpgrade
    //
    // Parameters of the last (or active) cluster upgrade process
    ClusterLastUpgrade lastUpgrade = 15;

    // encryptionStatus
    //
    // Information about the state of Cluster Level Encryption
    ClusterEncryptionStatus encryptionStatus = 16;
}

message ClusterHealth {
    enum State {
        None        = 0;
        OK          = 1;
        Warning     = 2;
        Error       = 3;
    }
    State state = 1;
    uint32 numDegradedVolumes = 2;
    uint32 numReadOnlyVolumes = 3;
    uint32 numNotAvailableVolumes = 4;
    uint32 numInactiveNodes = 5;
    uint32 numHealthyVolumes = 6;
}

enum ProtectionStateEnum {
    Unknown = 0;
    FullyProtected = 1;
    Degraded = 2;
    ReadOnly = 3;
    NotAvailable = 4;
}

message Volume {
    enum StateEnum {
        Unknown = 0;
        Creating = 1;
        Available = 2;
        Deleting = 3;
        Deleted = 4;
        Failed = 7;
        Updating = 8;
        Rollback = 9;
        Migrating = 10;
    }
    enum ProtocolEnum {
        ProtocolTCP = 0;
    }

    StateEnum state = 1;
    ProtectionStateEnum protectionState = 2;
    // replicaCount
    //
    // The number of replicas a volume may have. Valid values are 1, 2, and 3.
    uint32 replicaCount = 3;
    // nodeList
    //
    // List of node UUIDs this volume is placed over.
    repeated string nodeList = 4;
    string UUID = 5;
    // NSID
    //
    // Volume's Namespace ID
    uint32 nsid = 6;
    // acl
    //
    // Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
    StringList acl = 7;
    // compression
    //
    // valid values: true/enable/enabled or false/disable/disabled
    string compression = 8;
    uint64 size = 9;
    string name = 10;
    string rebuildProgress = 11;
    VolumeStatisticsApi statistics = 12;
    // IPAcl
    //
    // Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE (optional, default: ALLOW_ANY)
    StringList IPAcl = 13;
    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 14;
    repeated string connectedHosts = 15;
    // sectorSize
    //
    // volume sector size. Valid values: 4K (default), 512B
    uint32 sectorSize = 16;
    // projectName
    //
    // project name
    string projectName = 17;
    // sourceSnapshotUUID
    //
    // For a cloned volume specify source snapshot of this clone
    string sourceSnapshotUUID = 18;
    // sourceSnapshotName
    //
    // For a cloned volume specify source snapshot of this clone
    string sourceSnapshotName = 19;
    repeated LabelMatchExpression placementRestrictions = 20;
    // qosPolicyUUID
    //
    // Optional volume's QoS policy UUID (if not specified project policy is used)
    string qosPolicyUUID = 21;
    // qosPolicyName
    //
    // Optional volume's QoS policy name (if not specified project policy is used)
    string qosPolicyName = 22;
    // primaryNodeUUID
    //
    // UUID of the primary node data is Read/Written for this volume.
    string primaryNodeUUID = 23;
    // creationTime
    //
    // Time of volume creation (UTC).
    google.protobuf.Timestamp creationTime = 24;
    // labels
    //
    // Optionally add labels to a volume.
    repeated Label labels = 25;
}

message ServerEvictionStatus {
    enum StatusEnum {
        None        = 0;
        Failed      = 1;
        Evicting    = 2;
        Aborting    = 3;
        Completed   = 4;
        Aborted     = 5;
    }
    // status
    //
    // The status of the eviction operation
    StatusEnum status = 1;

    // startTime
    //
    // Start time of eviction operation.
    google.protobuf.Timestamp startTime = 2;

    // endTime
    //
    // Completion time of eviction operation (either a successfully completed or ended due to failure).
    google.protobuf.Timestamp endTime = 3;

    // errorMessage
    //
    // Error message from the last eviction operation.
    string errorMessage = 4;

    // progress
    //
    // Current eviction progress given in units of percent
    uint32 progress = 5;
}

message ServerLastUpgrade {
    enum UpgradeStatusEnum {
        Unknown = 0;
        None = 1;
        UpgradeFailed = 2;
        Upgrading = 3;
        Rebooting = 4;
        Recovering = 5;
    }

    // Status
    //
    // The status of the upgrade operation
    UpgradeStatusEnum Status = 1;

    // StartTime
    //
    // The time of the upgrade task start
    google.protobuf.Timestamp StartTime = 2;

    // EndTime
    //
    // The time of closing the upgrade task (completed or failed).
    google.protobuf.Timestamp EndTime = 3;

    // TargetVersion
    //
    // The version that shall be installed by the end of the process.
    string TargetVersion = 4;

    // ErrorMessage
    //
    // Last error message. Free text formatted string describes the problem.
    string ErrorMessage = 5;

    // ProgressStep
    //
    // Current upgrade step. You can use ProgressTotal to calculate percentage as ProgressStep/ProgressTotal.
    uint32 ProgressStep = 6;

    // ProgressTotal
    //
    // Total possible upgrade progress steps.
    uint32 ProgressTotal = 7;
}

message Server {
    enum UpgradeStatusEnum {
        Unknown = 0;
        None = 1;
        UpgradeFailed = 2;
        Upgrading = 3;
        Rebooting = 4;
        Recovering = 5;
    }
    enum RiskOfServiceLossEnum {
        UnknownRiskOfServiceLoss = 0;
        NoRiskOfServiceLoss = 1;
        InRiskOfServiceLoss = 2;
        SourceOfRiskOfServiceLoss = 3;
    }
    enum ServerStateEnum {
        UnknownState   = 0;
        Creating  = 1;
        Enabled   = 2;
        Deleting  = 3;
        Failed    = 4;
        Disabled  = 5;
        Enabling  = 6;
        Disabling = 7;
    }

    string UUID = 2;
    string name = 3;
    // risk of service loss state
    //
    // indicates the ability to upgrade or disable a server without loss of service to cluster volumes
    RiskOfServiceLossEnum RiskOfServiceLossState = 4;
    repeated string NodesUUIDs = 5;
    ServerStateEnum state = 6;
    repeated string ServerEndpoints = 7;

    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 8;

    // LightOSVersion
    //
    // The current LightOS version
    string LightOSVersion = 9;

    // UpgradeStatus
    //
    // Deprecated: This field indicates the status of the upgrade operation
    UpgradeStatusEnum UpgradeStatus = 10;

    // ApiEndpoints
    //
    // The API endpoints
    repeated string ApiEndpoints = 11;

    // LastUpgrade
    //
    // Parameters of the last (or active) server upgrade process
    ServerLastUpgrade LastUpgrade = 12;

    // IsWitness
    bool IsWitness = 13;

    // LastEviction
    //
    // Parameters of the last (or active) server eviction process
    ServerEvictionStatus LastEviction = 14;
    // Server Health
    //
    // Server health: OK- server healthy, Warning high utilisation or failed disk under rebuild, Error - Inactive nodes or nodes nearing/in Read-only.
    ClusterHealth.State health = 15;
    // Server Permanent failure configuration
    //
    // Permanent failure timeout at the server level. If set, overrides the cluster configuration. value of "0" sets it to infinite.
    google.protobuf.Duration ServerPermanenetFailureTimeout = 16;
}

message GetRoleRequest {
    string name = 1;
    string projectName = 2;
}

message GetRoleResponse {
    Role role = 1;
}

message Role {
    string name = 1;
    string projectName = 2;
    // rulesJson
    //
    // a JSON representation of the role 'rules' array, e.g.:
    //   [{"resources":["versions"],"actions":["get"]}]
    string rulesJson = 4;
}

message ListRolesRequest {
    string projectName = 1;
}

message ListRolesResponse {
    repeated Role roles = 1;
}

message Snapshot {
    enum StateEnum {
        Unknown = 0;
        Creating = 1;
        Available = 2;
        Deleting = 3;
        Deleted = 4;
        Failed = 7;
    }

    StateEnum state = 1;
    string UUID = 2;
    string name = 3;
    string description = 4;
    google.protobuf.Timestamp creationTime = 5;
    google.protobuf.Duration retentionTime = 6;
    string sourceVolumeUUID = 7;
    string sourceVolumeName = 8;
    uint32 replicaCount = 9;
    repeated string nodeList = 10;
    uint32 nsid = 11;
    StringList acl = 12;
    bool compression = 13;
    uint64 size = 14;
    StringList IPAcl = 15;
    uint32 sectorSize = 16;
    SnapshotStatisticsApi statistics = 18;
    string ETag = 19;
    string projectName = 20;
    string primaryNodeUUID = 21;
    // labels
    //
    // Once a snapshot is taken, the volume's labels are copied to the snapshot. Once a clone is created, if the user does not pass new labels on clone creation, the cloned volume labels are copied from the source snapshot labels.
    repeated Label labels = 22;
}

message DeleteSnapshotRequest {
    string UUID = 1;
    string name = 2;
    string projectName = 3;
}

message CreateSnapshotRequest {
    // name
    //
    // The name of the snapshot
    string name = 1;
    // sourceVolumeUUID
    //
    // The UUID of the volume to create the snapshot from.
    // You should specify either the UUID or the name.
    // If both UUID and name as specified, the UUID takes precedence.
    string sourceVolumeUUID = 2;
    // sourceVolumeName
    //
    // The name of the volume to create the snapshot from.
    // You should specify either the UUID or the name.
    // If both UUID and name as specified, the UUID takes precedence.
    string sourceVolumeName = 3;
    // retentionTime
    //
    // The length of time in seconds to retain this snapshot for.
    google.protobuf.Duration retentionTime = 4;
    // description
    //
    // A short description (up to 256B) of the snapshot.
    string description = 5;
    // projectName
    //
    // The name of the project this snapshot belongs to
    string projectName = 6;
}

message ListSnapshotsRequest {
    string UUID = 1;
    string Name = 2;
    string projectName = 3;
    // offsetUUID
    //
    // Optional. When provided, returned list starts with next to offsetUUID volume.
    string offsetUUID = 4;
    // limit
    //
    // Optional. Limits the number of snapshots in the response.
    int64 limit = 5;
    // showAll
    //
    // Optional. Show also snapshots in Deleting state
    bool showAll = 6;
}

message GetSnapshotRequest {
    string UUID = 1;
    string Name = 2;
    string projectName = 3;
}

message ListSnapshotsResponse {
    repeated Snapshot snapshots = 1;
}
message DeleteSnapshotResponse {
}

message FeatureFlagStatus {
    string name = 1;
    bool enabled = 2;
}

message GetFeatureFlagRequest{
    string name = 1;
}

message EnableFeatureFlagRequest {
    string name = 1;
}

message DisableFeatureFlagRequest {
    string name = 1;
}

message SetFeatureFlagResponse {}

message ListFeatureFlagsRequest {}

message ListFeatureFlagsResponse {
    map<string, FeatureFlagStatus> featureFlags = 1;
}

message CreateResourcePolicyRequest {
    // name
    //
    // The name of the resource policy
    string name = 1;
    // resourceUUID
    //
    // The resource UUID. If both name and UUID are provided, the name
    // is ignored and only the UUID is used.
    string resourceUUID = 2;
    // resourceName
    //
    // The resource name. If both name and UUID are provided, the name
    // is ignored and only the UUID is used.
    string resourceName = 3;
    // projectName
    //
    // The project this resource policy belongs to.
    string projectName = 4;
    // schedulePolicy
    //
    // The schedule policy for this resource policy.
    lightbits.api.duros.v2.SchedulePolicy schedulePolicy = 5;
    // description
    //
    // A short (up to 256B) description for this resource.
    string description = 6;
}

message CreatePolicyRequest {
    // Policy name
    //
    // Policy name
    string name = 1;
    // Policy description
    //
    // Policy description, up to 256B in length
    string description = 2;
    // The policy
    //
    // Details of the policy to create
    oneof policy {
        QoSRateLimitPolicy qoSRateLimitPolicy = 3;
        // in the future we will move here schedule policy as well as other policies.
    }
}

message UpdatePolicyRequest {
    // UUID
    //
    // The UUID of the policy request to update. If both name and UUID are provided,
    // the name is ignored.
    string UUID = 1;
    // name
    //
    // The name of the policy request to update. If both name and UUID are provided,
    // the name is ignored.
    string name = 2;
    // description
    //
    // A short (up to 256B) description for this resource.
    string description = 3;
    // policy
    //
    // At the moment, this can only be the QoSRateLimitPolicy to be updated
    oneof policy {
        QoSRateLimitPolicy qoSRateLimitPolicy = 4;
        // in the future we will move here schedule policy as well as other policies.
    }
}

message UpdatePolicyResponse {}

message ResourcePolicy {
    enum State {
        UnknownState = 0;
        Creating     = 1;
        Active       = 2;
        Deleting     = 3;
        Failed       = 4;
    }

    string UUID = 1;
    string name = 2;
    string resourceUUID = 3;
    string resourceName = 4;
    string projectName = 5;
    lightbits.api.duros.v2.SchedulePolicy schedulePolicy = 6;
    string description = 7;
    State state = 8;
}

message Policy {
    enum State {
        Unknown    = 0;
        Creating   = 1;
        Active     = 2;
        Updating   = 3;
        Deprecated = 4;
        Failed     = 5;
    }

    string UUID = 1;
    string name = 2;
    string description = 3;
    State state = 4;
    oneof info {
        QoSRateLimitPolicy QoSRateLimitPolicy = 5;
    }
}

message UpdateResourcePolicyRequest {
    // UUID
    //
    // The UUID of the resource policy request to update
    string UUID = 1;
    // projectName
    //
    // The name of the project this resource policy request belongs to
    string projectName = 2;
    // schedulePolicy
    //
    // The updated schedule policy
    lightbits.api.duros.v2.SchedulePolicy schedulePolicy = 3;
    // description
    //
    // An updated short (up to 256B) description
    string description = 4;
}

message UpdateResourcePolicyResponse {}

message ListPoliciesRequest {
    string UUID = 1;
    string name = 2;
    string projectName = 3;
}

message ListPoliciesResponse {
    repeated Policy policies = 1;
}

message ListResourcePoliciesRequest {
    string UUID = 1;
    string projectName = 2;
    string volumeUUID  = 3;
}

message ListResourcePoliciesResponse {
    repeated ResourcePolicy resourcePolicies = 1;
    repeated DefaultGlobalResourcePolicy defaultResourcePolicies = 2;
}

message GetPolicyRequest {
    string UUID = 1;
    string name = 2;
    string projectName = 3;
}

message GetResourcePolicyRequest {
    string UUID = 1;
    string projectName = 2;
}

message DeleteResourcePolicyRequest {
    string UUID = 1;
    string projectName = 3;
}

message DeleteResourcePolicyResponse {}

message DeletePolicyRequest {
    string UUID = 1;
    string name = 2;
}

message DeletePolicyResponse {}

message GetClusterConfigParamRequest {
    // ClusterConfigParam name
    //
    // specify name of parameter to get: ClusterName/ ClockDriftIntervalForRaisingEvent/ DeviceHealthIntervalForRaisingEvent/
    // DurationToTurnIntoPermanentFailure/ VolumeDeletionFromNodeDelay/ DefaultQoSName
    string name = 1;
}

message ClusterConfigParam {
    // ClusterConfigParam name
    //
    // specify name of parameter to update: ClusterName [string]/ ClockDriftIntervalForRaisingEvent [time]/ DeviceHealthIntervalForRaisingEvent [time]/
    // DurationToTurnIntoPermanentFailure [time]/ VolumeDeletionFromNodeDelay [time]/ DefaultQoSName [valid QoS policy name]
    string name = 1;
    // ClusterConfigParam value
    //
    // value of cluster config parameter, where the specific units are specific to the specified parameter
    string value = 2;
}

message UpdateClusterConfigParamRequest {
    ClusterConfigParam configParam = 1;
}

message RollbackVolumeRequest {
    //
    // volume UUID
    string UUID = 1;
    //
    // source snapshot UUID
    string srcSnapshotUUID = 2;
    //
    // project name
    string projectName = 3;
    //
    // volume name
    string Name = 4;
    //
    // source snapshot name
    string srcSnapshotName = 5;
}

message RollbackVolumeResponse {}

message UpdateClusterConfigParamResponse {}

message ListClusterConfigParamsRequest {}

message ListClusterConfigParamsResponse {
    repeated ClusterConfigParam values = 1;
}

message LabelValueKeyPair {
    enum Key {
        Unknown = 0;
        FD = 1;
        PrimaryFD = 2;
    };

    Key key = 1;
    string value = 2;
}

message LabelMatchExpression {
    enum Operator {
        Unknown = 0;
        In = 1;
    };
    // Volume affinity operation
    //
    // Volume affinity operator, In specifies that placement logic will match nodes that have labels in labelValueKeyPairs list
    Operator operator = 1;
    // Volume affinity operation Key/Value pairs
    //
    // Volume affinity KeyPairs, Key currently must be fd (failure domain), value should specify the failure domains we want to match
    repeated LabelValueKeyPair labelValueKeyPairs = 2;
}

//ID of the impacted component (uuid/ip/serial number)
message ComponentVolumeInfo {
    // volume uuid
    string ID = 1;
    // volume name
    string Name = 2;
}

message VolumeComponentInfoList {
    repeated ComponentVolumeInfo VolumeComponentInfoList = 1;
}

message ComponentVolumesInfo {
    map<string, VolumeComponentInfoList> ProjectVolumesMap = 1;
}

message ComponentNodeInfo {
    // Node uuid
    string ID = 1;
    // Node name
    string Name = 2;
}

message ComponentClusterInfo {
    // cluster uuid
    string ID = 1;
    // cluster name
    string Name = 2;
}

message ComponentNVMeSSDInfo {
    // NVMe serial number
    string ID = 1;
    // SSD name
    string Name = 2;
}

message ComponentServerInfo {
    // Server UUID
    string ID = 1;
    // Server name
    string Name = 2;
}

message ComponentDataIntegrityInfo {
    string NodeUUID = 1;
    string ServerUUID = 2;
    repeated string SSDs = 3;
}

message LBARange {
    uint64 lbaStart = 1;
    uint64 lbaEnd = 2;
    bytes dataBitMap = 3;
}

 message ListChangedBlocksRequest {
    // snapshotUUID
    //
    // Target snapshot UUID for comparison. (specify either snapshotUUID or snapshotName)
    string snapshotUUID = 1;
    // baseSnapshotUUID
    //
    // Source snapshot UUID for comparison. Optional in case of full comparison.
    // (specify either baseSnapshotUUID or baseSnapshotName)
    string baseSnapshotUUID = 2;
    // projectName
    //
    // Project name
    string projectName = 3;
    // offsetLBA
    //
    // The first offset from which the comparison shall start, aligned to 64 and rounded down
    uint64 offsetLBA = 4;
    // snapshotName
    //
    // Target snapshot name for comparison. (specify either snapshotUUID or snapshotName)
    string snapshotName = 5;
    // baseSnapshotName
    //
    // Source snapshot name for comparison. Optional in case of full comparison
    // (specify either baseSnapshotUUID or baseSnapshotName)
    string baseSnapshotName = 6;
}

 message ListChangedBlocksResponse {
    // nextOffsetLBA
    //
    // LBA Offset for next call, zero at the last call (when end of LBA range has been reached)
    uint64 nextOffsetLBA = 1;
    // lbaRanges
    //
    // List of ranges of the target snapshot UUID that differs from the base snapshot UUID
    repeated LBARange lbaRanges = 2;
 }

// Event that will be returned to user
message Event {
    enum EventType {
        UnknownType = 0;
        Cluster = 1;
        Node = 2;
        Volume = 3;
        NVMeSSD = 4;
        Server = 5;
        DataIntegrity = 6;
        ClusterEncryption = 7;
    }

    enum EventReportingService {
        UnkownReportingService = 0;
        CM = 1;
        NM = 2;
        API = 3;
        UM = 4;
    }

    enum EventSeverity {
        UnkownSeverity = 0;
        Info = 1;
        Low = 2;
        Medium = 3;
        High = 4;
        Critical = 5;
    }

    // Event UUID
    string ID = 1;
    // Event start time
    google.protobuf.Timestamp Time = 2;
    // The component type impacted by the event
    EventType Type = 3;
    //The severity of the event
    EventSeverity Severity = 4;
    //The name of the event
    string EventName = 5;
    //The code of the cause of the event
    uint32 EventCode = 6;
    // The server that logged the event (Cluster Manager, Node Manager, etc)
    EventReportingService ReportingService = 7;
    // The event ID related to this event.
    string AssociatedEventID = 8;
    // Current status of the component
    string Status = 9;
    // The Cause of the event
    uint32 CauseCode = 10;
    // The Event Description
    string Description = 11;
    // Component info (specific to type)
    oneof ComponentInfo {
        ComponentVolumesInfo ComponentVolumesInfo = 201;
        ComponentNVMeSSDInfo ComponentNVMeSSDInfo = 202;
        ComponentNodeInfo ComponentNodeInfo = 203;
        ComponentServerInfo ComponentServerInfo = 204;
        ComponentClusterInfo ComponentClusterInfo = 205;
        ComponentDataIntegrityInfo ComponentDataIntegrityInfo = 206;
    }
}

enum PolicyVisibility {
    // Unavailable
    //
    // Unavailable - will be returned upon get/list QoS policies to non-cluster admin callers, or to all callers of "list" QoS policies if the result is filtered out by project name.
    Unavailable = 0;
    // Scoped
    //
    // Scoped - Indicates a private (scoped) policy (available only to projects specified in projectsNamesScope)
    Scoped = 1;
    // Global
    //
    // Global - indicates a global policy (available for all projects/volumes in cluster)
    Global = 2;
}

message QoSRateLimitPolicy {
    // TODO: i think we can omit the prefix QoSLimit from the messages below
    // They will inherit the name of the outer message as prefix

    // A limit of 0 means no rate limit.
    // Bandwidth limit is in units of MB/s.
    message QoSLimitIOPS {
        // writeIOPSLimit
        //
        // Volume write bandwidth limits, specified in units of IOPs. The granularity increases by 256 IOPs each time. 0 means unlimited.
        uint32 writeIOPSLimit = 1;
        // readIOPSLimit
        //
        // Volume read bandwidth limits, specified in units of IOPs. The granularity increases by 256 IOPs each time. 0 means unlimited.
        uint32 readIOPSLimit = 2;
    }
    message QoSLimitBW{
        // writeBWLimit
        //
        // Volume write bandwidth limits, specified in units of MB/s. The granularity must be in full MB/s. 0 means unlimited.
        uint32 writeBWLimit = 1;
        // readBWLimit
        //
        // Volume read bandwidth limits, specified in units of MB/s. The granularity must be in full MB/s. 0 means unlimited.
        uint32 readBWLimit = 2;
    }
    message QoSLimitIOPSPerGB {
        // writeIOPSPerGBLimit
        //
        // Volume write bandwidth limits, specified in units of IOPs per GB of volume size. 0 means unlimited.
        uint32 writeIOPSPerGBLimit = 1;
        // readIOPSPerGBLimit
        //
        // Volume read bandwidth limits, specified in units of IOPs per GB of volume size. 0 means unlimited.
        uint32 readIOPSPerGBLimit = 2;
    }

    // projectsNamesScope
    //
    // Lists the projects that have access to this policy (relevant if policyVisibility=Scoped)
    repeated string projectsNamesScope = 3;
    // Policy Visibility
    //
    // Policy Visibility, specifics who has access to this policy
    PolicyVisibility policyVisibility = 4;
    oneof QoSLimit {
        QoSLimitIOPS limitIOPS = 6;
        QoSLimitBW limitBw = 7;
        QoSLimitIOPSPerGB limitIOPSPerGB = 8;
    }
}

enum PolicyType {
    // Unknown
    //
    // For internal use only
    unknown = 0;
    // Snapshot
    //
    // Create snapshots per volumes policy
    snapshot = 1;
    // QosRateLimit
    //
    // Volumes QoS rate limit policy
    qosRateLimit = 2;
}

message DefaultGlobalResourcePolicy {
    PolicyType policyType = 1;
    string policyUUID = 2;
}

message UpdateProjectRequest {
    string projectName = 1;
    repeated DefaultPolicy defaultPolicies = 2;
}

message UpdateProjectResponse {}

message ClusterEncryptionStatus {
    enum State {
        Disabled = 0; // Encryption is disabled
        Enabling = 1; // Enabling cluster encryption
        Enabled = 2;  // Cluster encryption is enabled
        Unknown = 3;  // Unknown state
    }

    State encryptionState = 1;
    uint64 kekGeneration = 2;
    google.protobuf.Timestamp kekUpdateDate = 3;
}

enum IdpHealthStatus {
    IdpHealthStatus_Healthy = 0;
    IdpHealthStatus_UnHealthy = 1;
    IdpHealthStatus_Unknown = 2;
}

message IdpHealthInfo {
    string serverName = 1;
    IdpHealthStatus idpHealthStatus = 2;
    google.protobuf.Timestamp timestamp = 3;
    string healthErrorMessage = 4;
}

message FederatedAuthenticationStatus {
    bool federatedAuthenticationEnabled = 1;
    repeated IdpHealthInfo idpHealthInfos = 2;
}

message RotateClusterRootKeyRequest {}

message RotateClusterRootKeyResponse {}

message GetClusterRootKeyRequest {
    // encryptingKeyGeneration
    //
    // The Generation key you want to export, if not specified the latest key will be exported.
    uint64 encryptingKeyGeneration = 1;
    // userPublicKey
    //
    // Public key to use in order to encrypt the exported KEK.
    bytes userPublicKey = 2;
}

message GetClusterRootKeyResponse {
    message KeyObject{
        // encryptedKey
        //
        // Cluster Encryption key encrypted with the given public key.
        bytes encryptedKey = 1;
        // encryptingKeyGeneration
        //
        // The Generation of the exported key.
        uint64 encryptingKeyGeneration = 2;
    }
    // keys
    //
    // The object that includes each exported key and its generation.
    KeyObject key = 1;
}

enum IDPType {
    unknownIdp = 0;
    ADFS     = 1;
}

// IDPConfiguration represents the configuration for the Identity Provider (IdP) in LB cluster.
message IDPConfiguration {
    enum IDPConfigurationState {
        // 0
        //
        // For internal use only.
        Unknown    = 0;
        // 1
        //
        // The IdP configuration is being created.
        Creating   = 1;
        // 2
        //
        // The IdP configuration is active.
        Active     = 2;
        // 3
        //
        // The IdP configuration is being updated.
        Updating   = 3;
        // 4
        //
        // Failed to create a new IdP configuration.
        Failed     = 4;
    }

    //
    // Unique name identyfing this IdP configuration.
    string name = 1;
    //
    // The URL of the Identity Provider (IdP) issuer.
    string idpIssuerURL = 2;
    //
    // The current state of the IdP configuration.
    IDPConfigurationState state = 3;
    //
    // Type of an IdP (Identity Provider). currently only ADFS is supported.
    IDPType Type = 4;
    //
    // The UUID of this IdP configuration.
    string UUID = 5;
    //
    // Optional. Proxy server information for an IdP that is accessed via proxy.
    ProxyInfo ProxyInfo = 6;
}

message CreateIDPConfigurationRequest {
    //
    // The unique name to assign to this IdP configuration.
    string name = 1;
    //
    // The URL of the Identity Provider (IdP) issuer.
    string idpIssuerURL = 2;
    //
    // Type of an IdP (Identity Provider). currently only ADFS is supported.
    IDPType Type = 3;
    //
    // Optional. Proxy server information for an IdP that is accessed via proxy.
    ProxyInfo ProxyInfo = 4;
}

message UpdateIDPConfigurationRequest {
    //
    // Specify name of the IdP configuration to update.
    string name = 1;
    // 
    // The URL of the Identity Provider (IdP) issuer.
    string idpIssuerURL = 2;
    // 
    // The type of an IdP (Identity Provider). currently only ADFS is supported
    IDPType Type = 3;
    //
    // Optional. Proxy server information for an IdP that is accessed via proxy.
    ProxyInfo ProxyInfo = 4;

}

message ListIDPConfigurationsRequest{}

message ListIDPConfigurationsResponse{
    repeated IDPConfiguration IDPConfigurations = 1;
}

message GetIDPConfigurationRequest {
    string name = 1;
}

message DeleteIDPConfigurationRequest {
    string name = 1;
}

message DeleteIDPConfigurationResponse {}

// idp-client-configuration represents a configuration of an client specific IdP entry in LB cluster.
// Lighbits cluster supports IdP client configurations with three types of authorization modes:
// App, User, and Converge.
// App authorization mode should be used when Lightbit should map a specific client to a scope and role.
// User authorization mode should be used when Lightbits should map according to both the client ID and a specific claim in the JWT.
// Converge mode is used when Lightbits should map only according to the claim in the JWT. In this mode the client ID is ignored.
// Only a single such entry may be created for each IdP configuration. Lightbits API service would first attempt to check for a
// dedicated IdP client configuration using this client ID. falling back to to an optional converge entry only if no direct client specific
// entry is found.
 message IdpClientConf {
    //
    // The UUID of the idp-client-config entry.
    string UUID = 1;
    //
    // A unique name of the idp-client-conf.
    string name = 2;
    // clientId
    //
    // A unique client ID identifier registered in the IdP to identify a
    //  specific application (or a client) that wants to access resources
    //  from Lightbits cluster.
    //  When using converge authorization mode, this field must be configured to:
    //  NOT_APPLICABLE.
    string clientId = 3;
    //
    // A reference to the IdP configuration that will use this client
    //  configuration.
    string idpConfName = 4;
    //
    // When working in user authorization/converge mode, the claim name specifies
    //  the name of the field in JWT claim from which to extract the identifier
    //  value from.
    //  Note, this field is only required when authzMode is user or converge.
    string claimName = 5;
    // authzMode
    //
    // The authorization mode will determine what info from access JWT
    //  will be mapped to matching scope/role in Lightbits cluster.  
    //  The autherization mode can be one of the following:
    //  user, app, converge.
    AuthorizationMode authzMode = 6;
}

message CreateIdpClientConfRequest {
    //
    // A unique name of the idp-client-conf.
    string name = 1;
    // clientId
    //
    // A unique client ID identifier registered in the IdP to identify a
    //  specific application (or a client) that wants to access resources
    //  from Lightbits cluster.
    //  When using converge authorization mode, this field must be configured to:
    //  NOT_APPLICABLE.
    string clientId = 2;
    //
    // A reference to the IdP configuration that will use this client
    //  configuration.
    string idpConfName = 3;
    //
    // When working in user authorization/converge mode, the claim name specifies
    //  the name of the field in JWT claim from which to extract the identifier
    //  value from.
    //  Note, this field is only required when authzMode is user or converge.
    string claimName = 4;
    //
    // The authorization mode will determine what info from access JWT
    //  will be mapped to matching scope/role in Lightbits cluster.  
    //  The autherization mode can be one of the following:
    //  user, app, converge.
    AuthorizationMode authzMode = 5;
}

message UpdateIdpClientConfRequest {
    //
    // The name of the idp-client-conf to update.
    string name = 1;
    //
    // When working in user authorization/converge mode, the claim name specifies
    //  the name of the field in JWT claim from which to extract the identifier
    //  value from.
    //  Note, this field is only required when authzMode is user or converge.
    string claimName = 2;
}

message GetIdpClientConfRequest {
    //
    // The name of the idp-client-conf to get.
    string name = 1;
}

message DeleteIdpClientConfRequest {
    //
    // The name of the idp-client-conf to delete.
    string name = 1;
}

message DeleteIdpClientConfResponse {}

message ListIdpClientConfsRequest{}

message ListIdpClientConfsResponse{
    repeated IdpClientConf IdpClientConfs = 1;
}

message AuthMapEntry {
    reserved "state";
    reserved 1;
    // 
    // AuthMapEntry UUID
    string UUID = 2;
    // 
    // Name of specific authorization mapping entry.
    string name = 3;
    // 
    // Identifier to map application or clientID/claim/group to Lightbits scope/role.
    //  This should either have the clientID of the relevant application (app mode) or
    //  an identifier of a specific claim/group exctracted from the field specified by claimName
    //  (user or converge modes).
    string identifier = 4;
    // 
    // Represents the scope assgined to this client/claim/group  in Lightbits cluster.
    string scope = 5;
    // 
    // Represents the role assgined to this client/claim/group in Lightbits cluster.
    string role = 6;
    // 
    // IdP configuration that is associated with this authorization map entry.
    string idpConfigurationName = 7;
}

message CreateAuthMapEntryRequest {
    // 
    // Name of specific authorization mapping entry.
    string name = 1;
    // 
    // Identifier to map application or clientID/claim/group to Lightbits scope/role.
    //  This should either have the clientID of the relevant application (app mode) or
    //  an identifier of a specific claim/group exctracted from the field specified by claimName
    //  (user or converge modes).
    string identifier = 2;
    // 
    // Represents the scope assgined to this client/claim/group  in Lightbits cluster.
    string scope = 3;
    // 
    // Represents the role assgined to this client/claim/group in Lightbits cluster.
    string role = 4;
    // 
    // Idp configuration that is associated with this authorization map entry.
    string idpConfigurationName = 5;
}

message UpdateAuthMapEntryRequest {
    // 
    // Name of specific authorization mapping entry.
    string name = 1;
    // 
    // Represents the scope assgined to this client/claim/group  in Lightbits cluster.
    string scope = 2;
    // 
    // Represents the role assgined to this client/claim/group in Lightbits cluster.
    string role = 3;
    // 
    // Identifier to map application or claim/group to Lightbits scope/role.
    //  This should either have the clientID of the relevant application (app mode) or
    //  an identifier of a specific claim/group exctracted from the field specified by claimName
    //  (user or converge modes).
    string identifier = 4;
    // 
    // IdP configuration that is associated with this authorization map entry.
    string idpConfigurationName = 5;
}

message DeleteAuthMapEntryRequest {
    // 
    // Name of specific authorization mapping entry.
    string name = 1;
}

message GetAuthMapEntryRequest {
    // 
    // Name of specific authorization mapping entry.
    string name = 1;
}

message ListAuthMapEntriesRequest {}

message DeleteAuthMapEntryResponse {}

message ListAuthMapEntriesResponse {
    repeated AuthMapEntry AuthMapEntries = 1;
}

message EnableFederatedAuthenticationRequest {}

message EnableFederatedAuthenticationResponse {}

message DisableFederatedAuthenticationRequest {}

message DisableFederatedAuthenticationResponse {}

enum fedAuthState {
    FederatedAuthenticationDisabled = 0;
    FederatedAuthenticationEnabled = 1;
}

message GetFederatedAuthenticationStatusResponse {
    fedAuthState federatedAuthenticationState = 1;
}
