syntax = "proto3";

package lightbits.api.duros.v2;

option go_package = "duros/v2;v2";

import "google/protobuf/timestamp.proto";
import "google/protobuf/duration.proto";
import "google/api/annotations.proto";
import "google/api/httpbody.proto";
import "grpc/gateway/protoc_gen_swagger/options/annotations.proto";
import "lightbits/api/duros/v2/statisticsapiv2.proto";
import "lightbits/api/duros/v2/schedule_policy.proto";
import "lightbits/api/duros/v2/security.proto";
import "lightbits/api/duros/v2/labels.proto";
import "lightbits/api/duros/v2/authz_mode.proto";
import "lightbits/api/duros/v2/proxy_info.proto";
import "lightbits/api/duros/v2/cf.proto";


service DurosAPI {
    rpc GetVersion(GetVersionRequest) returns (Version) {
        option (google.api.http) = {
            get: "/api/v2/version"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Product Version.";
            description: "Get product version information.";
            tags: "Cluster operations";
        };
    }

    rpc CreateVolume(CreateVolumeRequest) returns (Volume) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/volumes"
            body: "*"
            additional_bindings {
                post: "/api/v2/volumes"
                body: "*"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create volume.";
            description: "A volume has a user-defined name, capacity, and a string-based Access Control List (ACL).\nUser can also select to enable compression and define IP-ACL (IP address-based control list).";
            tags: "Volume operations";
            responses: {
                key: "409";
                value: {
                    description: "A volume with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "An invalid argument was provided, due to one of the following reasons: \n a mandatory argument is missing, \n name contains illegal characters, \n size is not a positive integer, \n replica count is outside of a valid range, \n ACL or IP-ACL are invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteVolume(DeleteVolumeRequest) returns (DeleteVolumeResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/volumes/{UUID}"
            additional_bindings {
                delete: "/api/v2/volumes/{UUID}"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete volume.";
            description: "Deletes a volume according to the provided UUID or Name.\nDeletion of a volume is a long operation. The status of deletion can be queried by a GET operation on the volume. As long as the operation runs, the volume state is Deleting. Once the operation has completed, GET volume returns a NotFound error response.";
            tags: "Volume operations";
            responses: {
                key: "404";
                value: {
                    description: "Volume with provided UUID or Name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid UUID, Name, or volume state does not allow deletion (Deleting/Failed).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Volume is in a temporary state that does not currently allow deletion (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the volume";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListVolumes(ListVolumeRequest) returns (ListVolumesResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/volumes"
            additional_bindings {
                get: "/api/v2/volumes"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List volumes.";
            description: "List can be filtered by failure domain. List can be partially returned by given offset UUID and size of the list. If offset is not provided, list is returned from the start. If offset UUID is provided, list starts from the next volume after the provided offset UUID. If limit is provided, length of the returned list is bounded by the limit. If limit is not provided, list is returned until the end. projectName is mandatory unless you are the admin. List can also be filtered by a specific source snapshot.";
            tags: "Volume operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListEvents(ListEventsRequest) returns (ListEventsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/events"
            additional_bindings {
                get: "/api/v2/events"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get all Lightbits events from cluster.";
            description:  "API to pull the events from the aggregated cluster event log.";
            tags: "Cluster operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability. Specify only a single parameter to filter events: componentType, ProjectName, or Severity.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Project not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetHost(GetHostRequest) returns (ConnectedHost) {
        option (google.api.http) = {
            get: "/api/v2/connectedHosts/{hostNQN}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get connected host information.";
            description: "Get connected host information given by hostNQN.";
            tags: "Host operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided host NQN is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListHosts(ListHostsRequest) returns (ListHostsResponse) {
        option (google.api.http) = {
            get: "/api/v2/connectedHosts"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get a list of connected hosts.";
            description: "List all hosts connected to a cluster, or only connected hosts associated with a volume.";
            tags: "Host operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided volume UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetVolume(GetVolumeRequest) returns (Volume) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/volumes/{UUID}"
            additional_bindings {
                get: "/api/v2/volumes/{UUID}"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get volume information.";
            description: "Get volume information by provided UUID";
            tags: "Volume operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided volume UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListNodes(ListNodeRequest) returns (ListNodesResponse) {
        option (google.api.http) = {
            get: "/api/v2/nodes"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get list of nodes.";
            description: "List Nodes. An option to filter is done by the following parameters: 1. Name - e.g., api/v2/nodes?Name=<Name> 2. UUID - e.g.,  api/v2/nodes?UUID=<UUID> 3. FailureDomain - e.g.,  api/v2/nodes?FailureDomain=<FailureDomain>";
            tags: "Node operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument, or several mutually exclusive arguments are provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetNode(GetNodeRequest) returns (DurosNodeInfo) {
        option (google.api.http) = {
            get: "/api/v2/nodes/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get node information.";
            description: "Get node information identified by the UUID of the node.";
            tags: "Node operations";
            responses: {
                key: "404";
                value: {
                    description: "Node UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListNvmeDevices(ListNvmeDevicesRequest) returns (ListNvmeDevicesResponse) {
        option (google.api.http) = {
            get: "/api/v2/nvmeDevices"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve a list of NVMe devices, with optional filtering selections.";
            description: "A request to list NVMe devices is exposed via this API. The list of NVMe devices can be filtered by the following parameters:  1. ServerUUID - e.g., api/v2/nvmeDevices?ServerUUID=<UUID> 2. NodeUUID - e.g., api/v2/nvmeDevices?NodeUUID=<UUID>.";
            tags: "NVMe device operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetNvmeDevice(GetNvmeDeviceRequest) returns (UserNvmeDevicesResponse) {
        option (google.api.http) = {
            get: "/api/v2/nvmeDevices/{Serial}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve a specific NVMe device with a filtering option.";
            description: "Request NVMe device information according to it's serial number. Example usage: api/v2/nvmeDevices/15eb21c0-35ae-478d-b.";
            tags: "NVMe device operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Serial is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc FetchLogs(LogRequest) returns (stream google.api.HttpBody) {
        option (google.api.http) = {
            get: "/api/v2/logs"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve server logs and other information.";
            description: "Retrieve all server logs. This command will trigger a dedicated Lightbits script that will package all server logs and information them into a tarball file then fetch the tarball file.";
            tags: "Cluster operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetCluster(GetClusterRequest) returns (ClusterInfo) {
        option (google.api.http) = {
            get: "/api/v2/cluster"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve cluster information.";
            description: "Cluster information - e.g., cluster UUID and SubsystemNQN - is exposed via this API.";
            tags: "Cluster operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetClusterInfo(GetClusterRequest) returns (ClusterInfoV2) {
        option (google.api.http) = {
            get: "/api/v2/clusterinfo"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve cluster information.";
            description: "Cluster information for tenants - e.g., cluster UUID and SubsystemNQN - is exposed via this API.";
            tags: "Cluster operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateNvmeDevice(UpdateNvmeDeviceRequest) returns (UpdateNvmeDeviceResponse) {
        option (google.api.http) = {
            post: "/api/v2/nvmeDevices/{serialNumber}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update NVMe device on a node.";
            description: "Update NVMe device defined by serial number on a server defined by server UUID.";
            tags: "NVMe device operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Empty serial or empty server UUID is provided, the device is already attached to another node, the number of node's managed devices reached the maximum, node is not listed as server's node for the server that the device belongs to, or node is not active.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Serial or server UUID not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the device.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc AddNvmeDevice(AddNvmeDeviceRequest) returns (AddNvmeDeviceResponse) {
        option (google.api.http) = {
            post: "/api/v2/nvmeDevices"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Add NVMe device to a node.";
            description: "Add NVMe device identified by its serial number to a node identified by its UUID. If the NVMe device is already used by another node, or cannot be attached to the node, the command fails.";
            tags: "NVMe device operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Empty serial or empty node UUID is provided, the device is already attached to another node, the number of node's managed devices reached the maximum, the node is not listed as the server's node for the server that device belongs to, or the node is not active.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Serial or node UUID not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the device";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateVolume(UpdateVolumeRequest) returns (UpdateVolumeResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/volumes/{UUID}"
            body: "*"
            additional_bindings {
                put: "/api/v2/volumes/{UUID}"
                body: "*"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            description: "Update volume enables the change of the following attributes:\n size\n compression\n ACL list\n IP-ACL list\n QoS\n labels.";
            summary: "Update volume.";
            tags: "Volume operations";
            responses: {
                key: "404";
                value: {
                    description: "Returned when the volume with given UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Volume is in temporary state and cannot be updated now (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument or a volume is in a state that cannot be updated (Deleting/Failed).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability (updating capacity).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the volume.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetServer(GetServerRequest) returns (Server) {
        option (google.api.http) = {
            get: "/api/v2/servers/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve specific server information, based on UUID.";
            description: "Request server information, identified by UUID.";
            tags: "Server operations";
            responses: {
                key: "404";
                value: {
                    description: "Server with provided UUID does not exist.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListServers(ListServersRequest) returns (ListServersResponse) {
        option (google.api.http) = {
            get: "/api/v2/servers"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Retrieve servers list with optional filtering parameters.";
            description: "Retrieve servers list. The results can be filtered by supplying the following filters: 1. Name - e.g., /api/v2/servers?Name=<Name> 2. UUID - e.g.,  /api/v2/servers?UUID=<UUID>.";
            tags: "Server operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpgradeServer(UpgradeServerRequest) returns (UpgradeServerResponse) {
        option (google.api.http) = {
            post: "/api/v2/servers/{UUID}/upgrade"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Upgrade server.";
            description: "Upgrades server given by UUID with a package pointed by URI. Since upgrading a server is a long operation, the status of the upgrade shall be fetched from server object";
            tags: "Upgrade operations";
            responses: {
                key: "404";
                value: {
                    description: "UUID not found";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid UUID or URI.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpgradeCluster(UpgradeClusterRequest) returns (UpgradeClusterResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/upgrade"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Upgrade cluster.";
            description: "Upgrades servers in the cluster one by one. Only servers that do not cause loss of service are upgraded. The progress and status of the upgrade operation can be monitored by be polling the server object.";
            tags: "Upgrade operations";
            responses: {
                key: "404";
                value: {
                    description: "One of the provided UUIDs is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid UUID or URI.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableClusterEncryption(EnableClusterEncryptionRequest) returns (EnableClusterEncryptionResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/encryption/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable Cluster level encryption.";
            description: "Enables cluster-level encryption. Once enabled, each volume will be encrypted with a Data Encryption Key (DEK), which is in turn encrypted by a Key Encryption Key (KEK). In the body, users can select the KeyStore type: tpm or file. Note: cluster encryption cannot be disabled once enabled.";
            tags: "Encryption operations";
            responses: {
                key: "500";
                value: {
                    description: "System internal error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Encryption is already enabled or enabling.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Precondition failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }
            }
        };
    }

    rpc CreateServer(CreateServerRequest) returns (Server) {
        option (google.api.http) = {
            post: "/api/v2/servers"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create Server.";
            description: "A request to create a new server. The required parameters for operation are:  1. serverEndpoints - URL list of the new server IP addresses as well as etcd ports for peer communication e.g.: http://10.0.0.1:2380.";
            tags: "Server operations";
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Multiple endpoints provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Server with UUID or endpoint already exists (reuseIP flag was not used).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ReplaceNode(ReplaceNodeRequest) returns (ReplaceNodeResponse) {
        option (google.api.http) = {
            post: "/api/v2/nodes/{SrcNodeUUID}/replace"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Replace Node.";
            description: "The request is identified by the UUID of the replaced node (referred to as SrcNodeUUID).\nThe required parameters in the body are:\n1. TargetNodeUUID - the UUID of the target node that replaces the src Node. The command will succeed only if srcNode is Inactive, and targetNode is Unattached. Users should disable the server of the srcNode (that will make the node Inactive), and assure that targetNode is Unattached (possibly as a new node without assigned PGs or by replacing its PG to another node).";
            tags: "Node operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument provided. Source and target nodes are not in the correct states.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "One of the provided UUIDs is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on one of the nodes.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "429";
                value: {
                    description: "Too many commands in progress.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteServer(DeleteServerRequest) returns (DeleteServerResponse) {
        option (google.api.http) = {
            delete: "/api/v2/servers/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete Server.";
            description: "A request to delete a server. This operation will delete a server (information) from the Lightbits cluster. The required parameters in the body are:  1. UUID - UUID of the server to delete.";
            tags: "Server operations";
            responses: {
                key: "404";
                value: {
                    description: "Server with UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Missing or Invalid UUID is provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableServer(EnableServerRequest) returns (Server) {
        option (google.api.http) = {
            post: "/api/v2/servers/{UUID}/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable Server.";
            description: "Enable a disabled server. Enabling a server causes the server nodes to synchronize with their peers and rebuild the replicas they hold.";
            tags: "Server operations";
            responses: {
                key: "404";
                value: {
                    description: "Server with UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Missing or Invalid UUID is provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableServer(DisableServerRequest) returns (DisableServerResponse) {
        option (google.api.http) = {
            post: "/api/v2/servers/{UUID}/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable server.";
            description: "Server is disabled from the cluster. Server nodes become Inactive and do not participate in data protection. If the 'evict' parameter is True, all data on the server is evicted from the server before it is disabled. Once a server is disabled, it can be enabled and added back to the cluster or removed from the cluster completely.";
            tags: "Server operations";
            responses: {
                key: "404";
                value: {
                    description: "Server with UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Bad request: Missing/Invalid UUID is provided or disable server can lead to risk of service loss state.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the server.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }


    rpc CreateProject(CreateProjectRequest) returns (Project) {
        option (google.api.http) = {
            post: "/api/v2/projects"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create project.";
            description: "A project has a name, a description, and a default QOS rate limit policy.";
            tags: "Project operations";
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateProject(UpdateProjectRequest) returns (UpdateProjectResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update Project Default Policy.";
            description: "Update project's default resource policy.";
            tags: "Project operations";
            responses: {
                key: "400";
                value: {
                    description: "Mandatory argument is missing.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteProject(DeleteProjectRequest) returns (DeleteProjectResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete project.";
            description: "Deletes project with provided name.";
            tags: "Project operations";
            responses: {
                key: "404";
                value: {
                    description: "Project with provided name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid name or the project is not allowed to be deleted.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListProjects(ListProjectsRequest) returns (ListProjectsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List projects.";
            description: "list all projects.";
            tags: "Project operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetProject(GetProjectRequest) returns (Project) {
        option (google.api.http) = {
            get: "/api/v2/projects/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get project.";
            description: "Get project by name";
            tags: "Project operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided project name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateCredential(CreateCredentialRequest) returns (Credential) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/credentials"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create credential.";
            description: "A credential has a name and description.";
            tags: "Access control operations";
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters, \nsize is not a positive integer, \nreplica count is outside of a valid range, \nACL or IP-ACL is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteCredential(DeleteCredentialRequest) returns (DeleteCredentialResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/credentials/{ID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete credential.";
            description: "Deletes credential with provided ID.";
            tags: "Access control operations";
            responses: {
                key: "404";
                value: {
                    description: "Credential with provided ID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid name or the credential is not allowed to be deleted.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListCredentials(ListCredentialsRequest) returns (ListCredentialsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/credentials"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List credentials.";
            description: "List credentials.";
            tags: "Access control operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetCredential(GetCredentialRequest) returns (Credential) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/credentials/{ID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get credential.";
            description: "Get credential by ID.";
            tags: "Access control operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided credential ID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetRole(GetRoleRequest) returns (GetRoleResponse) {
        option (google.api.http) = {
	     get: "/api/v2/projects/{projectName}/roles/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get role.";
            description: "Get role by name.";
            tags: "Access control operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Provided role name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListRoles(ListRolesRequest) returns (ListRolesResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/roles"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List all roles defined in a project.";
            description: "List roles";
            tags: "Access control operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
     }

     rpc CreateAdminEndpoint(CreateAdminEndpointRequest) returns (AdminEndpoint) {
        option (google.api.http) = {
            post: "/api/v2/adminEndpoints"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create admin endpoint.";
            description: "Allow access to a specified port for all specified IPs.";
            tags: "Admin endpoint operations";
            responses: {
                key: "409";
                value: {
                    description: "Port already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteAdminEndpoint(DeleteAdminEndpointRequest) returns (DeleteAdminEndpointResponse) {
        option (google.api.http) = {
            delete: "/api/v2/adminEndpoints/{port}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete admin endpoint.";
            description: "Delete endpoint corresponding to a specified port.";
            tags: "Admin endpoint operations";
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Port does not have a corresponding endpoint.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Temporary state that does not currently allow deletion (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the port.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }

        };
    }

    rpc ListAdminEndpoints(ListAdminEndpointsRequest) returns (ListAdminEndpointsResponse) {
        option (google.api.http) = {
            get: "/api/v2/adminEndpoints"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List admin endpoints.";
            description: "List can be filtered by port.";
            tags: "Admin endpoint operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }


    rpc UpdateAdminEndpoint(UpdateAdminEndpointRequest) returns (AdminEndpoint) {
        option (google.api.http) = {
            put: "/api/v2/adminEndpoints/{port}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update admin endpoint.";
            description: "Update list of ips that may access the specified port.";
            tags: "Admin endpoint operations";
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Port does not have a corresponding endpoint.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Temporary state; cannot be updated now (Creating/Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the port.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetAdminEndpoint(GetAdminEndpointRequest) returns (AdminEndpoint) {
        option (google.api.http) = {
            get: "/api/v2/adminEndpoints/{port}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get admin endpoint.";
            description: "Get an endpoint corresponding to a specified port.";
            tags: "Admin endpoint operations";
            responses: {
                key: "400";
                value: {
                    description: "Port is invalid.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Port does not have a corresponding endpoint.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateResourcePolicy(CreateResourcePolicyRequest) returns (ResourcePolicy) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/resourcePolicies"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create a resource policy.";
            description: "A resource policy.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy with a given resource UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreatePolicy(CreatePolicyRequest) returns (Policy) {
        option (google.api.http) = {
            post: "/api/v2/policies"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create a policy.";
            description: "A policy is a set of user-defined rules that should be applied to one or more objects in the system.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \n invalid argument is provided \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "One of the given projects was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            // TODO: currently we don't enforce name uniqueness, but we can want to.
            responses: {
                key: "409";
                value: {
                    description: "Policy with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdatePolicy(UpdatePolicyRequest) returns (UpdatePolicyResponse) {
        option (google.api.http) = {
            put: "/api/v2/policies/{UUID}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a policy.";
            description: "Updates user pre-defined policy by overriding the existing properties with the given arguments.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument(s) with one of the following reasons: \nmandatory argument is missing, \nmutually exclusive arguments were provided \ninvalid argument is provided.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "The given policy was not found or the request is not supported.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateResourcePolicy(UpdateResourcePolicyRequest) returns (UpdateResourcePolicyResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/resourcePolicies/{UUID}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a resource policy.";
            description: "Update resource policy enable the change of the following attributes:\nretentionTime \nschedulePolicy \ndescription";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters, \ninvalid argument value.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetPolicy(GetPolicyRequest) returns (Policy) {
        option (google.api.http) = {
            get: "/api/v2/policies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get policy.";
            description: "A request to get policy by either name or UUID.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListPolicies(ListPoliciesRequest) returns (ListPoliciesResponse) {
        option (google.api.http) = {
            get: "/api/v2/policies"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List policies.";
            description: "A request to list policies. The result can be filtered by either name or UUID.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListResourcePolicies(ListResourcePoliciesRequest) returns (ListResourcePoliciesResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/resourcePolicies"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List resource policies.";
            description: "A request to list resource policies. The result can be filtered by either name or UUID.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetResourcePolicy(GetResourcePolicyRequest) returns (ResourcePolicy) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/resourcePolicies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get resource policy.";
            description: "Get resource policy information by provided UUID/name";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteResourcePolicy(DeleteResourcePolicyRequest) returns (DeleteResourcePolicyResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/resourcePolicies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete resource policy.";
            description: "Delete resource policy information by provided UUID/name.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the resource policy UUID/name is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeletePolicy(DeletePolicyRequest) returns (DeletePolicyResponse) {
        option (google.api.http) = {
            delete: "/api/v2/policies/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete policy.";
            description: "Delete policy information by provided policy UUID.";
            tags: "Policy operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "The given policy to delete was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateSnapshot(CreateSnapshotRequest) returns (Snapshot) {
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/snapshots"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create snapshot.";
            description: "Create a snapshot from a volume.";
            tags: "Snapshot operations";
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid argument with one of the following reasons: \nmandatory argument is missing, \nname contains illegal characters.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Returned when the snapshot with the given source-volume UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Resource with the provided name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability (updating capacity).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetSnapshot(GetSnapshotRequest) returns (Snapshot) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/snapshots/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get snapshot.";
            description: "Get snapshot by UUID/Name.";
            tags: "Snapshot operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Snapshot with UUID/Name not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListSnapshots(ListSnapshotsRequest) returns (ListSnapshotsResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/snapshots"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List snapshots.";
            description: "List can be filtered by UUID/Name.";
            tags: "Snapshot operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteSnapshot(DeleteSnapshotRequest) returns (DeleteSnapshotResponse) {
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/snapshots/{UUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete snapshot.";
            description: "Deletes snapshot with provided UUID.\nDeletion of a snapshot is a long operation. The status of deletion can be queried with a GET operation on the snapshot. As long as the operation runs, the snapshot state is Deleting. When the operation has completed, GET snapshot will return a NotFound error response.";
            tags: "Snapshot operations";
            responses: {
                key: "404";
                value: {
                    description: "Snapshot with provided UUID is not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "400";
                value: {
                    description: "Provided invalid UUID or a snapshot state does not allow deletion (Deleting/Failed).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Snapshot is in a temporary state that does not currently allow deletion (Creating/Updating and volume Updating).";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "412";
                value: {
                    description: "Etag mismatch.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "There is a user operation in progress on the snapshot";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetFeatureFlag(GetFeatureFlagRequest) returns (FeatureFlagStatus) {
        option (google.api.http) = {
            get: "/api/v2/featureFlags/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get feature flag status.";
            description: "Get feature flag status enable/disable corresponding to the given feature flag name.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableFeatureFlag(EnableFeatureFlagRequest) returns (SetFeatureFlagResponse) {
        option (google.api.http) = {
            post: "/api/v2/featureFlags/{name}/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable feature flag.";
            description: "Enable feature flag status corresponding to the given feature flag name.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableFeatureFlag(DisableFeatureFlagRequest) returns (SetFeatureFlagResponse) {
        option (google.api.http) = {
            post: "/api/v2/featureFlags/{name}/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable feature flag.";
            description: "Disable feature flag status corresponding to the given feature flag name.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }
            }
        };
    }

    rpc ListFeatureFlags(ListFeatureFlagsRequest) returns (ListFeatureFlagsResponse) {
        option (google.api.http) = {
            get: "/api/v2/featureFlags"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List feature flags.";
            description: "List feature flags.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetClusterConfigParam(GetClusterConfigParamRequest) returns (ClusterConfigParam) {
        option (google.api.http) = {
            get: "/api/v2/clusterConfig/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get a specific cluster configuration parameter's value.";
            description: "Get a specific cluster configuration parameter's value.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Cluster configuration parameter was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateClusterConfigParam(UpdateClusterConfigParamRequest) returns (UpdateClusterConfigParamResponse) {
        option (google.api.http) = {
            put: "/api/v2/clusterConfig/{configParam.name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update Cluster Config value.";
            description: "Update Cluster Config value.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Cluster configuration parameter was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListClusterConfigParams(ListClusterConfigParamsRequest) returns (ListClusterConfigParamsResponse) {
        option (google.api.http) = {
            get: "/api/v2/clusterConfig"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List all cluster configuration parameters values.";
            description: "List all cluster configuration parameters values.";
            tags: "Cluster configuration/features operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc RollbackVolume(RollbackVolumeRequest) returns (RollbackVolumeResponse) {
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/volumes/{UUID}/rollback"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Roll back a volume to a previous snapshot.";
            description: "Roll back a volume to a previous snapshot.";
            tags: "Volume operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Volume or snapshot UUID not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "503";
                value: {
                    description: "Cannot roll volume back. Volume is deleting.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListChangedBlocks(ListChangedBlocksRequest) returns (ListChangedBlocksResponse) {
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/snapshots/diff/{snapshotUUID}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List changed LBAs between a volume's snapshots.";
            description: "List changed LBAs between a volume's snapshots (optionally list all snapshots LBAs).";
            tags: "Snapshot operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments. Snapshot UUIDs are identical or they are no on same chain or offset-lba exceeds snapshot size.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find snapshot UUID or base snapshot UUID or project name.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "500";
                value: {
                    description: "Internal Lightbits error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc RotateClusterRootKey (RotateClusterRootKeyRequest) returns (RotateClusterRootKeyResponse){
        option (google.api.http) = {
            post: "/api/v2/cluster/clusterRootKey/rotate"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Rotate the cluster root encryption key (Mock).";
            description: "Rotate the Cluster Level Encryption Key (KEK). After the rotation, all of the DEKs will be encrypted with the new KEK and the new KEK will be stored securely in the cluster.";
            tags: "Encryption operations";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }

            }
            responses: {
                key: "500";
                value: {
                    description: "System internal error.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Rotation is already in progress.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Last rotation occurred less than the defined interval period between rotations";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }

            responses: {
                key: "412";
                value: {
                    description: "Precondition failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetClusterRootKey (GetClusterRootKeyRequest) returns (GetClusterRootKeyResponse){
        option (google.api.http) = {
            get: "/api/v2/cluster/clusterRootkey"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get cluster root encryption key.";
            description: "Securely export the Cluster-Level Encryption Key (KEK). As a security measure, the exported key in the response will be encrypted.";
            tags: "Encryption operations";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "501";
                value: {
                    description: "Unimplemented capability.";
                    schema: { json_schema: { type: INTEGER; } }
                }
            }
        };
    }


    rpc CreateIdpConfiguration(CreateIDPConfigurationRequest) returns (IDPConfiguration) {
        option (google.api.http) = {
            post: "/api/v2/cluster/IdpConfiguration"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create an IdP configuration.";
            description: "Create a configuration for a remote Identity Provider (IdP) that could be used to authorize access to the Lightbits cluster. Currently only a single IdP configuration is supported.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteIdpConfiguration(DeleteIDPConfigurationRequest) returns (DeleteIDPConfigurationResponse) {
        option (google.api.http) = {
            delete: "/api/v2/cluster/IdpConfiguration/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete an IdP configuration.";
            description: "Delete an IdP configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "IdP configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateIdpConfiguration(UpdateIDPConfigurationRequest) returns (IDPConfiguration) {
        option (google.api.http) = {
            put: "/api/v2/cluster/IdpConfiguration"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update an IdP configuration.";
            description: "Update an IdP configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "IdP configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListIdpConfigurations(ListIDPConfigurationsRequest) returns (ListIDPConfigurationsResponse) {
        option (google.api.http) = {
            get: "/api/v2/cluster/IdpConfiguration"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Listing IdP configurations.";
            description: "Listing IdP configurations.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetIdpConfiguration(GetIDPConfigurationRequest) returns (IDPConfiguration) {
        option (google.api.http) = {
            get: "/api/v2/cluster/IdpConfiguration/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get an IdP configuration.";
            description: "Get an IdP configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "IdP configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateIdpClientConf(CreateIdpClientConfRequest) returns (IdpClientConf) {
        option (google.api.http) = {
            post: "/api/v2/cluster/idpClientConfs"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create an idp-client-configuration.";
            description: "Create an idp-client-configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteIdpClientConf(DeleteIdpClientConfRequest) returns (DeleteIdpClientConfResponse) {
        option (google.api.http) = {
            delete: "/api/v2/cluster/idpClientConfs/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete an idp-client-configuration.";
            description: "Delete an idp-client-configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "idp-client-configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateIdpClientConf(UpdateIdpClientConfRequest) returns (IdpClientConf) {
        option (google.api.http) = {
            put: "/api/v2/cluster/idpClientConfs/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update an idp-client-configuration.";
            description: "Update an idp-client-configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "idp-client-configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListIdpClientConfs(ListIdpClientConfsRequest) returns (ListIdpClientConfsResponse) {
        option (google.api.http) = {
            get: "/api/v2/cluster/idpClientConfs"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Listing idp-client-configurations.";
            description: "Listing idp-client-configurations.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetIdpClientConf(GetIdpClientConfRequest) returns (IdpClientConf) {
        option (google.api.http) = {
            get: "/api/v2/cluster/idpClientConfs/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get an idp-client-configuration.";
            description: "Get an idp-client-configuration.";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "idp-client-configuration with the specified name was not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateAuthMapEntry(CreateAuthMapEntryRequest) returns (AuthMapEntry) {
        option (google.api.http) = {
            post: "/api/v2/cluster/authMaps"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create an authorization map entry.";
            description: "Create an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateAuthMapEntry(UpdateAuthMapEntryRequest) returns (AuthMapEntry) {
        option (google.api.http) = {
            put: "/api/v2/cluster/authMaps/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "update an authorization map entry.";
            description: "Update an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Auth map entry not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteAuthMapEntry(DeleteAuthMapEntryRequest) returns (DeleteAuthMapEntryResponse) {
        option (google.api.http) = {
            delete: "/api/v2/cluster/authMaps/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete an authorization map entry.";
            description: "Delete an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Auth map entry not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetAuthMapEntry(GetAuthMapEntryRequest) returns (AuthMapEntry) {
        option (google.api.http) = {
            get: "/api/v2/cluster/authMaps/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get an authorization map entry.";
            description: "Get an authorization map entry that maps a clientID/claim/group to an access right (scope and role).";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Auth map entry not found.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListAuthMapEntries(ListAuthMapEntriesRequest) returns (ListAuthMapEntriesResponse) {
        option (google.api.http) = {
            get: "/api/v2/cluster/authMaps"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List all authorization map entries.";
            description: "List all map entries between a clientID/claim/group and an access right (scope and role).";
            tags: "Federated authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableClusterInBandAuth(EnableClusterInBandAuthRequest) returns (EnableClusterInBandAuthResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/inBandAuth/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable In-Band cluster authentication (Beta).";
            description: "Enables NVMe-oF In-Band Authentication. This allows a Lightbits cluster to selectively restrict the set of NVMe hosts (clients) that are allowed to connect to the NVMe target (Lightbits cluster), and also (optionally), restrict the set NVMe targets that a given NVMe host will trust and connect to. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }
     
    rpc DisableClusterInBandAuth(DisableClusterInBandAuthRequest) returns (DisableClusterInBandAuthResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/inBandAuth/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable In-Band cluster authentication (Beta).";
            description: "Disables NVMe-oF In Band Authentication. Hosts can connect to a Lightbits cluster without establishing trust (the default Lightbits cluster configuration). In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc CreateTrustedHost(CreateTrustedHostRequest) returns (TrustedHost){
        option (google.api.http) = {
            post: "/api/v2/projects/{projectName}/trustedHosts"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Create a trusted host resource.";
            description: "Create a trusted host resource with configuration parameters needed for authentication and NVMe connectivity. When In-Band Authentication is enabled, only trusted hosts can connect to a Lightbits cluster. For each trusted host, an associated Lightbits resource must be created using this command. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "409";
                value: {
                    description: "Host with the provided host name and project name already exists.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DeleteTrustedHost(DeleteTrustedHostRequest) returns (DeleteTrustedHostResponse){
        option (google.api.http) = {
            delete: "/api/v2/projects/{projectName}/trustedHosts/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Delete a trusted host.";
            description: "Delete a trusted host configuration. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/project .";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetTrustedHost(GetTrustedHostRequest) returns (TrustedHost){
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/trustedHosts/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get a host.";
            description: "Get a trusted host configuration. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/project.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc ListTrustedHosts(ListTrustedHostsRequest) returns (ListTrustedHostsResponse){
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/trustedHosts"
            additional_bindings {
                get: "/api/v2/hosts"
            }
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Return a list of trusted hosts configurations.";
            description: "Return a list of trusted hosts configurations. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/project.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc UpdateTrustedHost(UpdateTrustedHostRequest) returns (TrustedHost){
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/trustedHosts/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Update a host.";
            description: "Update a trusted host configuration, optionally modifying labels. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/project.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc SetTrustedHostSecret(SetTrustedHostSecretsRequest) returns (SetTrustedHostSecretsResponse){
        option (google.api.http) = {
            put: "/api/v2/projects/{projectName}/trustedHostSecrets/{name}"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Set the secrets for a host.";
            description: "Set hosts secrets for a trusted host to allow trusted connectivity between a Lightbits cluster and hosts, as part of In-Band Authentication support. Specifying a host secret is mandatory for trusted connect of this host to the Lightbits cluster, Specifying a target secret - either explicitly or by using auto-gen mode - is optional, allowing only a trusted Lightbits cluster to connect to the host, If no target secret is specified, the target secret type will be set to disable. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/project.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc GetTrustedHostSecret(GetTrustedHostSecretsRequest) returns (GetTrustedHostSecretsResponse){
        option (google.api.http) = {
            get: "/api/v2/projects/{projectName}/trustedHostSecrets/{name}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get secrets of a host.";
            description: "Get a trusted host secrets required for authentication and connection. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.";
            tags: "In-Band authentication operations";
            responses: {
                key: "400";
                value: {
                    description: "Invalid arguments.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "404";
                value: {
                    description: "Failed to find host name/project.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc EnableFederatedAuthentication(EnableFederatedAuthenticationRequest) returns (EnableFederatedAuthenticationResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/federatedAuthentication/enable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Enable Federated Authentication.";
            description: "Enable Federated Authentication.";
            tags: "Federated authentication operations";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    rpc DisableFederatedAuthentication(DisableFederatedAuthenticationRequest) returns (DisableFederatedAuthenticationResponse) {
        option (google.api.http) = {
            post: "/api/v2/cluster/federatedAuthentication/disable"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Disable Federated Authentication.";
            description: "Disable Federated Authentication.";
            tags: "Federated authentication operations";
            responses: {
                key: "401";
                value: {
                    description: "Unauthorized: authentication failed.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
            responses: {
                key: "403";
                value: {
                    description: "Permission denied.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // Login to the CF service
    //
    // If successful, the response will contain a token that should be used
    // in the Authorization header for all subsequent requests.
    rpc CFLogin(CFLoginRequest) returns (CFLoginResponse) {
        option (google.api.http) = {
            post: "/cflogin"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Login to the cluster federation.";
            description: "Login to the cluster federation service. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            security: {
                security_requirement: {
                  key: "BasicAuth";
                  value: {};
                }
            },
            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "500";
                value: {
                    description: "Internal error in the cluster-federation service.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // List Lightbits clusters
    //
    // List the Lightbits clusters connected to the CF service.
    rpc ListClusters(ListClustersRequest) returns (ListClustersResponse) {
        option (google.api.http) = {
            get: "/api/v2/clusters"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List clusters.";
            description: "List clusters attached to the cluster-federation. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // Detach Lightbits cluster
    //
    // Detach a Lightbits cluster from the CF service.
    rpc DetachCluster(DetachClusterRequest) returns (DetachClusterResponse) {
        option (google.api.http) = {
            delete: "/api/v2/clusters/{cid}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Detach an existing cluster.";
            description: "Detaches an existing cluster from the system. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "500";
                value: {
                    description: "Internal error in the cluster-federation service.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // Attach a Lightbits cluster to the CF service.
    rpc AttachCluster(AttachClusterRequest) returns (AttachClusterResponse) {
        option (google.api.http) = {
            post: "/api/v2/clusters"
            body: "*"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Attach a new cluster.";
            description: "Attaches a new cluster to the system. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "500";
                value: {
                    description: "Internal error in the cluster-federation service.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // Get CF service credentials
    rpc GetCFServiceCredentials(GetCFServiceCredentialsRequest) returns (GetCFServiceCredentialsResponse) {
        option (google.api.http) = {
            get: "/api/v2/cf-service-credentials"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get cluster-federation service credentials";
            description: "Gets the cluster-federation service credentials. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // List workflows
    //
    // List the running and completed workflows.
    rpc ListWorkflows(ListWorkflowsRequest) returns (ListWorkflowsResponse) {
        option (google.api.http) = {
            get: "/api/v2/workflows"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "List workflows";
            description: "List the running and completed workflows. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "500";
                value: {
                    description: "Internal error in the cluster-federation service.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }

    // Get a specific workflow by its ID
    //
    // Get a specific workflow by its ID.
    rpc GetWorkflow(GetWorkflowRequest) returns (GetWorkflowResponse) {
        option (google.api.http) = {
            get: "/api/v2/workflows/{workflowId}"
        };
        option (grpc.gateway.protoc_gen_swagger.options.openapiv2_operation) = {
            summary: "Get a specific workflow";
            description: "Gets a specific workflow by its ID. This API is currently unavailable. It is reserved for future support of cluster federation functionality.";
            tags: "Cluster Federation";

            responses: {
                key: "401";
                value: {
                    description: "Authentication required / Authentication failed";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "400";
                value: {
                    description: "Invalid argument.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            },
            responses: {
                key: "500";
                value: {
                    description: "Internal error in the cluster-federation service.";
                    schema: { json_schema: { type: INTEGER;	} }
                }
            }
        };
    }
}


message LogRequest {
    // SkipStatistics
    //
    // The fetch log operation will download by default all of the statistics from the relevant server
    // By passing this parameter fetch logs will skip the statistics collection.
    bool   SkipStatistics = 1;
    // CaptureCpuAndTcpDump
    //
    // Capture CPU and tcpdump stats for five seconds to tcpdump.cap + sar.log in network/<interfaces>
    bool   CaptureCpuAndTcpDump = 2;
    // NumOfDaysToCollectLogs
    //
    // Number of days back to collect the logs (the default is two days).
    uint32 NumOfDaysToCollectLogs = 3;
    // CollectServicesLbcliEtcd
    //
    // Collect services information - lbcli and etcd dump only (the default will also collect all relevant logs).
    bool   CollectServicesLbcliEtcd = 4;
    // IntervalBetweenBEReadCycles
    //
    // The interval in seconds between FE/BE statistics captures (the default is five seconds).
    uint32 IntervalBetweenBEReadCycles = 5;
    // DontCollectlogs
    //
    // Do not collect /var/log.
    bool   DontCollectlogs = 6;
    // LogFilename
    //
    // Log filename prefix for convenience (do not use spaces).
    string LogFilename = 7;
    // NumOfstatisticsToCapture
    //
    // The number of FE/BE statistics cycles to capture (the default is one).
    uint32 NumOfstatisticsToCapture = 8;
    // DontCompressOutput
    //
    // Do not compress the output tar file. The default is gzip, but xz can be selected with the -x flag.
    bool   DontCompressOutput = 9;
    // IoNice
    //
    // Set the nicest IO/CPU priority on most commands via 'ionice -c 2 -n 7 nice -n 19'. Default: 'ionice -c 2 -n 7'
    bool   IoNice = 10;
    // UseHighCompression
    //
    // If compressing, use stronger xz compression instead of gzip. The file extension will be txz instead of tgz
    bool   UseHighCompression = 11;
}

message AdminEndpoint {
    // port
    //
    // Admin endpoint port.
    uint32 port = 1;
    repeated string ips = 2;
    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 3;
}


message GetAdminEndpointRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["port"]
        }
    };
    // port
    //
    // Admin endpoint port.
    uint32 port = 1;
}

message ListAdminEndpointsResponse {
    repeated AdminEndpoint adminEndpoints = 1;
}

message ListAdminEndpointsRequest {
    // port
    //
    // Optionally filter by port.
    uint32 port = 1;
}

message CreateAdminEndpointRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["port", "ips"]
        }
    };
    // port
    //
    // Admin endpoint port.
    uint32 port = 1;
    // ips
    // Admin endpoint IP addresses.
    repeated string ips = 2;
}

message UpdateAdminEndpointRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["port", "ips"]
        }
    };
    // port
    //
    // Admin endpoint port.
    uint32 port = 1;
    // ips
    // Admin endpoint IP addresses.
    repeated string ips = 2;
}

message DeleteAdminEndpointRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["port"]
        }
    };
    // port
    //
    // Delete endpoint corresponding to a specified port.
    uint32 port = 1;
}

message DeleteAdminEndpointResponse {
}

enum CredsType {
    UnknownType = 0;
    RS256PubKey = 1;
    TlsCertChainPem = 2;
    TlsPrivKeyPem = 3;
}

message CreateCredentialRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName", "ID", "type", "payload"]
        }
    };
    // projectName
    //
    // Project name.
    string projectName = 1;
    // ID
    //
    // Credential ID.
    string ID = 2;
    // type
    //
    // Type of the credentials, one of: pki rsa256pubkey cert-chain.
    CredsType type = 3;
    // payload
    //
    // Payload of the credentials.
    bytes payload = 4;
}

// CredsKind specifies the intended usage and origin of the credentials. It cannot be
// set directly by the user when uploading credentials and cannot be modified at all after the
// credentials were created.
enum CredsKind {
    // Credentials directly managed by the users.
    UserCreds = 0;

    // Credentials that will be used by Lightbits Photon to submit requests either on
    // behalf of the Photon users, or for Photon requests to fetch the cluster metadata.
    //
    // These credentials can be viewed by the users, but can only be modified indirectly,
    // as part of the Beacon service configuration/management process.
    BeaconCreds = 2;

    // Lightbits server encountered credentials possibly created by a newer Lightbits
    // SW version than that running on the server itself.
    UnknownKind = 127;
}

message Credential {
    string projectName = 1;
    string ID = 2;
    CredsType type = 3;
    bytes payload = 4;

    // kind
    //
    // CredsKind specifies the origin and intended usage of the credentials.
    CredsKind kind = 5;
}

message DeleteCredentialRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["ID", "projectName"]
        }
    };
    // ID
    //
    // Credential ID.
    string ID = 1;
    // projectName
    //
    // Project name.
    string projectName = 2;
}

message DeleteCredentialResponse {
}

message ListCredentialsRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // projectName
    //
    // Project name associated with credentials.
    string projectName = 1;
}

message ListCredentialsResponse {
    repeated Credential credentials = 1;
}

message GetCredentialRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["ID", "projectName"]
        }
    };
    // ID
    //
    // Credential ID.
    string ID = 1;
    // projectName
    //
    // Project name.
    string projectName = 2;
}

message DefaultPolicy {
    // Policy Type
    //
    // Policy Type. Available types are 'QoS' or 'Snapshot'.
    PolicyType policyType = 1;
    // Policy UUID
    //
    // Policy UUID
    string policyUUID = 2;
}

message CreateProjectRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // Project Name
    //
    // Project Name
    string name = 1;
    // Project description
    //
    // Brief (up to 256B) description of the project.
    string description = 2;
    // Default policies
    //
    // List of default polices. Such as default QoS policy.
    repeated DefaultPolicy defaultPolicies = 3;
}

message Project {
    // Project UUID
    //
    // Project UUID.
    string UUID = 1;
    // Project Name
    //
    // Project Name.
    string name = 2;
    // Project description
    //
    // Brief description of project.
    string description = 3;
    // Default policies
    //
    // List of default polices specified for this project.
    repeated DefaultPolicy defaultPolicies = 4;
}

message DeleteProjectRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // project name
    string name = 1;
}

message DeleteProjectResponse {
}

message ListProjectsRequest {
}

message ListProjectsResponse {
    repeated Project projects = 1;
}

message GetProjectRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // project name.
    string name = 1;
}


message StringList {
    repeated string values = 1;
}

message GetVersionRequest {
}

message CreateVolumeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "size", "acl", "replicaCount", "projectName"]
        }
    };

    enum SectorSizeEnum {
        sectorSize_Default = 0;
        sectorSize_512B = 512;
        sectorSize_4K = 4096;
    }

    // name
    //
    // A volume's name is unique at the project level. Name length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.).
    string name = 1 [(grpc.gateway.protoc_gen_swagger.options.openapiv2_field) = {pattern: "^[a-zA-Z0-9-_\\.]{1,253}$"}];
    // size
    //
    // Volume size.
    string size = 2;
    // acl
    //
    // Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE.
    StringList acl = 3;
    // compression
    //
    // Volume compression. Valid values: true/enable/enabled/false/disable/disabled (default value is disable compression).
    string compression = 4;
    // replicaCount
    //
    // The number of replicas a volume can have. Valid values are 1, 2, and 3.
    uint32 replicaCount = 5 ;
    // IPAcl
    //
    // Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE (optional, default: ALLOW_ANY).
    StringList IPAcl = 6;
    // minReplicas
    //
    // not used.
    uint32 minReplicas = 7 ;
    // sectorSize
    //
    // Volume sector size. Valid values: 4K (default), 512B.
    SectorSizeEnum sectorSize = 8;
    // projectName
    //
    // Name of the project the volume belongs to.
    string projectName = 9;
    // sourceSnapshotUUID
    //
    // Optionally specify a source snapshot to create a clone from (specify either sourceSnapshotUUID or sourceSnapshotName).
    string sourceSnapshotUUID = 10;
    // sourceSnapshotName
    //
    // Optionally specify a source snapshot to create a clone from (specify either sourceSnapshotUUID or sourceSnapshotName).
    string sourceSnapshotName = 11;
    // PlacementRestrictions
    //
    // Specify volume affinity labels for placement restrictions
    // This may only be specified for volumes of single replication (replicaCount=1), and where Dynamic Rebalance is disabled (feature flags FailInPlace and ProactiveRebalance, lbcli get feature-flag are false).
    repeated LabelMatchExpression placementRestrictions = 12;
    // qosPolicyID
    //
    // Optionally specify QoS policy to be used by volume (either name or UUID).
    oneof qosPolicyID {
        string qosPolicyUUID = 13;
        string qosPolicyName = 14;
    }
    // labels
    //
    // User-defined labels are optional for a volume. Labels are key-value pairs. A volume can have up to 16 labels. label-key and label-value length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9), hyphen (-), underscore (_), and period (.). When creating a clone, if labels are passed, the clone will be created with them. Otherwise, the labels are copied from the snapshot used for the clone.
    repeated Label labels = 15;
}

message DeleteVolumeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    // The volume's UUID for the delete volume request (optional; either UUID or Name must be provided to identify the volume to delete).
    string UUID = 1;
    // name
    //
    // The volume's name for the delete volume request (optional; either UUID or Name must be provided to identify the volume to delete).
    string name = 2;
    // projectName
    //
    // The project name of the volume to delete.
    string projectName = 3;
}

message DeleteVolumeResponse {
}

message EnableServerRequest {
    // UUID
    //
    // The server's UUID for the enable server request (either server UUID or name must be specified).
    string UUID = 1;
    // name
    //
    // The server's name for the enable server request (either server UUID or name must be specified).
    string name = 2;
}

message DisableServerRequest {
    // UUID
    //
    // The server's UUID for the disable server request (either server UUID or name must be specified).
    string UUID = 1;
    // ForceDisable
    //
    // When set to True, the disable operation bypasses an upgradeability (loss of service) check when disabling
    // server. If the evict flag is also set to True, it will force eviction of all server data, even if it means losing single
    // replica volumes because they cannot be evicted to another server. Only set both "evict" and "ForceDisable"
    // to True if you are willing to lose your single-replica volumes.
    bool ForceDisable = 2;
    // name
    //
    // The server's name for the disable server request (either server UUID or name must be specified).
    string name = 3;
    // evictData
    //
    // Setting this to True will cause all server data to be evicted from the server.
    // Setting this to 'False' will disable the server while keeping all data on the server, so it will be there when you
    // re-enable it.
    // eviction may fail in some cases; e.g., in case of single replica volume that can’t be
    // transferred to another server due to network issues between the servers, the eviction is expected to fail.
    // If you want the data eviction process, even at the risk of potentially losing some data that could not be evicted,
    // set both evictData and ForceDisable to True.
    bool evictData = 4;
    // permanentFailureTimeout
    //
    // Setting a value for this parameter will override the permanent failure timeout at the cluster level.
    // This can be used  when a user wants to take a server into maintenance state and avoid data migration
    // during this time. Valid values are 1 hour or longer, "0"  value should be used to specify an infinite timeout.
    // Permanent failure timeout is a string constructed by a decimal number followed
    // by the units: ns, us, ms, s, m, h. For example: 7200s, 120m, 2h
    // This value will be override once the server is re-enabled. Default value: null
    google.protobuf.Duration permanentFailureTimeout = 5;
}

message DeleteServerRequest {
    // UUID
    //
    // The server's UUID for the delete server request (either server UUID or Name must be specified).
    string UUID = 1;
    // name
    //
    // The server's name for the delete server request (either server UUID or Name must be specified).
    string name = 2;

    // forceDelete
    //
    // Optional. Setting forceDelete will override some of the delete
    // server pre-checks.
    // When set to False (default), a server cannot be deleted if
    // there are any resources attached to the server (e.g., node replace
    // was issued, server nodes entered permanent failure states, and
    // resources were migrated.)
    // When set to True, the delete operation bypasses checks to verify
    // if the server still has any resources attached to it and starts the
    // delete operation in the background. The operation will not
    // complete and will remain in the background until the server
    // resources will have been detached from the server.
    // Note that a server with volumes/snapshots/clones with a single
    // replica cannot be deleted, even with forceDelete set to
    // True. You must remove the 1x replica volumes/snapshots/clones
    // before deleting the server.
    bool forceDelete = 3;
}

message ReplaceNodeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["SrcNodeUUID", "TargetNodeUUID"]
        }
    };
    // SrcNodeUUID
    //
    // The source node's UUID for the replace node request.
    string SrcNodeUUID = 1;
    // TargetNodeUUID
    //
    // The target node's UUID for the replace node request.
    string TargetNodeUUID = 2;
    // ReplaceWhileActive
    //
    // Optional. When true, the replace node operation will be performed while the server is active. Default is False.
    bool   ReplaceWhileActive = 3;
}

message CreateServerRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["serverEndpoints", "serverUUID"]
        }
    };
    // serverEndpoints
    //
    // Etcd member endpoint. In the current version, only a single point is allowed.
    repeated string serverEndpoints = 1;
    // serverUUID
    //
    // The server's UUID for the create server request.
    string serverUUID = 2;
    // reuseIP
    //
    // Optional. When true, bypasses validation if a given endpoint is used by another server.
    bool reuseIP = 3;
    // extendCluster
    //
    // Optional. When true, the cluster is extended with a new server and its resources, enabling new volumes placement on the server (the nodes of this server will come up as active). Default is False (the nodes of this server will be added to the cluster as unattached, and may be used to move over resources from an existing failed server using the replace node API command).
    bool extendCluster = 4;
}

message UpdateVolumeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    // Optional identifier of the volume to update (command must use either name or UUID fields to identify volume).
    string UUID = 1;
    // acl
    //
    // Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
    StringList acl = 2;
    // IPAcl
    //
    // Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE
    StringList IPAcl = 3;
    string size = 4;
    // compression
    //
    // valid values: true/enable/enabled or false/disable/disabled
    string compression = 5;
    // project name
    //
    // Name of the project the volume belongs to.
    string projectName = 6;
    // qosPolicyID
    //
    // QoS Policy, optionally specify QoS policy to be used by volume (either name or UUID).
    oneof qosPolicyID {
        string qosPolicyUUID = 7;
        string qosPolicyName = 8;
    }
    // Force
    //
    // To intentionally shrink volume size, provide updated volume size and set force to true.
    bool Force = 9;
    // name
    //
    // Optional identifier of the volume to update (command must use either name or UUID fields to identify volume).
    string name = 10;
    // labels
    //
    // User-defined labels are optional for a volume. Labels are key-value pairs. A volume can have up to 16 labels. label-key and label-value length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.). If labels are passed during volume update, the existing volume's labels are replaced with the new ones. Otherwise, the labels are untouched.
    repeated Label labels = 11;
    // new name
    //
    // Volume new name. A volume's name is unique on the project level. Name length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.).
    string newName = 12;
}

message UpgradeServerRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["UUID", "InstallPkgUri"]
        }
    };
    // UUID
    //
    // The server's UUID for the upgrade server request.
    string UUID = 1;
    // InstallPkgUri
    //
    // URI of Lightbits package to install.
    string InstallPkgUri = 2;
    // ForceUpgrade
    //
    // Optional. When true, bypasses the upgradability (loss of service) check.
    bool ForceUpgrade = 3;
    // ProxyInfo
    //
    // Optional. Proxy server information for upgrade behind proxy.
    ProxyInfo ProxyInfo = 4;
}

message UpgradeClusterRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["InstallPkgUri"]
        }
    };
    // InstallPkgUri
    //
    // URI of Lightbits package to install.
    string InstallPkgUri = 1;
    // UUIDs
    //
    // Optional. Servers with given UUIDs are upgraded. If not given, all servers in the cluster are upgraded according to an upgradability (loss of service) check.
    repeated string UUIDs = 2;
    // ProxyInfo
    //
    // Optional. Proxy server information for upgrade behind proxy.
    ProxyInfo ProxyInfo = 3;
}

message EnableClusterEncryptionRequest {
    enum KeyStore {
        file = 0;
        tpm = 1;
    }
    // KeyStore
    //
    // Optional. Where to store the Encryption KEK on file or in tpm.
    KeyStore keyStore = 1;
}

message GetClusterRequest {
}

message UpdateNvmeDeviceRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["serverUUID", "serialNumber", "ledPattern"]
        }
    };
    // serverUUID
    //
    // Server UUID of the NVMe device to update.
    string serverUUID = 1;
    // serialNumber
    //
    // NVMe device serial number.
    string serialNumber = 2;
    // ledPattern
    //
    // NVMe device LED pattern. specify either "locate", "rebuild" or "locate-off"
    string ledPattern = 3;
}

message AddNvmeDeviceRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["serialNumber", "nodeUUID"]
        }
    };
    // serialNumber
    //
    // NVMe device serial number.
    string serialNumber = 1;
    // nodeUUID
    //
    // UUID of node to add the NVMe device to.
    string nodeUUID = 2;
}


message GetHostRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["hostNQN"]
        }
    };
    // hostNQN
    //
    // Host NQN to get.
    string hostNQN = 1;
}

message ListHostsRequest {
    // hostNQN
    //
    // Not supported (hostNQN filtering parameter is ignored and all connected hosts will be returned).
    string hostNQN = 1;
    // hostNQN
    //
    // Optionally filter hosts associated with a specific volume (the default operation will return all hosts connected to the cluster).
    string volumeUUID = 2;
}

message ListHostsResponse {
	repeated ConnectedHost connectedHosts = 1;
}

message ListNodeRequest {
    // Name
    //
    // Filter nodes by node name (either no filter, or only name, UUID, or failureDomain should be specified).
    string name = 1;
    // Name
    //
    // Filter nodes by node name (either no filter, or only name, UUID, or failureDomain should be specified).
    string UUID = 2;
    // failureDomain
    //
    // Filter nodes by a failure domain associated with nodes (either no filter, or only name, UUID, or failureDomain should be specified).
    string failureDomain = 3;
}

message ListEventsRequest {
    // projectName
    //
    // List only events that are associated with the specified project.
    string projectName = 1;
    // nextToken
    //
    // Optional. Specifies the first event to return when using consecutive paginated requests. Use the nextToken returned in the response of the previous request as the indication for the first event the new request should fetch. The value of nextToken is an event ID.
    string nextToken = 2;
    // since
    //
    // Optional. Return a list of events with a timestamp not earlier than the given timestamp. The timestamp format must be given in UTC time in ISO-8601, e.g.: 2000-01-01T12:00:00.000Z.
	string since = 3;
    // until
    //
    // Optional. Return a list of events with a timestamp not later than the given timestamp. The timestamp format must be given in UTC time in ISO-8601, e.g.: 2000-01-01T12:00:00.000Z.
	string until = 4;
    // limit
    //
    // Optional. Set a limit for the maximum number of events that can be returned in this response.
	int64 limit = 6;
    // severity
    //
    // Optional. Return only events of the given severity.
	repeated string severity = 7;
    // component type
    //
    // Optional. Return only events of the given component type.
	string componentType = 8;
}

message ListEventsResponse {
    repeated Event events = 1;
    string nextToken = 2;
}

message GetVolumeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    // Optional. The volume's UUID. Either UUID or Name must be provided to identify the volume to get.
    string UUID = 1;
    // Name
    //
    // Optional. The volume's name. Either UUID or Name must be provided to identify the volume to get.
    string name = 2;
    // projectName
    //
    // Name of project volume belongs to.
    string projectName = 3;
}

message GetNodeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["UUID"]
        }
    };
    // UUID
    //
    // ID of node to get.
    string UUID = 1;
}

message ListVolumeRequest {
    // UUID
    //
    // List only volume with matching UUID.
    string UUID = 1;
    // Name
    //
    // List only volumes with specified name.
    string name = 2;
    // failureDomain
    //
    // List volumes according to failureDomains volumes replicas are placed on.
    string failureDomain = 3;
    // offsetUUID
    //
    // When provided, returned list starts with next to offsetUUID volume.
    string offsetUUID = 4;
    // limit
    //
    // Limits the number of volumes in the response (default/maximum value is 1000 volumes).
    int64 limit = 5;
    // projectName
    //
    // Optional. Return only volumes of the given project.
    string projectName = 6;
    // source snapshot UUID
    //
    // Return only volumes created from this source snapshot.
    string snapshotUUID = 7;
    // showAll
    //
    // Optional. Show also volumes in Deleting state (the default is false).
    bool showAll = 8;
}

message ListNvmeDevicesRequest {
    // nodeUUID
    //
    // Optionally, list all NVMe devices managed by a specified node.
    string nodeUUID = 1;
    // serverUUID
    //
    // Optionally, list all NVMe devices attached to a specified server.
    string serverUUID = 2;
}

message GetNvmeDeviceRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["Serial"]
        }
    };
    // Serial
    //
    // Serial number of the NVMe device to get.
    string Serial = 1;
}

message ListNvmeDevicesResponse {
    repeated UserNvmeDevicesResponse NvmeDevices = 1;
}

message ConnectedHost {
    // hostNQN
    //
    // Host's NVMe qualified name (NQN).
    string hostNQN = 1;
    // iPAddress
    //
    // Host's IP addresses.
    string iPAddress = 2;
    // hostname
    //
    // Host's name.
    string hostname = 3;
    //volumeUUIDs
    //
    // list of volumes to which this host connects to.
    repeated string volumeUUIDs = 4;
}

message UserNvmeDevicesResponse {
    enum StateEnum {
        None = 0;
        Healthy = 1;
        Adding = 2;
        Rebuilding = 3;
        Failed = 4;
    }
    // size
    //
    // Total capacity of the device in bytes.
    uint64 size = 1;
    // numaNodeID
    //
    // The NUMA node ID this device is associated with.
    uint64 numaNodeID = 2;
    // model
    //
    // Model string of the device, if exists.
    string model = 3;
    // serial
    //
    // Serial of the block device, if exists.
    string serial = 4;
    // server UUID
    //
    // The UUID of the server to which the block device is installed.
    string serverUUID = 5;
    // device state
    //
    // Describes the state of the device. Unmanaged device state will be None.
    StateEnum state = 6;
    // device time of failure
    //
    // Timestamp that will be updated in case the device has failed.
    google.protobuf.Timestamp failureTime = 7;
    // device rebuild completion time
    //
    // Timestamp that will be updated once GFTL has completed
    // to rebuild all the data that the device had, and we are safe
    // for second failure.
    google.protobuf.Timestamp rebuildCompletionTime = 8;
    // name
    //
    // Device name or address.
    string name = 9;
    // node UUID that manages the device
    //
    // The UUID of the node that manages the device. Empty string if the device is not managed.
    string nodeUUID = 12;
    // Etag
    //
    // identifier for a specific version of a resource.
    string ETag = 13;
    // Statistics
    //
    // Various nvme-device related statistics.
    NvmeDeviceStatisticsApi statistics = 14;
}

message DurosNodeInfo {
    enum State {
        // 0
        //
        // Reserved value. Default should return an error, rather than a true state that is incorrect.
        Unknown = 0;
        // 1
        //
        // Node is completed join cluster flow.
        Active = 1;
        // 2
        //
        // Node is is the process of coming up (starting required services) and joining cluster.
        Activating = 2;
        // 3
        //
        // Node is is Inactive (this includes internal states Removing and failed).
        Inactive = 3;
        // 4
        //
        // Node is not attached to cluster (none of the cluster pgs contain this pg).
        Unattached = 4;
        // 6
        //
        // Attaching a node to the cluster ongoing (replacing old node in pgs with this node).
        Attaching = 6;
        // 7
        //
        // Detaching a node from the cluster ongoing (replacing this node in pgs with this a new node).
        Detaching = 7;
    }
    // Machine-readable internal state of the node we want to report to the cluster.
    enum StatusEnum {
        NoStatus = 0;
        // reported during NodeStateEnum==Adding
        ConnectivityOK = 1;
        ConnectivityProblem = 2;
        // reported during NodeStateEnum==Removing
        IssuedDeletePeer = 3;
    }
    string name = 1;
    string UUID = 2;
    State state = 3;
    StatusEnum status = 4;
    // peer <ip>:<port> service data-path IP
    string nvmeEndpoint = 5;
    repeated string failureDomains = 6;
    string failureInfo = 7;
    string hostname = 9;
    bool inLocalRebuild = 10;
    uint32 localRebuildProgress = 11;
    int32 numManagedDevices = 12;
    uint32 maxNvmeDevices = 13;
    bool ec = 14;
    NodeStatisticsApi statistics = 15;
    string serverUUID = 16;
    // Etag
    //
    // identifier for a specific version of a resource
    string ETag = 17;
    bool readOnly = 18;
    uint32 powerupProgress = 19;
    bool permanentFailure = 20;
}

message ListNodesResponse {
    repeated DurosNodeInfo nodes = 1;
}

message ListVolumesResponse {
    repeated Volume volumes = 1;
}

message UpdateNvmeDeviceResponse {}

message AddNvmeDeviceResponse {}

message UpdateVolumeResponse {}

message UpgradeServerResponse {}

message UpgradeClusterResponse {}

message EnableClusterEncryptionResponse {}

message ReplaceNodeResponse {}

message DeleteServerResponse {}

message DisableServerResponse {}

message ListServersRequest {
    // UUID
    //
    // Filter server by the server's UUID.
    string UUID = 1;
    // Name
    //
    // Filter server by the server's name.
    string Name = 2;
    // RiskOfServiceLoss
    //
    // List only servers in a RiskOfServiceLoss state matching the specified state.
    Server.RiskOfServiceLossEnum RiskOfServiceLoss = 3;
}

message GetServerRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["UUID"]
        }
    };
    // UUID
    //
    // The server's UUID for the get server request.
    string UUID = 1;
}

message ListServersResponse {
    repeated Server servers = 1;
}

message ClusterUpgradeStatusResponse {
    ClusterInfo cluster = 1;
}

message ListUpgradeStatusResponse {
    repeated Server servers = 1;
}

message Version {
    //latest user API version
    string apiVersion = 4;
}

message ClusterLastUpgrade {
    enum UpgradeStatusEnum {
        Unknown = 0;
        None = 1;
        UpgradeFailed = 2;
        Upgrading = 3;
    }

    // Status
    //
    // The status of the upgrade operation
    UpgradeStatusEnum Status = 1;

    // StartTime
    //
    // The time of the upgrade task start
    google.protobuf.Timestamp StartTime = 2;

    // EndTime
    //
    // The time of closing the upgrade task (completed or failed). Reset when the next upgrade starts.
    google.protobuf.Timestamp EndTime = 3;

    // TargetVersion
    //
    // The version that should be installed by the end of the process.
    string TargetVersion = 4;

    // ErrorMessage
    //
    // Free formatted text, describes the error if such an error occurred.
    string ErrorMessage = 5;

    // ProgressStep
    //
    // Current upgrade step. You can use ProgressTotal to calculate percentage as ProgressStep/ProgressTotal.
    uint32 ProgressStep = 6;

    // ProgressTotal
    //
    // Total possible upgrade progress steps.
    uint32 ProgressTotal = 7;
}

message ClusterInfo {
    enum AuthenticationMode {
        UnKnown = 0;
        Enabled  = 2;
        Disabled  = 3;
    }

    // cluster UUID
    //
    // UUID of cluster
    string UUID = 1;
    // subsystemNQN
    //
    // Subsystem NQN that should be used by the hosts to connect to volumes on this cluster.
    string subsystemNQN = 2;
    // Current maximum number of replicas per volume
    //
    // A maximal number of replicas that a new volume can have, given the current state of the nodes. This value depends on the healthiness of the nodes.
    uint32 currentMaxReplicas = 3;
    // Maximum number of replicas per volume supported by cluster.
    //
    // A maximal number of replicas that a volume can have, given cluster installation parameters (Number of Servers, Failure Domains...).
    uint32 supportedMaxReplicas = 4;
    // cluster statistics
    //
    // Cluster statistics (storage capacity, used storage, compression ration...)
    ClusterStatisticsApi statistics = 5;
    // Etag
    //
    // Identifier for a specific version of a resource.
    string ETag = 6;
    // Cluster Health
    //
    // Cluster health: OK- cluster healthy, Warning - Inactive node(s) and/or degraded volumes in cluster, Error - ReadOnly/Unavailable volumes in cluster.
    ClusterHealth health = 7;
    // Minimal Lightbits version
    //
    // Lowest version of Lightbits running on one of the servers in the cluster.
    string MinVersionInCluster = 8;
    // Minimal allowed Lightbits version
    //
    // For Lightbits internal use.
    string MinAllowedVersion = 9;
    // Maximal allowed Lightbits version
    //
    // Lightbits version this cluster can be upgraded to.
    string MaxAllowedVersion = 10;
    // Addresses of the API Service
    //
    // A list of REST/gRPC endpoints - <ip>:<port> pairs that the API listen on.
    // Example entries:
    // - 192.168.16.16:443
    // - 192.168.16.17:443
    repeated string apiEndpoints = 11;
    // Addresses of the Discovery Service
    //
    // A list of TCP endpoints - <ip>:<port> pairs that the Discovery Service listen on.
    // Example entries:
    // - 192.168.16.16:8009
    // - 192.168.16.17:8009
    repeated string discoveryEndpoints = 12;
    // cluster name
    //
    // Cluster name.
    string clusterName = 13;
    // lastUpgrade
    //
    // Parameters of the last (or active) cluster upgrade process.
    ClusterLastUpgrade lastUpgrade = 14;
    // inBandAuthMode
    //
    // Defines whether In-Band Authentication is enabled for the cluster(Enabled/Disabled).
    // When enabled, authentication is required for hosts to connect to the Lightbits cluster.
    AuthenticationMode inBandAuthMode = 15;
    // encryptionStatus
    //
    // Information about the state of Cluster Level Encryption.
    ClusterEncryptionStatus encryptionStatus = 16;
    // federatedAuthenticationStatus
    //
    // Information about the state of Federated Authentication
    FederatedAuthenticationStatus federatedAuthenticationStatus = 17;
}

message ClusterInfoV2 {
    // cluster UUID
    //
    // UUID of cluster
    string UUID = 1;
    // subsystemNQN
    //
    // Subsystem NQN that should be used by the hosts to connect to volumes on this server.
    string subsystemNQN = 2;
    // Current maximum number of replicas per volume
    //
    // A maximal number of replicas that a new volume can have, given the current state of the nodes. This value depends on the healthiness of the nodes.
    uint32 currentMaxReplicas = 3;
    // Maximum number of replicas per volume supported by the cluster
    //
    // A maximal number of replicas that a volume can have, given the cluster installation parameters.
    uint32 supportedMaxReplicas = 4;
    // Etag
    //
    // identifier for a specific version of a resource.
    string ETag = 6;
    // Addresses of the API Service
    //
    // A list of REST/gRPC endpoints - <ip>:<port> pairs that the API listen on.
    // Example entries:
    // - 192.168.16.16:443
    // - 192.168.16.17:443
    repeated string apiEndpoints = 11;
    // Addresses of the Discovery Service
    //
    // A list of TCP endpoints - <ip>:<port> pairs that the Discovery Service listen on.
    // Example entries:
    // - 192.168.16.16:8009
    // - 192.168.16.17:8009
    repeated string discoveryEndpoints = 12;
    // Addresses of the NVMe endpoints
    //
    // A list of TCP endpoints - <ip>:<port> pairs that the NVMe targets listen on.
    // Example entries:
    // - 192.168.16.16:4420
    // - 192.168.16.17:4420
    repeated string nvmeEndpoints = 13;
    // cluster name
    //
    // cluster name.
    string clusterName = 14;

    // lastUpgrade
    //
    // Parameters of the last (or active) cluster upgrade process
    ClusterLastUpgrade lastUpgrade = 15;

    // encryptionStatus
    //
    // Information about the state of Cluster Level Encryption
    ClusterEncryptionStatus encryptionStatus = 16;
}

message ClusterHealth {
    enum State {
        None        = 0;
        OK          = 1;
        Warning     = 2;
        Error       = 3;
    }
    State state = 1;
    uint32 numDegradedVolumes = 2;
    uint32 numReadOnlyVolumes = 3;
    uint32 numNotAvailableVolumes = 4;
    uint32 numInactiveNodes = 5;
    uint32 numHealthyVolumes = 6;
}

enum ProtectionStateEnum {
    // Unknown.
    //
    // Reserved value.
    Unknown = 0;
    // FullyProtected
    //
    // Volume supports write/read and replication, All volumes replicas are healthy.
    FullyProtected = 1;
    // Degraded
    //
    // Volume supports write/read,  Data may not be replicated,
    // at least one of the volume's replicas is unhealthy (node is inactive, is full, or not synced).
    Degraded = 2;
    // ReadOnly
    //
    // Volume supports only read, Data may not be replicated,
    // at least one of the volume's replicas is unhealthy (node is inactive, is full or not synced).
    ReadOnly = 3;
    // NotAvailable.
    //
    // Volume can not be used for read or write, all volume's replicas are unhealthy (node is inactive or not synced).
    NotAvailable = 4;
}

message Volume {
    enum StateEnum {
        // Unknown.
        //
        // Reserved value.
        Unknown = 0;
        // Creating.
        //
        // Volume is being created.
        Creating = 1;
        // Available.
        //
        // Volume is available for use. No ongoing operations on volume.
        Available = 2;
        // Deleting.
        //
        // Volume is being deleted.
        Deleting = 3;
        // Deleted.
        //
        // Volume was deleted.
        Deleted = 4;
        // Failed.
        //
        // Volume creation failed.
        Failed = 7;
        // Updating.
        //
        // Volume is being updated.
        Updating = 8;
        // Rollback.
        //
        // Volume is being rolled back to a specified snapshot.
        Rollback = 9;
        // Migrating.
        //
        // One of the volume's replicas is being migrated.
        Migrating = 10;
    }
    enum ProtocolEnum {
        ProtocolTCP = 0;
    }

    // State
    //
    // Indicates the current state of the volume in its creation/update/delete lifetime. It will reflect the state of execution of a user invoked API (CreateVolume, UpdateVolume..)
    // or an internal operation (Volume migration).
    StateEnum state = 1;
    // Protection state
    //
    // Indicates volume's data availability derived from the health of each of the replica's it resides on.
    ProtectionStateEnum protectionState = 2;
    // replicaCount
    //
    // The number of replicas a volume can have. Valid values are 1, 2, and 3.
    uint32 replicaCount = 3;
    // nodeList
    //
    // List of node UUIDs this volume is placed over.
    repeated string nodeList = 4;
    string UUID = 5;
    // NSID
    //
    // Volume's Namespace ID
    uint32 nsid = 6;
    // acl
    //
    // Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
    StringList acl = 7;
    // compression
    //
    // valid values: true/enable/enabled or false/disable/disabled
    string compression = 8;
    uint64 size = 9;
    // name
    //
    // A volume's name is unique at the project level. Name length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.).
    string name = 10;
    // rebuildProgress
    //
    // Progress of the volume's replica rebuild operation in percent.
    string rebuildProgress = 11;
    // statistics
    //
    // Volume statistics. Contains information about the physical used capacity, used memory, compression ratio, and more.
    VolumeStatisticsApi statistics = 12;
    // IPAcl
    //
    // Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE (optional, default: ALLOW_ANY).
    StringList IPAcl = 13;
    // Etag
    //
    // Identifier for a specific version of a resource.
    string ETag = 14;
    repeated string connectedHosts = 15;
    // sectorSize
    //
    // Volume sector size. Valid values: 4K (default), 512B.
    uint32 sectorSize = 16;
    // projectName
    //
    // Project name.
    string projectName = 17;
    // sourceSnapshotUUID
    //
    // For a cloned volume, specify the source snapshot of this clone.
    string sourceSnapshotUUID = 18;
    // sourceSnapshotName
    //
    // For a cloned volume, specify the source snapshot of this clone.
    string sourceSnapshotName = 19;
    repeated LabelMatchExpression placementRestrictions = 20;
    // qosPolicyUUID
    //
    // Optional volume's QoS policy UUID (if not specified the QoS policy defined in volume's project is used).
    string qosPolicyUUID = 21;
    // qosPolicyName
    //
    // Optional volume's QoS policy name (if not specified the QoS policy defined in volume's project is used)
    string qosPolicyName = 22;
    // primaryNodeUUID
    //
    // UUID of the primary node data is Read/Written for this volume.
    string primaryNodeUUID = 23;
    // creationTime
    //
    // Time of volume creation (UTC).
    google.protobuf.Timestamp creationTime = 24;
    // labels
    //
    // Optionally add labels to a volume.
    repeated Label labels = 25;
    // clusterId
    //
    // The ID of the cluster where the volume is resides.
    string clusterId = 26;
}

message ServerEvictionStatus {
    enum StatusEnum {
        None        = 0;
        Failed      = 1;
        Evicting    = 2;
        Aborting    = 3;
        Completed   = 4;
        Aborted     = 5;
    }
    // status
    //
    // The status of the eviction operation.
    StatusEnum status = 1;
    // startTime
    //
    // Start time of eviction operation.
    google.protobuf.Timestamp startTime = 2;
    // endTime
    //
    // Completion time of eviction operation (either a successfully completed or ended due to failure).
    google.protobuf.Timestamp endTime = 3;
    // errorMessage
    //
    // Error message from the last eviction operation.
    string errorMessage = 4;
    // progress
    //
    // Current eviction progress given in units of percent.
    uint32 progress = 5;
}

message ServerLastUpgrade {
    enum UpgradeStatusEnum {
        Unknown = 0;
        None = 1;
        UpgradeFailed = 2;
        Upgrading = 3;
        Rebooting = 4;
        Recovering = 5;
    }

    // Status
    //
    // The status of the upgrade operation.
    UpgradeStatusEnum Status = 1;
    // StartTime
    //
    // The time of the upgrade task start.
    google.protobuf.Timestamp StartTime = 2;
    // EndTime
    //
    // The time of closing the upgrade task (completed or failed).
    google.protobuf.Timestamp EndTime = 3;
    // TargetVersion
    //
    // The version that should be installed by the end of the process.
    string TargetVersion = 4;
    // ErrorMessage
    //
    // Last error message. Free text formatted string describes the problem.
    string ErrorMessage = 5;
    // ProgressStep
    //
    // Current upgrade step. You can use ProgressTotal to calculate the percentage as ProgressStep/ProgressTotal.
    uint32 ProgressStep = 6;
    // ProgressTotal
    //
    // Total possible upgrade progress steps.
    uint32 ProgressTotal = 7;
}

message Server {
    enum UpgradeStatusEnum {
        Unknown = 0;
        None = 1;
        UpgradeFailed = 2;
        Upgrading = 3;
        Rebooting = 4;
        Recovering = 5;
    }
    enum RiskOfServiceLossEnum {
        UnknownRiskOfServiceLoss = 0;
        NoRiskOfServiceLoss = 1;
        InRiskOfServiceLoss = 2;
        SourceOfRiskOfServiceLoss = 3;
    }
    enum ServerStateEnum {
        UnknownState   = 0;
        Creating  = 1;
        Enabled   = 2;
        Deleting  = 3;
        Failed    = 4;
        Disabled  = 5;
        Enabling  = 6;
        Disabling = 7;
    }

    string UUID = 2;
    string name = 3;
    // risk of service loss state
    //
    // Indicates the ability to upgrade or disable a server without loss of service to cluster volumes.
    RiskOfServiceLossEnum RiskOfServiceLossState = 4;
    repeated string NodesUUIDs = 5;
    ServerStateEnum state = 6;
    repeated string ServerEndpoints = 7;

    // Etag
    //
    // Identifier for a specific version of a resource.
    string ETag = 8;

    // LightOSVersion
    //
    // The current Lightbits version.
    string LightOSVersion = 9;

    // UpgradeStatus
    //
    // Deprecated: This field indicates the status of the upgrade operation.
    UpgradeStatusEnum UpgradeStatus = 10;

    // ApiEndpoints
    //
    // The API endpoints
    repeated string ApiEndpoints = 11;

    // LastUpgrade
    //
    // Parameters of the last (or active) server upgrade process
    ServerLastUpgrade LastUpgrade = 12;

    // IsWitness
    bool IsWitness = 13;

    // LastEviction
    //
    // Parameters of the last (or active) server eviction process
    ServerEvictionStatus LastEviction = 14;
    // Server Health
    //
    // Server health: OK- server healthy, Warning high utilization or failed disk under rebuild, Error - Inactive nodes or nodes nearing/in Read-only.
    ClusterHealth.State health = 15;
    // Server Permanent failure configuration
    //
    // Permanent failure timeout at the server level. If set, overrides the cluster configuration. Value of "0" sets it to infinite.
    google.protobuf.Duration ServerPermanenetFailureTimeout = 16;

    // TPM 2.0 Support
    //
    // Trusted Platform Module 2.0 (TPM) support indication.
    // Note: If information about a server's TPM2 support is unavailable,
    // we consider it as not supported.
    bool tpm2IsSupported = 17;
}

message GetRoleRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "projectName"]
        }
    };
    // name
    //
    // The name of the role to get.
    string name = 1;
    // projectName
    //
    // The name of the project this role belongs to.
    string projectName = 2;
}

message GetRoleResponse {
    Role role = 1;
}

message Role {
    string name = 1;
    string projectName = 2;
    // rulesJson
    //
    // A JSON representation of the role 'rules' array, e.g.:
    //   [{"resources":["versions"],"actions":["get"]}]
    string rulesJson = 4;
}

message ListRolesRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // projectName
    //
    // The name of the project to list roles for.
    string projectName = 1;
}

message ListRolesResponse {
    repeated Role roles = 1;
}

message Snapshot {
    enum StateEnum {
        Unknown = 0;
        Creating = 1;
        Available = 2;
        Deleting = 3;
        Deleted = 4;
        Failed = 7;
    }

    StateEnum state = 1;
    string UUID = 2;
    string name = 3;
    string description = 4;
    google.protobuf.Timestamp creationTime = 5;
    google.protobuf.Duration retentionTime = 6;
    string sourceVolumeUUID = 7;
    string sourceVolumeName = 8;
    uint32 replicaCount = 9;
    repeated string nodeList = 10;
    uint32 nsid = 11;
    StringList acl = 12;
    bool compression = 13;
    uint64 size = 14;
    StringList IPAcl = 15;
    uint32 sectorSize = 16;
    SnapshotStatisticsApi statistics = 18;
    string ETag = 19;
    string projectName = 20;
    string primaryNodeUUID = 21;
    // labels
    //
    // Once a snapshot is taken, the volume's labels are copied to the snapshot. Once a clone is created, if the user does not pass new labels on clone creation, the cloned volume labels are copied from the source snapshot labels.
    repeated Label labels = 22;
}

message DeleteSnapshotRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    // The UUID of the snapshot to delete (specify either UUID or Name).
    string UUID = 1;
    // name
    //
    // The name of the snapshot to delete (specify either UUID or Name).
    string name = 2;
    // projectName
    //
    // The name of the project this snapshot belongs to.
    string projectName = 3;
}

message CreateSnapshotRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "projectName"]
        }
    };
    // name
    //
    // The name of the snapshot
    string name = 1;
    // sourceVolumeUUID
    //
    // The UUID of the volume to create the snapshot from.
    // You should specify either the UUID or the name.
    // If both UUID and name are specified, the UUID takes precedence.
    string sourceVolumeUUID = 2;
    // sourceVolumeName
    //
    // The name of the volume to create the snapshot from.
    // You should specify either the UUID or the name.
    // If both UUID and name are specified, the UUID takes precedence.
    string sourceVolumeName = 3;
    // retentionTime
    //
    // The length of time in seconds to retain this snapshot for.
    google.protobuf.Duration retentionTime = 4;
    // description
    //
    // A short description (up to 256B) of the snapshot.
    string description = 5;
    // projectName
    //
    // The name of the project this snapshot belongs to
    string projectName = 6;
}

message ListSnapshotsRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    // Optionally filter a specific snapshot by UUID.
    string UUID = 1;
    // Name
    //
    // Optionally filter a specific snapshot by name.
    string Name = 2;
    // projectName
    //
    // The name of the project this snapshot belongs to.
    string projectName = 3;
    // offsetUUID
    //
    // Optional. When provided, returned list starts with next to offsetUUID volume.
    string offsetUUID = 4;
    // limit
    //
    // Optional. Limits the number of snapshots in the response (default/max is 1000 snapshots in a response).
    int64 limit = 5;
    // showAll
    //
    // Optional. Show also snapshots in Deleting state (the default is false).
    bool showAll = 6;
}

message GetSnapshotRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    //  The UUID of the snapshot to get (either UUID or Name must be specified).
    string UUID = 1;
    // Name
    //
    // The name of the snapshot to get (either UUID or Name must be specified).
    string Name = 2;
    // projectName
    //
    // The name of the project this snapshot belongs to.
    string projectName = 3;
}

message ListSnapshotsResponse {
    repeated Snapshot snapshots = 1;
}
message DeleteSnapshotResponse {
}

message FeatureFlagStatus {
    string name = 1;
    bool enabled = 2;
}

message GetFeatureFlagRequest{
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the feature flag to get:  "event-log", "evict-data", "fail-in-place", "in-band-authentication", "proactive-rebalance".
    string name = 1;
}

message EnableFeatureFlagRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the feature flag to enable:  "event-log", "evict-data", "fail-in-place", "in-band-authentication", "proactive-rebalance".
    string name = 1;
}

message DisableFeatureFlagRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the feature flag to disable:  "event-log", "evict-data", "fail-in-place", "in-band-authentication", "proactive-rebalance".
    string name = 1;
}

message SetFeatureFlagResponse {}

message ListFeatureFlagsRequest {}

message ListFeatureFlagsResponse {
    map<string, FeatureFlagStatus> featureFlags = 1;
}

message CreateResourcePolicyRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "schedulePolicy"]
        }
    };
    // name
    //
    // The name of the resource policy.
    string name = 1;
    // resourceUUID
    //
    // The resource UUID. If both name and UUID are provided, the name
    // is ignored and only the UUID is used.
    string resourceUUID = 2;
    // resourceName
    //
    // The resource name. If both name and UUID are provided, the name
    // is ignored and only the UUID is used.
    string resourceName = 3;
    // projectName
    //
    // The project this resource policy belongs to.
    string projectName = 4;
    // schedulePolicy
    //
    // The schedule policy for this resource policy.
    lightbits.api.duros.v2.SchedulePolicy schedulePolicy = 5;
    // description
    //
    // A short (up to 256B) description for this resource.
    string description = 6;
}

message CreatePolicyRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // Policy name
    //
    // Policy name
    string name = 1;
    // Policy description
    //
    // Policy description, up to 256B in length
    string description = 2;
    // The policy
    //
    // Details of the policy to create
    oneof policy {
        QoSRateLimitPolicy qoSRateLimitPolicy = 3;
        // in the future we will move here schedule policy as well as other policies.
    }
}

message UpdatePolicyRequest {

    // UUID
    //
    // The UUID of the policy request to update. If both name and UUID are provided,
    // the name is ignored.
    string UUID = 1;
    // name
    //
    // The name of the policy request to update. If both name and UUID are provided,
    // the name is ignored.
    string name = 2;
    // description
    //
    // A short (up to 256B) description for this resource.
    string description = 3;
    // policy
    //
    // At the moment, this can only be the QoSRateLimitPolicy to be updated
    oneof policy {
        QoSRateLimitPolicy qoSRateLimitPolicy = 4;
        // in the future we will move here schedule policy as well as other policies.
    }
}

message UpdatePolicyResponse {}

message ResourcePolicy {
    enum State {
        UnknownState = 0;
        Creating     = 1;
        Active       = 2;
        Deleting     = 3;
        Failed       = 4;
    }

    string UUID = 1;
    string name = 2;
    string resourceUUID = 3;
    string resourceName = 4;
    string projectName = 5;
    lightbits.api.duros.v2.SchedulePolicy schedulePolicy = 6;
    string description = 7;
    State state = 8;
}

message Policy {
    enum State {
        Unknown    = 0;
        Creating   = 1;
        Active     = 2;
        Updating   = 3;
        Deprecated = 4;
        Failed     = 5;
    }

    string UUID = 1;
    string name = 2;
    string description = 3;
    State state = 4;
    oneof info {
        QoSRateLimitPolicy QoSRateLimitPolicy = 5;
    }
}

message UpdateResourcePolicyRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["UUID", "schedulePolicy"]
        }
    };
    // UUID
    //
    // The UUID of the resource policy request to update.
    string UUID = 1;
    // projectName
    //
    // The name of the project this resource policy request belongs to.
    string projectName = 2;
    // schedulePolicy
    //
    // The updated schedule policy.
    lightbits.api.duros.v2.SchedulePolicy schedulePolicy = 3;
    // description
    //
    // An updated short (up to 256B) description.
    string description = 4;
}

message UpdateResourcePolicyResponse {}

message ListPoliciesRequest {
    // UUID
    //
    // Optionally filter specific policy by UUID.
    string UUID = 1;
    // name
    //
    // Optionally filter specific policy by name.
    string name = 2;
    // projectName
    //
    // Optionally filter policies by project name.
    string projectName = 3;
}

message ListPoliciesResponse {
    repeated Policy policies = 1;
}

message ListResourcePoliciesRequest {
    // UUID
    //
    // Optionally filter specific policy by UUID.
    string UUID = 1;
    // projectName
    //
    // Optionally filter policies by project name.
    string projectName = 2;
    // volumeUUID
    //
    // Optionally filter all policies of a specific volume.
    string volumeUUID  = 3;
}

message ListResourcePoliciesResponse {
    repeated ResourcePolicy resourcePolicies = 1;
    repeated DefaultGlobalResourcePolicy defaultResourcePolicies = 2;
}

message GetPolicyRequest {
    // UUID
    //
    // UUID of the policy to get (specify either UUID or name)
    string UUID = 1;
    // name
    //
    // name of the policy to get (specify either UUID or name)
    string name = 2;
    // projectName
    //
    // The name of the project this policy belongs to
    string projectName = 3;
}

message GetResourcePolicyRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["UUID"]
        }
    };
    // UUID
    //
    // The UUID of the resource policy to get.
    string UUID = 1;
    // projectName
    //
    // The name of the project this resource policy belongs to.
    string projectName = 2;
}

message DeleteResourcePolicyRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["UUID"]
        }
    };
    // UUID
    //
    // The UUID of the resource policy to get.
    string UUID = 1;
    // projectName
    //
    // The name of the project this resource policy belongs to.
    string projectName = 3;
}

message DeleteResourcePolicyResponse {}

message DeletePolicyRequest {
    // UUID
    //
    // UUID of the policy to delete (specify either UUID or name).
    string UUID = 1;
    // name
    //
    // name of the policy to delete (specify either UUID or name).
    string name = 2;
}

message DeletePolicyResponse {}

message GetClusterConfigParamRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // specify name of parameter to get: ClusterName/ ClockDriftIntervalForRaisingEvent/ DeviceHealthIntervalForRaisingEvent/
    // DurationToTurnIntoPermanentFailure/ VolumeDeletionFromNodeDelay/ DefaultQoSName/ AllowedNumRevives/ DisableVolumeStatisticsExport
    // EnableTrim/ EvictionNoProgressTimeout/ RevivesWindowDuration
    string name = 1;
}

message ClusterConfigParam {
    // ClusterConfigParam name
    //
    // Specify the name of the parameter to update: ClusterName [name]/ ClockDriftIntervalForRaisingEvent [time]/ DeviceHealthIntervalForRaisingEvent [time]/
    // DurationToTurnIntoPermanentFailure [time]/ VolumeDeletionFromNodeDelay [time]/ DefaultQoSName [string]/ AllowedNumRevives [int]
    // DisableVolumeStatisticsExport [bool]/ EnableTrim [bool]/ EvictionNoProgressTimeout [time]/ RevivesWindowDuration [time].
    string name = 1;
    // ClusterConfigParam value
    //
    // The value of the cluster config parameter, where the specific units are specific to the specified parameter.
    string value = 2;
}

message UpdateClusterConfigParamRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["configParam"]
        }
    };
    // configParam
    //
    // Cluster config parameter name and value to update.
    ClusterConfigParam configParam = 1;
}

message RollbackVolumeRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // UUID
    //
    // Volume UUID to rollback (specify either volume UUID or volume name).
    string UUID = 1;
    // srcSnapshotUUID
    //
    // Source snapshot UUID to rollback volume to (specify either snapshot UUID or volume name).
    string srcSnapshotUUID = 2;
    // projectName
    //
    // Project volume belongs to.
    string projectName = 3;
    // Name
    //
    // Volume Name (specify either volume UUID or volume name).
    string Name = 4;
    // srcSnapshotName
    //
    // Source snapshot name to rollback volume to (specify either snapshot UUID or volume name).
    string srcSnapshotName = 5;
}

message RollbackVolumeResponse {}

message UpdateClusterConfigParamResponse {}

message ListClusterConfigParamsRequest {}

message ListClusterConfigParamsResponse {
    repeated ClusterConfigParam values = 1;
}

message LabelValueKeyPair {
    enum Key {
        Unknown = 0;
        FD = 1;
        PrimaryFD = 2;
    };

    Key key = 1;
    string value = 2;
}

message LabelMatchExpression {
    enum Operator {
        Unknown = 0;
        In = 1;
    };
    // Volume affinity operation
    //
    // Volume affinity operator. Specifies that placement logic will match nodes that have labels in labelValueKeyPairs list.
    Operator operator = 1;
    // Volume affinity operation Key/Value pairs
    //
    // Volume affinity KeyPairs. Key currently must be fd (failure domain). Value should specify the failure domains we want to match.
    repeated LabelValueKeyPair labelValueKeyPairs = 2;
}

//ID of the impacted component (UUID/IP/serial number)
message ComponentVolumeInfo {
    // volume UUID
    string ID = 1;
    // volume name
    string Name = 2;
}

message VolumeComponentInfoList {
    repeated ComponentVolumeInfo VolumeComponentInfoList = 1;
}

message ComponentVolumesInfo {
    map<string, VolumeComponentInfoList> ProjectVolumesMap = 1;
}

message ComponentNodeInfo {
    // Node UUID
    string ID = 1;
    // Node name
    string Name = 2;
}

message ComponentClusterInfo {
    // cluster UUID
    string ID = 1;
    // cluster name
    string Name = 2;
}

message ComponentNVMeSSDInfo {
    // NVMe serial number
    string ID = 1;
    // SSD name
    string Name = 2;
}

message ComponentServerInfo {
    // Server UUID
    string ID = 1;
    // Server name
    string Name = 2;
}

message ComponentDataIntegrityInfo {
    string NodeUUID = 1;
    string ServerUUID = 2;
    repeated string SSDs = 3;
}

message LBARange {
    uint64 lbaStart = 1;
    uint64 lbaEnd = 2;
    bytes dataBitMap = 3;
}

 message ListChangedBlocksRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName"]
        }
    };
    // snapshotUUID
    //
    // Target snapshot UUID for comparison (specify either snapshotUUID or snapshotName).
    string snapshotUUID = 1;
    // baseSnapshotUUID
    //
    // Source snapshot UUID for comparison. Optional in case of full comparison
    // (specify either baseSnapshotUUID or baseSnapshotName).
    string baseSnapshotUUID = 2;
    // projectName
    //
    // Project name
    string projectName = 3;
    // offsetLBA
    //
    // The first offset from which the comparison shall start, aligned to 64 and rounded down.
    uint64 offsetLBA = 4;
    // snapshotName
    //
    // Target snapshot name for comparison (specify either snapshotUUID or snapshotName).
    string snapshotName = 5;
    // baseSnapshotName
    //
    // Source snapshot name for comparison. Optional in case of full comparison
    // (specify either baseSnapshotUUID or baseSnapshotName).
    string baseSnapshotName = 6;
}

 message ListChangedBlocksResponse {
    // nextOffsetLBA
    //
    // LBA Offset for next call, zero at the last call (when end of LBA range has been reached).
    uint64 nextOffsetLBA = 1;
    // lbaRanges
    //
    // List of ranges of the target snapshot UUID that differs from the base snapshot UUID.
    repeated LBARange lbaRanges = 2;
 }

// Event that will be returned to user
message Event {
    enum EventType {
        UnknownType = 0;
        Cluster = 1;
        Node = 2;
        Volume = 3;
        NVMeSSD = 4;
        Server = 5;
        DataIntegrity = 6;
        ClusterEncryption = 7;
    }

    enum EventReportingService {
        UnkownReportingService = 0;
        CM = 1;
        NM = 2;
        API = 3;
        UM = 4;
    }

    enum EventSeverity {
        UnkownSeverity = 0;
        Info = 1;
        Low = 2;
        Medium = 3;
        High = 4;
        Critical = 5;
    }

    // Event UUID
    string ID = 1;
    // Event start time
    google.protobuf.Timestamp Time = 2;
    // The component type impacted by the event
    EventType Type = 3;
    //The severity of the event
    EventSeverity Severity = 4;
    //The name of the event
    string EventName = 5;
    //The code of the cause of the event
    uint32 EventCode = 6;
    // The server that logged the event (Cluster Manager, Node Manager, etc)
    EventReportingService ReportingService = 7;
    // The event ID related to this event.
    string AssociatedEventID = 8;
    // Current status of the component
    string Status = 9;
    // The Cause of the event
    uint32 CauseCode = 10;
    // The Event Description
    string Description = 11;
    // Component information (specific to type)
    oneof ComponentInfo {
        ComponentVolumesInfo ComponentVolumesInfo = 201;
        ComponentNVMeSSDInfo ComponentNVMeSSDInfo = 202;
        ComponentNodeInfo ComponentNodeInfo = 203;
        ComponentServerInfo ComponentServerInfo = 204;
        ComponentClusterInfo ComponentClusterInfo = 205;
        ComponentDataIntegrityInfo ComponentDataIntegrityInfo = 206;
    }
}

enum PolicyVisibility {
    // Unavailable
    //
    // Unavailable - will be returned upon get/list QoS policies to non-cluster admin callers, or to all callers of "list" QoS policies if the result is filtered out by project name.
    Unavailable = 0;
    // Scoped
    //
    // Scoped - Indicates a private (scoped) policy (available only to projects specified in projectsNamesScope)
    Scoped = 1;
    // Global
    //
    // Global - indicates a global policy (available for all projects/volumes in a cluster)
    Global = 2;
}

message QoSRateLimitPolicy {
    // TODO: i think we can omit the prefix QoSLimit from the messages below
    // They will inherit the name of the outer message as prefix

    // A limit of 0 means no rate limit.
    // Bandwidth limit is in units of MB/s.
    message QoSLimitIOPS {
        // writeIOPSLimit
        //
        // Volume write bandwidth limits, specified in units of IOPs. The granularity increases by 256 IOPs each time. 0 means unlimited.
        uint32 writeIOPSLimit = 1;
        // readIOPSLimit
        //
        // Volume read bandwidth limits, specified in units of IOPs. The granularity increases by 256 IOPs each time. 0 means unlimited.
        uint32 readIOPSLimit = 2;
    }
    message QoSLimitBW{
        // writeBWLimit
        //
        // Volume write bandwidth limits, specified in units of MB/s. The granularity must be in full MB/s. 0 means unlimited.
        uint32 writeBWLimit = 1;
        // readBWLimit
        //
        // Volume read bandwidth limits, specified in units of MB/s. The granularity must be in full MB/s. 0 means unlimited.
        uint32 readBWLimit = 2;
    }
    message QoSLimitIOPSPerGB {
        // writeIOPSPerGBLimit
        //
        // Volume write bandwidth limits, specified in units of IOPs per GB of volume size. 0 means unlimited.
        uint32 writeIOPSPerGBLimit = 1;
        // readIOPSPerGBLimit
        //
        // Volume read bandwidth limits, specified in units of IOPs per GB of volume size. 0 means unlimited.
        uint32 readIOPSPerGBLimit = 2;
    }

    // projectsNamesScope
    //
    // Lists the projects that have access to this policy (relevant if policyVisibility=Scoped)
    repeated string projectsNamesScope = 3;
    // Policy Visibility
    //
    // Policy Visibility, specifics who has access to this policy
    PolicyVisibility policyVisibility = 4;
    oneof QoSLimit {
        QoSLimitIOPS limitIOPS = 6;
        QoSLimitBW limitBw = 7;
        QoSLimitIOPSPerGB limitIOPSPerGB = 8;
    }
}

enum PolicyType {
    // Unknown
    //
    // For internal use only
    unknown = 0;
    // Snapshot
    //
    // Create snapshots per volumes policy
    snapshot = 1;
    // QosRateLimit
    //
    // Volumes QoS rate limit policy
    qosRateLimit = 2;
}

message DefaultGlobalResourcePolicy {
    PolicyType policyType = 1;
    string policyUUID = 2;
}

message UpdateProjectRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["projectName", "defaultPolicies"]
        }
    };
    // projectName
    //
    // The name of the project to update.
    string projectName = 1;
    // defaultPolicies
    //
    // The updated default policies to apply to the project.
    repeated DefaultPolicy defaultPolicies = 2;
}

message UpdateProjectResponse {}

message ClusterEncryptionStatus {
    enum State {
        Disabled = 0; // Encryption is disabled
        Enabling = 1; // Enabling cluster encryption
        Enabled = 2;  // Cluster encryption is enabled
        Unknown = 3;  // Unknown state
    }

    enum RotationState {
        NoRotation = 0; // No rotation is in progress
        DistributingKEK = 1; // Distributing KEK to all nodes
        EncryptyingDEKs = 2; // Encrypting all DEKs with the new KEK
    }

    // encryptionState
    //
    // Indicates the encryption state of the cluster encryption status
    State encryptionState = 1;
    // kekGeneration
    //
    // The current generation of the KEK
    uint64 kekGeneration = 2;
    // kekUpdateDate
    //
    // The date of the last KEK update
    google.protobuf.Timestamp kekUpdateDate = 3;
    // previousKekGenerations
    //
    // The previous generations of the KEK
    repeated uint64 previousKekGenerations = 4;
    // rotationState
    //
    // Indicates the rotation state of the cluster encryption encryption status
    RotationState rotationState = 5;
}

enum IdpHealthStatus {
    IdpHealthStatus_Healthy = 0;
    IdpHealthStatus_UnHealthy = 1;
    IdpHealthStatus_Unknown = 2;
}

message IdpHealthInfo {
    string serverName = 1;
    IdpHealthStatus idpHealthStatus = 2;
    google.protobuf.Timestamp timestamp = 3;
    string healthErrorMessage = 4;
}

message FederatedAuthenticationStatus {
    bool federatedAuthenticationEnabled = 1;
    repeated IdpHealthInfo idpHealthInfos = 2;
}

message RotateClusterRootKeyRequest {}

message RotateClusterRootKeyResponse {}

message GetClusterRootKeyRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["userPublicKey"]
        }
    };
    // encryptingKeyGeneration
    //
    // The generation of the encryption key. if not specified, the latest key will be exported.
    uint64 encryptingKeyGeneration = 1;
    // userPublicKey
    //
    // Public key to use in order to encrypt the exported KEK.
    bytes userPublicKey = 2;
}

message GetClusterRootKeyResponse {
    message KeyObject{
        // encryptedKey
        //
        // Cluster Encryption key encrypted with the given public key.
        bytes encryptedKey = 1;
        // encryptingKeyGeneration
        //
        // The Generation of the exported key.
        uint64 encryptingKeyGeneration = 2;
    }
    // keys
    //
    // The object that includes each exported key and its generation.
    KeyObject key = 1;
}

enum IDPType {
    unknownIdp = 0;
    ADFS     = 1;
}

// IDPConfiguration represents the configuration for the Identity Provider (IdP) in the Lightbits cluster.
message IDPConfiguration {


    enum IDPConfigurationState {
        // 0
        //
        // For internal use only.
        Unknown    = 0;
        // 1
        //
        // The IdP configuration is being created.
        Creating   = 1;
        // 2
        //
        // The IdP configuration is active.
        Active     = 2;
        // 3
        //
        // The IdP configuration is being updated.
        Updating   = 3;
        // 4
        //
        // Failed to create a new IdP configuration.
        Failed     = 4;
    }

    //
    // Unique name identifying this IdP configuration.
    string name = 1;
    //
    // The URL of the Identity Provider (IdP) issuer.
    string idpIssuerURL = 2;
    //
    // The current state of the IdP configuration.
    IDPConfigurationState state = 3;
    //
    // Type of an IdP (Identity Provider). Currently only ADFS is supported.
    IDPType type = 4;
    //
    // The UUID of this IdP configuration.
    string UUID = 5;
    //
    // Optional. Proxy server information for an IdP that is accessed via proxy.
    ProxyInfo proxyInfo = 6;
}

message CreateIDPConfigurationRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "idpIssuerURL", "type"]
        }
    };
    // name
    //
    // The unique name to assign to this IdP configuration.
    string name = 1;
    // idpIssuerURL
    //
    // The URL of the Identity Provider (IdP) issuer.
    string idpIssuerURL = 2;
    // type
    //
    // Type of an IdP (Identity Provider). Currently only ADFS is supported.
    IDPType type = 3;
    // ProxyInfo
    //
    // Optional. Proxy server information for an IdP that is accessed via proxy.
    ProxyInfo proxyInfo = 4;
}

message UpdateIDPConfigurationRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // Specify name of the IdP configuration to update.
    string name = 1;
    // idpIssuerURL
    //
    // The URL of the Identity Provider (IdP) issuer.
    string idpIssuerURL = 2;
    // type
    //
    // The type of an IdP (Identity Provider). Currently only ADFS is supported.
    IDPType type = 3;
    // proxyInfo
    //
    // Proxy server information for an IdP that is accessed via proxy.
    ProxyInfo proxyInfo = 4;
}

message ListIDPConfigurationsRequest{}

message ListIDPConfigurationsResponse{
    repeated IDPConfiguration idpConfigurations = 1;
}

message GetIDPConfigurationRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the IdP configuration to get.
    string name = 1;
}

message DeleteIDPConfigurationRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the IdP configuration to delete.
    string name = 1;
}

message DeleteIDPConfigurationResponse {}

// idp-client-configuration represents a configuration of a client-specific IdP entry in the Lightbits cluster.
// The Lightbits cluster supports IdP client configurations with three types of authorization modes:
// App, User, and Converge.
// App authorization mode should be used when Lightbits should map a specific client to a scope and role.
// User authorization mode should be used when Lightbits should map according to both the client ID and a specific claim in the JWT.
// Converge mode is used when Lightbits should map only according to the claim in the JWT. In this mode the client ID is ignored.
// Only a single such entry can be created for each IdP configuration. Lightbits API service will first attempt to check for a
// dedicated IdP client configuration using this client ID, falling back to to an optional converge entry only if no direct client specific
// entry is found.
 message IdpClientConf {
    //
    // The UUID of the idp-client-config entry.
    string UUID = 1;
    //
    // A unique name of the idp-client-conf.
    string name = 2;
    // clientId
    //
    // A unique client ID identifier registered in the IdP to identify a
    //  specific application (or a client) that wants to access resources
    //  from a Lightbits cluster.
    //  When using converge authorization mode, this field must be configured to:
    //  NOT_APPLICABLE.
    string clientId = 3;
    //
    // A reference to the IdP configuration that will use this client
    //  configuration.
    string idpConfigurationName = 4;
    //
    // When working in user authorization/converge mode, the claim name specifies
    //  the name of the field in JWT claim from which to extract the identifier
    //  value from.
    //  Note that this field is only required when authzMode is user or converge.
    string claimName = 5;
    // authzMode
    //
    // The authorization mode will determine what information from access JWT
    //  will be mapped to a matching scope/role in the Lightbits cluster.
    //  The authorization mode can be one of the following:
    //  user, app, converge.
    AuthorizationMode authzMode = 6;
}

message CreateIdpClientConfRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "clientId", "idpConfigurationName", "authzMode"]
        }
    };
    // name
    //
    // A unique name of the idp-client-conf.
    string name = 1;
    // clientId
    //
    // A unique client ID identifier registered in the IdP to identify a
    //  specific application (or a client) that wants to access resources
    //  from a Lightbits cluster.
    //  When using converge authorization mode, this field must be configured to:
    //  NOT_APPLICABLE.
    string clientId = 2;
    // idpConfigurationName
    //
    // A reference to the IdP configuration that will use this client
    //  configuration.
    string idpConfigurationName = 3;
    // claimName
    //
    // When working in user authorization/converge mode, the claim name specifies
    //  the name of the field in the JWT claim from which to extract the identifier
    //  value from.
    //  Note that this field is only required when authzMode is user or converge.
    string claimName = 4;
    //
    // The authorization mode will determine what information from access JWT
    //  will be mapped to a matching scope/role in the Lightbits cluster.
    //  The authorization mode can be one of the following:
    //  user, app, converge.
    AuthorizationMode authzMode = 5;
}

message UpdateIdpClientConfRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "claimName"]
        }
    };
    // name
    //
    // The name of the idp-client-conf to update.
    string name = 1;
    // claimName
    //
    // When working in user authorization/converge mode, the claim name specifies
    //  the name of the field in the JWT claim from which to extract the identifier
    //  value from.
    //  Note that this field is only required when authzMode is user or converge.
    string claimName = 2;
}

message GetIdpClientConfRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the idp-client-conf to get.
    string name = 1;
}

message DeleteIdpClientConfRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // The name of the idp-client-conf to delete.
    string name = 1;
}

message DeleteIdpClientConfResponse {}

message ListIdpClientConfsRequest{}

message ListIdpClientConfsResponse{
    repeated IdpClientConf idpClientConfigurations = 1;
}

message AuthMapEntry {
    reserved "state";
    reserved 1;
    //
    // AuthMapEntry UUID
    string UUID = 2;
    //
    // Name of specific authorization mapping entry.
    string name = 3;
    //
    // Identifier to map application or clientID/claim/group to Lightbits scope/role.
    //  This should either have the clientID of the relevant application (app mode), or
    //  an identifier of a specific claim/group extracted from the field specified by claimName
    //  (user or converge modes).
    string identifier = 4;
    //
    // Represents the scope assigned to this client/claim/group in the Lightbits cluster.
    string scope = 5;
    //
    // Represents the role assigned to this client/claim/group in the Lightbits cluster.
    string role = 6;
    //
    // IdP configuration that is associated with this authorization map entry.
    string idpConfigurationName = 7;
}

message CreateAuthMapEntryRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "identifier", "scope", "role", "idpConfigurationName"]
        }
    };
    // name
    //
    // Name of a specific authorization mapping entry.
    string name = 1;
    // identifier
    //
    // Identifier to map application or clientID/claim/group to Lightbits scope/role.
    //  This should either have the clientID of the relevant application (app mode) or
    //  an identifier of a specific claim/group extracted from the field specified by claimName
    //  (user or converge modes).
    string identifier = 2;
    // scope
    //
    // Represents the scope assigned to this client/claim/group in the Lightbits cluster.
    string scope = 3;
    // Role
    //
    // Represents the role assigned to this client/claim/group in the Lightbits cluster.
    string role = 4;
    // idpConfigurationName
    //
    // Idp configuration that is associated with this authorization map entry.
    string idpConfigurationName = 5;
}

message UpdateAuthMapEntryRequest {

    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name", "identifier", "scope", "role", "idpConfigurationName"]
        }
    };
    // name
    //
    // Name of a specific authorization mapping entry.
    string name = 1;
    // scope
    //
    // The scope assigned to this client/claim/group in the Lightbits cluster.
    string scope = 2;
    // role
    //
    // The role assigned to this client/claim/group in the Lightbits cluster.
    string role = 3;
    // identifier
    //
    // Identifier to map application or claim/group to a Lightbits scope/role.
    //  This should either have the clientID of the relevant application (app mode) or
    //  an identifier of a specific claim/group extracted from the field specified by claimName
    //  (user or converge modes).
    string identifier = 4;
    // idpConfigurationName
    //
    // IdP configuration that is associated with this authorization map entry.
    string idpConfigurationName = 5;
}

message DeleteAuthMapEntryRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // Name of a specific authorization mapping entry.
    string name = 1;
}

message GetAuthMapEntryRequest {
    option (grpc.gateway.protoc_gen_swagger.options.openapiv2_schema) = {
        json_schema: {
          required: ["name"]
        }
    };
    // name
    //
    // Name of a specific authorization mapping entry.
    string name = 1;
}

message ListAuthMapEntriesRequest {}

message DeleteAuthMapEntryResponse {}

message ListAuthMapEntriesResponse {
    repeated AuthMapEntry authMapEntries = 1;
}

message EnableFederatedAuthenticationRequest {}

message EnableFederatedAuthenticationResponse {}

message DisableFederatedAuthenticationRequest {}

message DisableFederatedAuthenticationResponse {}

enum fedAuthState {
    FederatedAuthenticationDisabled = 0;
    FederatedAuthenticationEnabled = 1;
}

message GetFederatedAuthenticationStatusResponse {
    fedAuthState federatedAuthenticationState = 1;
}
