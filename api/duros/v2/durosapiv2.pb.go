// Code generated by protoc-gen-go. DO NOT EDIT.
// versions:
// 	protoc-gen-go v1.36.11
// 	protoc        (unknown)
// source: lightbits/api/duros/v2/durosapiv2.proto

package v2

import (
	_ "github.com/grpc-ecosystem/grpc-gateway/protoc-gen-swagger/options"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	httpbody "google.golang.org/genproto/googleapis/api/httpbody"
	protoreflect "google.golang.org/protobuf/reflect/protoreflect"
	protoimpl "google.golang.org/protobuf/runtime/protoimpl"
	durationpb "google.golang.org/protobuf/types/known/durationpb"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	reflect "reflect"
	sync "sync"
	unsafe "unsafe"
)

const (
	// Verify that this generated code is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(20 - protoimpl.MinVersion)
	// Verify that runtime/protoimpl is sufficiently up-to-date.
	_ = protoimpl.EnforceVersion(protoimpl.MaxVersion - 20)
)

type CredsType int32

const (
	CredsType_UnknownType     CredsType = 0
	CredsType_RS256PubKey     CredsType = 1
	CredsType_TlsCertChainPem CredsType = 2
	CredsType_TlsPrivKeyPem   CredsType = 3
)

// Enum value maps for CredsType.
var (
	CredsType_name = map[int32]string{
		0: "UnknownType",
		1: "RS256PubKey",
		2: "TlsCertChainPem",
		3: "TlsPrivKeyPem",
	}
	CredsType_value = map[string]int32{
		"UnknownType":     0,
		"RS256PubKey":     1,
		"TlsCertChainPem": 2,
		"TlsPrivKeyPem":   3,
	}
)

func (x CredsType) Enum() *CredsType {
	p := new(CredsType)
	*p = x
	return p
}

func (x CredsType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CredsType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[0].Descriptor()
}

func (CredsType) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[0]
}

func (x CredsType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CredsType.Descriptor instead.
func (CredsType) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{0}
}

// CredsKind specifies the intended usage and origin of the credentials. It cannot be
// set directly by the user when uploading credentials and cannot be modified at all after the
// credentials were created.
type CredsKind int32

const (
	// Credentials directly managed by the users.
	CredsKind_UserCreds CredsKind = 0
	// Credentials that will be used by Lightbits Photon to submit requests either on
	// behalf of the Photon users, or for Photon requests to fetch the cluster metadata.
	//
	// These credentials can be viewed by the users, but can only be modified indirectly,
	// as part of the Beacon service configuration/management process.
	CredsKind_BeaconCreds CredsKind = 2
	// Lightbits server encountered credentials possibly created by a newer Lightbits
	// SW version than that running on the server itself.
	CredsKind_UnknownKind CredsKind = 127
)

// Enum value maps for CredsKind.
var (
	CredsKind_name = map[int32]string{
		0:   "UserCreds",
		2:   "BeaconCreds",
		127: "UnknownKind",
	}
	CredsKind_value = map[string]int32{
		"UserCreds":   0,
		"BeaconCreds": 2,
		"UnknownKind": 127,
	}
)

func (x CredsKind) Enum() *CredsKind {
	p := new(CredsKind)
	*p = x
	return p
}

func (x CredsKind) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CredsKind) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[1].Descriptor()
}

func (CredsKind) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[1]
}

func (x CredsKind) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CredsKind.Descriptor instead.
func (CredsKind) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{1}
}

type ProtectionStateEnum int32

const (
	// Unknown.
	//
	// Reserved value.
	ProtectionStateEnum_Unknown ProtectionStateEnum = 0
	// FullyProtected
	//
	// Volume supports write/read and replication, All volumes replicas are healthy.
	ProtectionStateEnum_FullyProtected ProtectionStateEnum = 1
	// Degraded
	//
	// Volume supports write/read,  Data may not be replicated,
	// at least one of the volume's replicas is unhealthy (node is inactive, is full, or not synced).
	ProtectionStateEnum_Degraded ProtectionStateEnum = 2
	// ReadOnly
	//
	// Volume supports only read, Data may not be replicated,
	// at least one of the volume's replicas is unhealthy (node is inactive, is full or not synced).
	ProtectionStateEnum_ReadOnly ProtectionStateEnum = 3
	// NotAvailable.
	//
	// Volume can not be used for read or write, all volume's replicas are unhealthy (node is inactive or not synced).
	ProtectionStateEnum_NotAvailable ProtectionStateEnum = 4
)

// Enum value maps for ProtectionStateEnum.
var (
	ProtectionStateEnum_name = map[int32]string{
		0: "Unknown",
		1: "FullyProtected",
		2: "Degraded",
		3: "ReadOnly",
		4: "NotAvailable",
	}
	ProtectionStateEnum_value = map[string]int32{
		"Unknown":        0,
		"FullyProtected": 1,
		"Degraded":       2,
		"ReadOnly":       3,
		"NotAvailable":   4,
	}
)

func (x ProtectionStateEnum) Enum() *ProtectionStateEnum {
	p := new(ProtectionStateEnum)
	*p = x
	return p
}

func (x ProtectionStateEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ProtectionStateEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[2].Descriptor()
}

func (ProtectionStateEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[2]
}

func (x ProtectionStateEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ProtectionStateEnum.Descriptor instead.
func (ProtectionStateEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{2}
}

type PolicyVisibility int32

const (
	// Unavailable
	//
	// Unavailable - will be returned upon get/list QoS policies to non-cluster admin callers, or to all callers of "list" QoS policies if the result is filtered out by project name.
	PolicyVisibility_Unavailable PolicyVisibility = 0
	// Scoped
	//
	// Scoped - Indicates a private (scoped) policy (available only to projects specified in projectsNamesScope)
	PolicyVisibility_Scoped PolicyVisibility = 1
	// Global
	//
	// Global - indicates a global policy (available for all projects/volumes in a cluster)
	PolicyVisibility_Global PolicyVisibility = 2
)

// Enum value maps for PolicyVisibility.
var (
	PolicyVisibility_name = map[int32]string{
		0: "Unavailable",
		1: "Scoped",
		2: "Global",
	}
	PolicyVisibility_value = map[string]int32{
		"Unavailable": 0,
		"Scoped":      1,
		"Global":      2,
	}
)

func (x PolicyVisibility) Enum() *PolicyVisibility {
	p := new(PolicyVisibility)
	*p = x
	return p
}

func (x PolicyVisibility) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyVisibility) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[3].Descriptor()
}

func (PolicyVisibility) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[3]
}

func (x PolicyVisibility) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyVisibility.Descriptor instead.
func (PolicyVisibility) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{3}
}

type PolicyType int32

const (
	// Unknown
	//
	// For internal use only
	PolicyType_unknown PolicyType = 0
	// Snapshot
	//
	// Create snapshots per volumes policy
	PolicyType_snapshot PolicyType = 1
	// QosRateLimit
	//
	// Volumes QoS rate limit policy
	PolicyType_qosRateLimit PolicyType = 2
)

// Enum value maps for PolicyType.
var (
	PolicyType_name = map[int32]string{
		0: "unknown",
		1: "snapshot",
		2: "qosRateLimit",
	}
	PolicyType_value = map[string]int32{
		"unknown":      0,
		"snapshot":     1,
		"qosRateLimit": 2,
	}
)

func (x PolicyType) Enum() *PolicyType {
	p := new(PolicyType)
	*p = x
	return p
}

func (x PolicyType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (PolicyType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[4].Descriptor()
}

func (PolicyType) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[4]
}

func (x PolicyType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use PolicyType.Descriptor instead.
func (PolicyType) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{4}
}

type IdpHealthStatus int32

const (
	IdpHealthStatus_IdpHealthStatus_Healthy   IdpHealthStatus = 0
	IdpHealthStatus_IdpHealthStatus_UnHealthy IdpHealthStatus = 1
	IdpHealthStatus_IdpHealthStatus_Unknown   IdpHealthStatus = 2
)

// Enum value maps for IdpHealthStatus.
var (
	IdpHealthStatus_name = map[int32]string{
		0: "IdpHealthStatus_Healthy",
		1: "IdpHealthStatus_UnHealthy",
		2: "IdpHealthStatus_Unknown",
	}
	IdpHealthStatus_value = map[string]int32{
		"IdpHealthStatus_Healthy":   0,
		"IdpHealthStatus_UnHealthy": 1,
		"IdpHealthStatus_Unknown":   2,
	}
)

func (x IdpHealthStatus) Enum() *IdpHealthStatus {
	p := new(IdpHealthStatus)
	*p = x
	return p
}

func (x IdpHealthStatus) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IdpHealthStatus) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[5].Descriptor()
}

func (IdpHealthStatus) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[5]
}

func (x IdpHealthStatus) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IdpHealthStatus.Descriptor instead.
func (IdpHealthStatus) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{5}
}

type IDPType int32

const (
	IDPType_unknownIdp IDPType = 0
	IDPType_ADFS       IDPType = 1
)

// Enum value maps for IDPType.
var (
	IDPType_name = map[int32]string{
		0: "unknownIdp",
		1: "ADFS",
	}
	IDPType_value = map[string]int32{
		"unknownIdp": 0,
		"ADFS":       1,
	}
)

func (x IDPType) Enum() *IDPType {
	p := new(IDPType)
	*p = x
	return p
}

func (x IDPType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IDPType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[6].Descriptor()
}

func (IDPType) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[6]
}

func (x IDPType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IDPType.Descriptor instead.
func (IDPType) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{6}
}

type FedAuthState int32

const (
	FedAuthState_FederatedAuthenticationDisabled FedAuthState = 0
	FedAuthState_FederatedAuthenticationEnabled  FedAuthState = 1
)

// Enum value maps for FedAuthState.
var (
	FedAuthState_name = map[int32]string{
		0: "FederatedAuthenticationDisabled",
		1: "FederatedAuthenticationEnabled",
	}
	FedAuthState_value = map[string]int32{
		"FederatedAuthenticationDisabled": 0,
		"FederatedAuthenticationEnabled":  1,
	}
)

func (x FedAuthState) Enum() *FedAuthState {
	p := new(FedAuthState)
	*p = x
	return p
}

func (x FedAuthState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (FedAuthState) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[7].Descriptor()
}

func (FedAuthState) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[7]
}

func (x FedAuthState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use FedAuthState.Descriptor instead.
func (FedAuthState) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{7}
}

type CreateVolumeRequest_SectorSizeEnum int32

const (
	CreateVolumeRequest_sectorSize_Default CreateVolumeRequest_SectorSizeEnum = 0
	CreateVolumeRequest_sectorSize_512B    CreateVolumeRequest_SectorSizeEnum = 512
	CreateVolumeRequest_sectorSize_4K      CreateVolumeRequest_SectorSizeEnum = 4096
)

// Enum value maps for CreateVolumeRequest_SectorSizeEnum.
var (
	CreateVolumeRequest_SectorSizeEnum_name = map[int32]string{
		0:    "sectorSize_Default",
		512:  "sectorSize_512B",
		4096: "sectorSize_4K",
	}
	CreateVolumeRequest_SectorSizeEnum_value = map[string]int32{
		"sectorSize_Default": 0,
		"sectorSize_512B":    512,
		"sectorSize_4K":      4096,
	}
)

func (x CreateVolumeRequest_SectorSizeEnum) Enum() *CreateVolumeRequest_SectorSizeEnum {
	p := new(CreateVolumeRequest_SectorSizeEnum)
	*p = x
	return p
}

func (x CreateVolumeRequest_SectorSizeEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (CreateVolumeRequest_SectorSizeEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[8].Descriptor()
}

func (CreateVolumeRequest_SectorSizeEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[8]
}

func (x CreateVolumeRequest_SectorSizeEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use CreateVolumeRequest_SectorSizeEnum.Descriptor instead.
func (CreateVolumeRequest_SectorSizeEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{26, 0}
}

type EnableClusterEncryptionRequest_KeyStore int32

const (
	EnableClusterEncryptionRequest_file EnableClusterEncryptionRequest_KeyStore = 0
	EnableClusterEncryptionRequest_tpm  EnableClusterEncryptionRequest_KeyStore = 1
)

// Enum value maps for EnableClusterEncryptionRequest_KeyStore.
var (
	EnableClusterEncryptionRequest_KeyStore_name = map[int32]string{
		0: "file",
		1: "tpm",
	}
	EnableClusterEncryptionRequest_KeyStore_value = map[string]int32{
		"file": 0,
		"tpm":  1,
	}
)

func (x EnableClusterEncryptionRequest_KeyStore) Enum() *EnableClusterEncryptionRequest_KeyStore {
	p := new(EnableClusterEncryptionRequest_KeyStore)
	*p = x
	return p
}

func (x EnableClusterEncryptionRequest_KeyStore) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (EnableClusterEncryptionRequest_KeyStore) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[9].Descriptor()
}

func (EnableClusterEncryptionRequest_KeyStore) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[9]
}

func (x EnableClusterEncryptionRequest_KeyStore) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use EnableClusterEncryptionRequest_KeyStore.Descriptor instead.
func (EnableClusterEncryptionRequest_KeyStore) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{37, 0}
}

type UserNvmeDevicesResponse_StateEnum int32

const (
	UserNvmeDevicesResponse_None       UserNvmeDevicesResponse_StateEnum = 0
	UserNvmeDevicesResponse_Healthy    UserNvmeDevicesResponse_StateEnum = 1
	UserNvmeDevicesResponse_Adding     UserNvmeDevicesResponse_StateEnum = 2
	UserNvmeDevicesResponse_Rebuilding UserNvmeDevicesResponse_StateEnum = 3
	UserNvmeDevicesResponse_Failed     UserNvmeDevicesResponse_StateEnum = 4
)

// Enum value maps for UserNvmeDevicesResponse_StateEnum.
var (
	UserNvmeDevicesResponse_StateEnum_name = map[int32]string{
		0: "None",
		1: "Healthy",
		2: "Adding",
		3: "Rebuilding",
		4: "Failed",
	}
	UserNvmeDevicesResponse_StateEnum_value = map[string]int32{
		"None":       0,
		"Healthy":    1,
		"Adding":     2,
		"Rebuilding": 3,
		"Failed":     4,
	}
)

func (x UserNvmeDevicesResponse_StateEnum) Enum() *UserNvmeDevicesResponse_StateEnum {
	p := new(UserNvmeDevicesResponse_StateEnum)
	*p = x
	return p
}

func (x UserNvmeDevicesResponse_StateEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UserNvmeDevicesResponse_StateEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[10].Descriptor()
}

func (UserNvmeDevicesResponse_StateEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[10]
}

func (x UserNvmeDevicesResponse_StateEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UserNvmeDevicesResponse_StateEnum.Descriptor instead.
func (UserNvmeDevicesResponse_StateEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{54, 0}
}

type UserNvmeDevicesResponse_DeviceUsageEnum int32

const (
	UserNvmeDevicesResponse_Unknown   UserNvmeDevicesResponse_DeviceUsageEnum = 0
	UserNvmeDevicesResponse_Data      UserNvmeDevicesResponse_DeviceUsageEnum = 1
	UserNvmeDevicesResponse_Journal   UserNvmeDevicesResponse_DeviceUsageEnum = 2
	UserNvmeDevicesResponse_OS        UserNvmeDevicesResponse_DeviceUsageEnum = 3
	UserNvmeDevicesResponse_UnManaged UserNvmeDevicesResponse_DeviceUsageEnum = 4
)

// Enum value maps for UserNvmeDevicesResponse_DeviceUsageEnum.
var (
	UserNvmeDevicesResponse_DeviceUsageEnum_name = map[int32]string{
		0: "Unknown",
		1: "Data",
		2: "Journal",
		3: "OS",
		4: "UnManaged",
	}
	UserNvmeDevicesResponse_DeviceUsageEnum_value = map[string]int32{
		"Unknown":   0,
		"Data":      1,
		"Journal":   2,
		"OS":        3,
		"UnManaged": 4,
	}
)

func (x UserNvmeDevicesResponse_DeviceUsageEnum) Enum() *UserNvmeDevicesResponse_DeviceUsageEnum {
	p := new(UserNvmeDevicesResponse_DeviceUsageEnum)
	*p = x
	return p
}

func (x UserNvmeDevicesResponse_DeviceUsageEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (UserNvmeDevicesResponse_DeviceUsageEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[11].Descriptor()
}

func (UserNvmeDevicesResponse_DeviceUsageEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[11]
}

func (x UserNvmeDevicesResponse_DeviceUsageEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use UserNvmeDevicesResponse_DeviceUsageEnum.Descriptor instead.
func (UserNvmeDevicesResponse_DeviceUsageEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{54, 1}
}

type DurosNodeInfo_State int32

const (
	// 0
	//
	// Reserved value. Default should return an error, rather than a true state that is incorrect.
	DurosNodeInfo_Unknown DurosNodeInfo_State = 0
	// 1
	//
	// Node is completed join cluster flow.
	DurosNodeInfo_Active DurosNodeInfo_State = 1
	// 2
	//
	// Node is is the process of coming up (starting required services) and joining cluster.
	DurosNodeInfo_Activating DurosNodeInfo_State = 2
	// 3
	//
	// Node is is Inactive (this includes internal states Removing and failed).
	DurosNodeInfo_Inactive DurosNodeInfo_State = 3
	// 4
	//
	// Node is not attached to cluster (none of the cluster pgs contain this pg).
	DurosNodeInfo_Unattached DurosNodeInfo_State = 4
	// 6
	//
	// Attaching a node to the cluster ongoing (replacing old node in pgs with this node).
	DurosNodeInfo_Attaching DurosNodeInfo_State = 6
	// 7
	//
	// Detaching a node from the cluster ongoing (replacing this node in pgs with this a new node).
	DurosNodeInfo_Detaching DurosNodeInfo_State = 7
)

// Enum value maps for DurosNodeInfo_State.
var (
	DurosNodeInfo_State_name = map[int32]string{
		0: "Unknown",
		1: "Active",
		2: "Activating",
		3: "Inactive",
		4: "Unattached",
		6: "Attaching",
		7: "Detaching",
	}
	DurosNodeInfo_State_value = map[string]int32{
		"Unknown":    0,
		"Active":     1,
		"Activating": 2,
		"Inactive":   3,
		"Unattached": 4,
		"Attaching":  6,
		"Detaching":  7,
	}
)

func (x DurosNodeInfo_State) Enum() *DurosNodeInfo_State {
	p := new(DurosNodeInfo_State)
	*p = x
	return p
}

func (x DurosNodeInfo_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DurosNodeInfo_State) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[12].Descriptor()
}

func (DurosNodeInfo_State) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[12]
}

func (x DurosNodeInfo_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DurosNodeInfo_State.Descriptor instead.
func (DurosNodeInfo_State) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{55, 0}
}

// Machine-readable internal state of the node we want to report to the cluster.
type DurosNodeInfo_StatusEnum int32

const (
	DurosNodeInfo_NoStatus DurosNodeInfo_StatusEnum = 0
	// reported during NodeStateEnum==Adding
	DurosNodeInfo_ConnectivityOK      DurosNodeInfo_StatusEnum = 1
	DurosNodeInfo_ConnectivityProblem DurosNodeInfo_StatusEnum = 2
	// reported during NodeStateEnum==Removing
	DurosNodeInfo_IssuedDeletePeer DurosNodeInfo_StatusEnum = 3
)

// Enum value maps for DurosNodeInfo_StatusEnum.
var (
	DurosNodeInfo_StatusEnum_name = map[int32]string{
		0: "NoStatus",
		1: "ConnectivityOK",
		2: "ConnectivityProblem",
		3: "IssuedDeletePeer",
	}
	DurosNodeInfo_StatusEnum_value = map[string]int32{
		"NoStatus":            0,
		"ConnectivityOK":      1,
		"ConnectivityProblem": 2,
		"IssuedDeletePeer":    3,
	}
)

func (x DurosNodeInfo_StatusEnum) Enum() *DurosNodeInfo_StatusEnum {
	p := new(DurosNodeInfo_StatusEnum)
	*p = x
	return p
}

func (x DurosNodeInfo_StatusEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (DurosNodeInfo_StatusEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[13].Descriptor()
}

func (DurosNodeInfo_StatusEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[13]
}

func (x DurosNodeInfo_StatusEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use DurosNodeInfo_StatusEnum.Descriptor instead.
func (DurosNodeInfo_StatusEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{55, 1}
}

type ClusterLastUpgrade_UpgradeStatusEnum int32

const (
	ClusterLastUpgrade_Unknown       ClusterLastUpgrade_UpgradeStatusEnum = 0
	ClusterLastUpgrade_None          ClusterLastUpgrade_UpgradeStatusEnum = 1
	ClusterLastUpgrade_UpgradeFailed ClusterLastUpgrade_UpgradeStatusEnum = 2
	ClusterLastUpgrade_Upgrading     ClusterLastUpgrade_UpgradeStatusEnum = 3
)

// Enum value maps for ClusterLastUpgrade_UpgradeStatusEnum.
var (
	ClusterLastUpgrade_UpgradeStatusEnum_name = map[int32]string{
		0: "Unknown",
		1: "None",
		2: "UpgradeFailed",
		3: "Upgrading",
	}
	ClusterLastUpgrade_UpgradeStatusEnum_value = map[string]int32{
		"Unknown":       0,
		"None":          1,
		"UpgradeFailed": 2,
		"Upgrading":     3,
	}
)

func (x ClusterLastUpgrade_UpgradeStatusEnum) Enum() *ClusterLastUpgrade_UpgradeStatusEnum {
	p := new(ClusterLastUpgrade_UpgradeStatusEnum)
	*p = x
	return p
}

func (x ClusterLastUpgrade_UpgradeStatusEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterLastUpgrade_UpgradeStatusEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[14].Descriptor()
}

func (ClusterLastUpgrade_UpgradeStatusEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[14]
}

func (x ClusterLastUpgrade_UpgradeStatusEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterLastUpgrade_UpgradeStatusEnum.Descriptor instead.
func (ClusterLastUpgrade_UpgradeStatusEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{81, 0}
}

type ClusterInfo_AuthenticationMode int32

const (
	ClusterInfo_UnKnown  ClusterInfo_AuthenticationMode = 0
	ClusterInfo_Enabled  ClusterInfo_AuthenticationMode = 2
	ClusterInfo_Disabled ClusterInfo_AuthenticationMode = 3
)

// Enum value maps for ClusterInfo_AuthenticationMode.
var (
	ClusterInfo_AuthenticationMode_name = map[int32]string{
		0: "UnKnown",
		2: "Enabled",
		3: "Disabled",
	}
	ClusterInfo_AuthenticationMode_value = map[string]int32{
		"UnKnown":  0,
		"Enabled":  2,
		"Disabled": 3,
	}
)

func (x ClusterInfo_AuthenticationMode) Enum() *ClusterInfo_AuthenticationMode {
	p := new(ClusterInfo_AuthenticationMode)
	*p = x
	return p
}

func (x ClusterInfo_AuthenticationMode) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterInfo_AuthenticationMode) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[15].Descriptor()
}

func (ClusterInfo_AuthenticationMode) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[15]
}

func (x ClusterInfo_AuthenticationMode) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterInfo_AuthenticationMode.Descriptor instead.
func (ClusterInfo_AuthenticationMode) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{82, 0}
}

type ClusterHealth_State int32

const (
	ClusterHealth_None    ClusterHealth_State = 0
	ClusterHealth_OK      ClusterHealth_State = 1
	ClusterHealth_Warning ClusterHealth_State = 2
	ClusterHealth_Error   ClusterHealth_State = 3
)

// Enum value maps for ClusterHealth_State.
var (
	ClusterHealth_State_name = map[int32]string{
		0: "None",
		1: "OK",
		2: "Warning",
		3: "Error",
	}
	ClusterHealth_State_value = map[string]int32{
		"None":    0,
		"OK":      1,
		"Warning": 2,
		"Error":   3,
	}
)

func (x ClusterHealth_State) Enum() *ClusterHealth_State {
	p := new(ClusterHealth_State)
	*p = x
	return p
}

func (x ClusterHealth_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterHealth_State) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[16].Descriptor()
}

func (ClusterHealth_State) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[16]
}

func (x ClusterHealth_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterHealth_State.Descriptor instead.
func (ClusterHealth_State) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{84, 0}
}

type Volume_StateEnum int32

const (
	// Unknown.
	//
	// Reserved value.
	Volume_Unknown Volume_StateEnum = 0
	// Creating.
	//
	// Volume is being created.
	Volume_Creating Volume_StateEnum = 1
	// Available.
	//
	// Volume is available for use. No ongoing operations on volume.
	Volume_Available Volume_StateEnum = 2
	// Deleting.
	//
	// Volume is being deleted.
	Volume_Deleting Volume_StateEnum = 3
	// Deleted.
	//
	// Volume was deleted.
	Volume_Deleted Volume_StateEnum = 4
	// Failed.
	//
	// Volume creation failed.
	Volume_Failed Volume_StateEnum = 7
	// Updating.
	//
	// Volume is being updated.
	Volume_Updating Volume_StateEnum = 8
	// Rollback.
	//
	// Volume is being rolled back to a specified snapshot.
	Volume_Rollback Volume_StateEnum = 9
	// Migrating.
	//
	// One of the volume's replicas is being migrated.
	Volume_Migrating Volume_StateEnum = 10
)

// Enum value maps for Volume_StateEnum.
var (
	Volume_StateEnum_name = map[int32]string{
		0:  "Unknown",
		1:  "Creating",
		2:  "Available",
		3:  "Deleting",
		4:  "Deleted",
		7:  "Failed",
		8:  "Updating",
		9:  "Rollback",
		10: "Migrating",
	}
	Volume_StateEnum_value = map[string]int32{
		"Unknown":   0,
		"Creating":  1,
		"Available": 2,
		"Deleting":  3,
		"Deleted":   4,
		"Failed":    7,
		"Updating":  8,
		"Rollback":  9,
		"Migrating": 10,
	}
)

func (x Volume_StateEnum) Enum() *Volume_StateEnum {
	p := new(Volume_StateEnum)
	*p = x
	return p
}

func (x Volume_StateEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Volume_StateEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[17].Descriptor()
}

func (Volume_StateEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[17]
}

func (x Volume_StateEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Volume_StateEnum.Descriptor instead.
func (Volume_StateEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{85, 0}
}

type Volume_ProtocolEnum int32

const (
	Volume_ProtocolTCP Volume_ProtocolEnum = 0
)

// Enum value maps for Volume_ProtocolEnum.
var (
	Volume_ProtocolEnum_name = map[int32]string{
		0: "ProtocolTCP",
	}
	Volume_ProtocolEnum_value = map[string]int32{
		"ProtocolTCP": 0,
	}
)

func (x Volume_ProtocolEnum) Enum() *Volume_ProtocolEnum {
	p := new(Volume_ProtocolEnum)
	*p = x
	return p
}

func (x Volume_ProtocolEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Volume_ProtocolEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[18].Descriptor()
}

func (Volume_ProtocolEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[18]
}

func (x Volume_ProtocolEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Volume_ProtocolEnum.Descriptor instead.
func (Volume_ProtocolEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{85, 1}
}

type ServerEvictionStatus_StatusEnum int32

const (
	ServerEvictionStatus_None      ServerEvictionStatus_StatusEnum = 0
	ServerEvictionStatus_Failed    ServerEvictionStatus_StatusEnum = 1
	ServerEvictionStatus_Evicting  ServerEvictionStatus_StatusEnum = 2
	ServerEvictionStatus_Aborting  ServerEvictionStatus_StatusEnum = 3
	ServerEvictionStatus_Completed ServerEvictionStatus_StatusEnum = 4
	ServerEvictionStatus_Aborted   ServerEvictionStatus_StatusEnum = 5
)

// Enum value maps for ServerEvictionStatus_StatusEnum.
var (
	ServerEvictionStatus_StatusEnum_name = map[int32]string{
		0: "None",
		1: "Failed",
		2: "Evicting",
		3: "Aborting",
		4: "Completed",
		5: "Aborted",
	}
	ServerEvictionStatus_StatusEnum_value = map[string]int32{
		"None":      0,
		"Failed":    1,
		"Evicting":  2,
		"Aborting":  3,
		"Completed": 4,
		"Aborted":   5,
	}
)

func (x ServerEvictionStatus_StatusEnum) Enum() *ServerEvictionStatus_StatusEnum {
	p := new(ServerEvictionStatus_StatusEnum)
	*p = x
	return p
}

func (x ServerEvictionStatus_StatusEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ServerEvictionStatus_StatusEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[19].Descriptor()
}

func (ServerEvictionStatus_StatusEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[19]
}

func (x ServerEvictionStatus_StatusEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ServerEvictionStatus_StatusEnum.Descriptor instead.
func (ServerEvictionStatus_StatusEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{86, 0}
}

type ServerLastUpgrade_UpgradeStatusEnum int32

const (
	ServerLastUpgrade_Unknown       ServerLastUpgrade_UpgradeStatusEnum = 0
	ServerLastUpgrade_None          ServerLastUpgrade_UpgradeStatusEnum = 1
	ServerLastUpgrade_UpgradeFailed ServerLastUpgrade_UpgradeStatusEnum = 2
	ServerLastUpgrade_Upgrading     ServerLastUpgrade_UpgradeStatusEnum = 3
	ServerLastUpgrade_Rebooting     ServerLastUpgrade_UpgradeStatusEnum = 4
	ServerLastUpgrade_Recovering    ServerLastUpgrade_UpgradeStatusEnum = 5
)

// Enum value maps for ServerLastUpgrade_UpgradeStatusEnum.
var (
	ServerLastUpgrade_UpgradeStatusEnum_name = map[int32]string{
		0: "Unknown",
		1: "None",
		2: "UpgradeFailed",
		3: "Upgrading",
		4: "Rebooting",
		5: "Recovering",
	}
	ServerLastUpgrade_UpgradeStatusEnum_value = map[string]int32{
		"Unknown":       0,
		"None":          1,
		"UpgradeFailed": 2,
		"Upgrading":     3,
		"Rebooting":     4,
		"Recovering":    5,
	}
)

func (x ServerLastUpgrade_UpgradeStatusEnum) Enum() *ServerLastUpgrade_UpgradeStatusEnum {
	p := new(ServerLastUpgrade_UpgradeStatusEnum)
	*p = x
	return p
}

func (x ServerLastUpgrade_UpgradeStatusEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ServerLastUpgrade_UpgradeStatusEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[20].Descriptor()
}

func (ServerLastUpgrade_UpgradeStatusEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[20]
}

func (x ServerLastUpgrade_UpgradeStatusEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ServerLastUpgrade_UpgradeStatusEnum.Descriptor instead.
func (ServerLastUpgrade_UpgradeStatusEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{87, 0}
}

type Server_UpgradeStatusEnum int32

const (
	Server_Unknown       Server_UpgradeStatusEnum = 0
	Server_None          Server_UpgradeStatusEnum = 1
	Server_UpgradeFailed Server_UpgradeStatusEnum = 2
	Server_Upgrading     Server_UpgradeStatusEnum = 3
	Server_Rebooting     Server_UpgradeStatusEnum = 4
	Server_Recovering    Server_UpgradeStatusEnum = 5
)

// Enum value maps for Server_UpgradeStatusEnum.
var (
	Server_UpgradeStatusEnum_name = map[int32]string{
		0: "Unknown",
		1: "None",
		2: "UpgradeFailed",
		3: "Upgrading",
		4: "Rebooting",
		5: "Recovering",
	}
	Server_UpgradeStatusEnum_value = map[string]int32{
		"Unknown":       0,
		"None":          1,
		"UpgradeFailed": 2,
		"Upgrading":     3,
		"Rebooting":     4,
		"Recovering":    5,
	}
)

func (x Server_UpgradeStatusEnum) Enum() *Server_UpgradeStatusEnum {
	p := new(Server_UpgradeStatusEnum)
	*p = x
	return p
}

func (x Server_UpgradeStatusEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Server_UpgradeStatusEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[21].Descriptor()
}

func (Server_UpgradeStatusEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[21]
}

func (x Server_UpgradeStatusEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Server_UpgradeStatusEnum.Descriptor instead.
func (Server_UpgradeStatusEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{88, 0}
}

type Server_RiskOfServiceLossEnum int32

const (
	Server_UnknownRiskOfServiceLoss  Server_RiskOfServiceLossEnum = 0
	Server_NoRiskOfServiceLoss       Server_RiskOfServiceLossEnum = 1
	Server_InRiskOfServiceLoss       Server_RiskOfServiceLossEnum = 2
	Server_SourceOfRiskOfServiceLoss Server_RiskOfServiceLossEnum = 3
)

// Enum value maps for Server_RiskOfServiceLossEnum.
var (
	Server_RiskOfServiceLossEnum_name = map[int32]string{
		0: "UnknownRiskOfServiceLoss",
		1: "NoRiskOfServiceLoss",
		2: "InRiskOfServiceLoss",
		3: "SourceOfRiskOfServiceLoss",
	}
	Server_RiskOfServiceLossEnum_value = map[string]int32{
		"UnknownRiskOfServiceLoss":  0,
		"NoRiskOfServiceLoss":       1,
		"InRiskOfServiceLoss":       2,
		"SourceOfRiskOfServiceLoss": 3,
	}
)

func (x Server_RiskOfServiceLossEnum) Enum() *Server_RiskOfServiceLossEnum {
	p := new(Server_RiskOfServiceLossEnum)
	*p = x
	return p
}

func (x Server_RiskOfServiceLossEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Server_RiskOfServiceLossEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[22].Descriptor()
}

func (Server_RiskOfServiceLossEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[22]
}

func (x Server_RiskOfServiceLossEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Server_RiskOfServiceLossEnum.Descriptor instead.
func (Server_RiskOfServiceLossEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{88, 1}
}

type Server_ServerStateEnum int32

const (
	Server_UnknownState Server_ServerStateEnum = 0
	Server_Creating     Server_ServerStateEnum = 1
	Server_Enabled      Server_ServerStateEnum = 2
	Server_Deleting     Server_ServerStateEnum = 3
	Server_Failed       Server_ServerStateEnum = 4
	Server_Disabled     Server_ServerStateEnum = 5
	Server_Enabling     Server_ServerStateEnum = 6
	Server_Disabling    Server_ServerStateEnum = 7
)

// Enum value maps for Server_ServerStateEnum.
var (
	Server_ServerStateEnum_name = map[int32]string{
		0: "UnknownState",
		1: "Creating",
		2: "Enabled",
		3: "Deleting",
		4: "Failed",
		5: "Disabled",
		6: "Enabling",
		7: "Disabling",
	}
	Server_ServerStateEnum_value = map[string]int32{
		"UnknownState": 0,
		"Creating":     1,
		"Enabled":      2,
		"Deleting":     3,
		"Failed":       4,
		"Disabled":     5,
		"Enabling":     6,
		"Disabling":    7,
	}
)

func (x Server_ServerStateEnum) Enum() *Server_ServerStateEnum {
	p := new(Server_ServerStateEnum)
	*p = x
	return p
}

func (x Server_ServerStateEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Server_ServerStateEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[23].Descriptor()
}

func (Server_ServerStateEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[23]
}

func (x Server_ServerStateEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Server_ServerStateEnum.Descriptor instead.
func (Server_ServerStateEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{88, 2}
}

type Snapshot_StateEnum int32

const (
	Snapshot_Unknown   Snapshot_StateEnum = 0
	Snapshot_Creating  Snapshot_StateEnum = 1
	Snapshot_Available Snapshot_StateEnum = 2
	Snapshot_Deleting  Snapshot_StateEnum = 3
	Snapshot_Deleted   Snapshot_StateEnum = 4
	Snapshot_Failed    Snapshot_StateEnum = 7
)

// Enum value maps for Snapshot_StateEnum.
var (
	Snapshot_StateEnum_name = map[int32]string{
		0: "Unknown",
		1: "Creating",
		2: "Available",
		3: "Deleting",
		4: "Deleted",
		7: "Failed",
	}
	Snapshot_StateEnum_value = map[string]int32{
		"Unknown":   0,
		"Creating":  1,
		"Available": 2,
		"Deleting":  3,
		"Deleted":   4,
		"Failed":    7,
	}
)

func (x Snapshot_StateEnum) Enum() *Snapshot_StateEnum {
	p := new(Snapshot_StateEnum)
	*p = x
	return p
}

func (x Snapshot_StateEnum) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Snapshot_StateEnum) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[24].Descriptor()
}

func (Snapshot_StateEnum) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[24]
}

func (x Snapshot_StateEnum) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Snapshot_StateEnum.Descriptor instead.
func (Snapshot_StateEnum) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{94, 0}
}

type ResourcePolicy_State int32

const (
	ResourcePolicy_UnknownState ResourcePolicy_State = 0
	ResourcePolicy_Creating     ResourcePolicy_State = 1
	ResourcePolicy_Active       ResourcePolicy_State = 2
	ResourcePolicy_Deleting     ResourcePolicy_State = 3
	ResourcePolicy_Failed       ResourcePolicy_State = 4
)

// Enum value maps for ResourcePolicy_State.
var (
	ResourcePolicy_State_name = map[int32]string{
		0: "UnknownState",
		1: "Creating",
		2: "Active",
		3: "Deleting",
		4: "Failed",
	}
	ResourcePolicy_State_value = map[string]int32{
		"UnknownState": 0,
		"Creating":     1,
		"Active":       2,
		"Deleting":     3,
		"Failed":       4,
	}
)

func (x ResourcePolicy_State) Enum() *ResourcePolicy_State {
	p := new(ResourcePolicy_State)
	*p = x
	return p
}

func (x ResourcePolicy_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ResourcePolicy_State) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[25].Descriptor()
}

func (ResourcePolicy_State) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[25]
}

func (x ResourcePolicy_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ResourcePolicy_State.Descriptor instead.
func (ResourcePolicy_State) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{112, 0}
}

type Policy_State int32

const (
	Policy_Unknown    Policy_State = 0
	Policy_Creating   Policy_State = 1
	Policy_Active     Policy_State = 2
	Policy_Updating   Policy_State = 3
	Policy_Deprecated Policy_State = 4
	Policy_Failed     Policy_State = 5
)

// Enum value maps for Policy_State.
var (
	Policy_State_name = map[int32]string{
		0: "Unknown",
		1: "Creating",
		2: "Active",
		3: "Updating",
		4: "Deprecated",
		5: "Failed",
	}
	Policy_State_value = map[string]int32{
		"Unknown":    0,
		"Creating":   1,
		"Active":     2,
		"Updating":   3,
		"Deprecated": 4,
		"Failed":     5,
	}
)

func (x Policy_State) Enum() *Policy_State {
	p := new(Policy_State)
	*p = x
	return p
}

func (x Policy_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Policy_State) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[26].Descriptor()
}

func (Policy_State) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[26]
}

func (x Policy_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Policy_State.Descriptor instead.
func (Policy_State) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{113, 0}
}

type LabelValueKeyPair_Key int32

const (
	LabelValueKeyPair_Unknown   LabelValueKeyPair_Key = 0
	LabelValueKeyPair_FD        LabelValueKeyPair_Key = 1
	LabelValueKeyPair_PrimaryFD LabelValueKeyPair_Key = 2
	LabelValueKeyPair_ClusterID LabelValueKeyPair_Key = 3
)

// Enum value maps for LabelValueKeyPair_Key.
var (
	LabelValueKeyPair_Key_name = map[int32]string{
		0: "Unknown",
		1: "FD",
		2: "PrimaryFD",
		3: "ClusterID",
	}
	LabelValueKeyPair_Key_value = map[string]int32{
		"Unknown":   0,
		"FD":        1,
		"PrimaryFD": 2,
		"ClusterID": 3,
	}
)

func (x LabelValueKeyPair_Key) Enum() *LabelValueKeyPair_Key {
	p := new(LabelValueKeyPair_Key)
	*p = x
	return p
}

func (x LabelValueKeyPair_Key) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LabelValueKeyPair_Key) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[27].Descriptor()
}

func (LabelValueKeyPair_Key) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[27]
}

func (x LabelValueKeyPair_Key) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LabelValueKeyPair_Key.Descriptor instead.
func (LabelValueKeyPair_Key) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{134, 0}
}

type LabelMatchExpression_Operator int32

const (
	LabelMatchExpression_Unknown LabelMatchExpression_Operator = 0
	LabelMatchExpression_In      LabelMatchExpression_Operator = 1
)

// Enum value maps for LabelMatchExpression_Operator.
var (
	LabelMatchExpression_Operator_name = map[int32]string{
		0: "Unknown",
		1: "In",
	}
	LabelMatchExpression_Operator_value = map[string]int32{
		"Unknown": 0,
		"In":      1,
	}
)

func (x LabelMatchExpression_Operator) Enum() *LabelMatchExpression_Operator {
	p := new(LabelMatchExpression_Operator)
	*p = x
	return p
}

func (x LabelMatchExpression_Operator) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (LabelMatchExpression_Operator) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[28].Descriptor()
}

func (LabelMatchExpression_Operator) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[28]
}

func (x LabelMatchExpression_Operator) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use LabelMatchExpression_Operator.Descriptor instead.
func (LabelMatchExpression_Operator) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{135, 0}
}

type Event_EventType int32

const (
	Event_UnknownType       Event_EventType = 0
	Event_Cluster           Event_EventType = 1
	Event_Node              Event_EventType = 2
	Event_Volume            Event_EventType = 3
	Event_NVMeSSD           Event_EventType = 4
	Event_Server            Event_EventType = 5
	Event_DataIntegrity     Event_EventType = 6
	Event_ClusterEncryption Event_EventType = 7
)

// Enum value maps for Event_EventType.
var (
	Event_EventType_name = map[int32]string{
		0: "UnknownType",
		1: "Cluster",
		2: "Node",
		3: "Volume",
		4: "NVMeSSD",
		5: "Server",
		6: "DataIntegrity",
		7: "ClusterEncryption",
	}
	Event_EventType_value = map[string]int32{
		"UnknownType":       0,
		"Cluster":           1,
		"Node":              2,
		"Volume":            3,
		"NVMeSSD":           4,
		"Server":            5,
		"DataIntegrity":     6,
		"ClusterEncryption": 7,
	}
)

func (x Event_EventType) Enum() *Event_EventType {
	p := new(Event_EventType)
	*p = x
	return p
}

func (x Event_EventType) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Event_EventType) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[29].Descriptor()
}

func (Event_EventType) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[29]
}

func (x Event_EventType) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Event_EventType.Descriptor instead.
func (Event_EventType) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{147, 0}
}

type Event_EventReportingService int32

const (
	Event_UnkownReportingService Event_EventReportingService = 0
	Event_CM                     Event_EventReportingService = 1
	Event_NM                     Event_EventReportingService = 2
	Event_API                    Event_EventReportingService = 3
	Event_UM                     Event_EventReportingService = 4
)

// Enum value maps for Event_EventReportingService.
var (
	Event_EventReportingService_name = map[int32]string{
		0: "UnkownReportingService",
		1: "CM",
		2: "NM",
		3: "API",
		4: "UM",
	}
	Event_EventReportingService_value = map[string]int32{
		"UnkownReportingService": 0,
		"CM":                     1,
		"NM":                     2,
		"API":                    3,
		"UM":                     4,
	}
)

func (x Event_EventReportingService) Enum() *Event_EventReportingService {
	p := new(Event_EventReportingService)
	*p = x
	return p
}

func (x Event_EventReportingService) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Event_EventReportingService) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[30].Descriptor()
}

func (Event_EventReportingService) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[30]
}

func (x Event_EventReportingService) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Event_EventReportingService.Descriptor instead.
func (Event_EventReportingService) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{147, 1}
}

type Event_EventSeverity int32

const (
	Event_UnkownSeverity Event_EventSeverity = 0
	Event_Info           Event_EventSeverity = 1
	Event_Low            Event_EventSeverity = 2
	Event_Medium         Event_EventSeverity = 3
	Event_High           Event_EventSeverity = 4
	Event_Critical       Event_EventSeverity = 5
)

// Enum value maps for Event_EventSeverity.
var (
	Event_EventSeverity_name = map[int32]string{
		0: "UnkownSeverity",
		1: "Info",
		2: "Low",
		3: "Medium",
		4: "High",
		5: "Critical",
	}
	Event_EventSeverity_value = map[string]int32{
		"UnkownSeverity": 0,
		"Info":           1,
		"Low":            2,
		"Medium":         3,
		"High":           4,
		"Critical":       5,
	}
)

func (x Event_EventSeverity) Enum() *Event_EventSeverity {
	p := new(Event_EventSeverity)
	*p = x
	return p
}

func (x Event_EventSeverity) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (Event_EventSeverity) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[31].Descriptor()
}

func (Event_EventSeverity) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[31]
}

func (x Event_EventSeverity) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use Event_EventSeverity.Descriptor instead.
func (Event_EventSeverity) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{147, 2}
}

type ClusterEncryptionStatus_State int32

const (
	ClusterEncryptionStatus_Disabled ClusterEncryptionStatus_State = 0 // Encryption is disabled
	ClusterEncryptionStatus_Enabling ClusterEncryptionStatus_State = 1 // Enabling cluster encryption
	ClusterEncryptionStatus_Enabled  ClusterEncryptionStatus_State = 2 // Cluster encryption is enabled
	ClusterEncryptionStatus_Unknown  ClusterEncryptionStatus_State = 3 // Unknown state
)

// Enum value maps for ClusterEncryptionStatus_State.
var (
	ClusterEncryptionStatus_State_name = map[int32]string{
		0: "Disabled",
		1: "Enabling",
		2: "Enabled",
		3: "Unknown",
	}
	ClusterEncryptionStatus_State_value = map[string]int32{
		"Disabled": 0,
		"Enabling": 1,
		"Enabled":  2,
		"Unknown":  3,
	}
)

func (x ClusterEncryptionStatus_State) Enum() *ClusterEncryptionStatus_State {
	p := new(ClusterEncryptionStatus_State)
	*p = x
	return p
}

func (x ClusterEncryptionStatus_State) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterEncryptionStatus_State) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[32].Descriptor()
}

func (ClusterEncryptionStatus_State) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[32]
}

func (x ClusterEncryptionStatus_State) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterEncryptionStatus_State.Descriptor instead.
func (ClusterEncryptionStatus_State) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{152, 0}
}

type ClusterEncryptionStatus_RotationState int32

const (
	ClusterEncryptionStatus_NoRotation      ClusterEncryptionStatus_RotationState = 0 // No rotation is in progress
	ClusterEncryptionStatus_DistributingKEK ClusterEncryptionStatus_RotationState = 1 // Distributing KEK to all nodes
	ClusterEncryptionStatus_EncryptingDEKs  ClusterEncryptionStatus_RotationState = 2 // Encrypting all DEKs with the new KEK
	// Deprecated: Typo in 'EncryptyingDEKs'. Use 'EncryptingDEKs' instead.
	// TODO: Remove the deprecated 'EncryptyingDEKs' field in version 3.20+.
	// (The correct field 'EncryptingDEKs' was added in 3.18; removal is scheduled 2 versions later.)
	ClusterEncryptionStatus_EncryptyingDEKs ClusterEncryptionStatus_RotationState = 2
)

// Enum value maps for ClusterEncryptionStatus_RotationState.
var (
	ClusterEncryptionStatus_RotationState_name = map[int32]string{
		0: "NoRotation",
		1: "DistributingKEK",
		2: "EncryptingDEKs",
		// Duplicate value: 2: "EncryptyingDEKs",
	}
	ClusterEncryptionStatus_RotationState_value = map[string]int32{
		"NoRotation":      0,
		"DistributingKEK": 1,
		"EncryptingDEKs":  2,
		"EncryptyingDEKs": 2,
	}
)

func (x ClusterEncryptionStatus_RotationState) Enum() *ClusterEncryptionStatus_RotationState {
	p := new(ClusterEncryptionStatus_RotationState)
	*p = x
	return p
}

func (x ClusterEncryptionStatus_RotationState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (ClusterEncryptionStatus_RotationState) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[33].Descriptor()
}

func (ClusterEncryptionStatus_RotationState) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[33]
}

func (x ClusterEncryptionStatus_RotationState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use ClusterEncryptionStatus_RotationState.Descriptor instead.
func (ClusterEncryptionStatus_RotationState) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{152, 1}
}

type IDPConfiguration_IDPConfigurationState int32

const (
	// 0
	//
	// For internal use only.
	IDPConfiguration_Unknown IDPConfiguration_IDPConfigurationState = 0
	// 1
	//
	// The IdP configuration is being created.
	IDPConfiguration_Creating IDPConfiguration_IDPConfigurationState = 1
	// 2
	//
	// The IdP configuration is active.
	IDPConfiguration_Active IDPConfiguration_IDPConfigurationState = 2
	// 3
	//
	// The IdP configuration is being updated.
	IDPConfiguration_Updating IDPConfiguration_IDPConfigurationState = 3
	// 4
	//
	// Failed to create a new IdP configuration.
	IDPConfiguration_Failed IDPConfiguration_IDPConfigurationState = 4
)

// Enum value maps for IDPConfiguration_IDPConfigurationState.
var (
	IDPConfiguration_IDPConfigurationState_name = map[int32]string{
		0: "Unknown",
		1: "Creating",
		2: "Active",
		3: "Updating",
		4: "Failed",
	}
	IDPConfiguration_IDPConfigurationState_value = map[string]int32{
		"Unknown":  0,
		"Creating": 1,
		"Active":   2,
		"Updating": 3,
		"Failed":   4,
	}
)

func (x IDPConfiguration_IDPConfigurationState) Enum() *IDPConfiguration_IDPConfigurationState {
	p := new(IDPConfiguration_IDPConfigurationState)
	*p = x
	return p
}

func (x IDPConfiguration_IDPConfigurationState) String() string {
	return protoimpl.X.EnumStringOf(x.Descriptor(), protoreflect.EnumNumber(x))
}

func (IDPConfiguration_IDPConfigurationState) Descriptor() protoreflect.EnumDescriptor {
	return file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[34].Descriptor()
}

func (IDPConfiguration_IDPConfigurationState) Type() protoreflect.EnumType {
	return &file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes[34]
}

func (x IDPConfiguration_IDPConfigurationState) Number() protoreflect.EnumNumber {
	return protoreflect.EnumNumber(x)
}

// Deprecated: Use IDPConfiguration_IDPConfigurationState.Descriptor instead.
func (IDPConfiguration_IDPConfigurationState) EnumDescriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{159, 0}
}

type LogRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SkipStatistics
	//
	// The fetch log operation will download by default all of the statistics from the relevant server
	// By passing this parameter fetch logs will skip the statistics collection.
	SkipStatistics bool `protobuf:"varint,1,opt,name=SkipStatistics,proto3" json:"SkipStatistics,omitempty"`
	// CaptureCpuAndTcpDump
	//
	// Capture CPU and tcpdump stats for five seconds to tcpdump.cap + sar.log in network/<interfaces>
	CaptureCpuAndTcpDump bool `protobuf:"varint,2,opt,name=CaptureCpuAndTcpDump,proto3" json:"CaptureCpuAndTcpDump,omitempty"`
	// NumOfDaysToCollectLogs
	//
	// Number of days back to collect the logs (the default is two days).
	NumOfDaysToCollectLogs uint32 `protobuf:"varint,3,opt,name=NumOfDaysToCollectLogs,proto3" json:"NumOfDaysToCollectLogs,omitempty"`
	// CollectServicesLbcliEtcd
	//
	// Collect services information - lbcli and etcd dump only (the default will also collect all relevant logs).
	CollectServicesLbcliEtcd bool `protobuf:"varint,4,opt,name=CollectServicesLbcliEtcd,proto3" json:"CollectServicesLbcliEtcd,omitempty"`
	// IntervalBetweenBEReadCycles
	//
	// The interval in seconds between FE/BE statistics captures (the default is five seconds).
	IntervalBetweenBEReadCycles uint32 `protobuf:"varint,5,opt,name=IntervalBetweenBEReadCycles,proto3" json:"IntervalBetweenBEReadCycles,omitempty"`
	// DontCollectlogs
	//
	// Do not collect /var/log.
	DontCollectlogs bool `protobuf:"varint,6,opt,name=DontCollectlogs,proto3" json:"DontCollectlogs,omitempty"`
	// LogFilename
	//
	// Log filename prefix for convenience (do not use spaces).
	LogFilename string `protobuf:"bytes,7,opt,name=LogFilename,proto3" json:"LogFilename,omitempty"`
	// NumOfstatisticsToCapture
	//
	// The number of FE/BE statistics cycles to capture (the default is one).
	NumOfstatisticsToCapture uint32 `protobuf:"varint,8,opt,name=NumOfstatisticsToCapture,proto3" json:"NumOfstatisticsToCapture,omitempty"`
	// DontCompressOutput
	//
	// Do not compress the output tar file. The default is gzip, but xz can be selected with the -x flag.
	DontCompressOutput bool `protobuf:"varint,9,opt,name=DontCompressOutput,proto3" json:"DontCompressOutput,omitempty"`
	// IoNice
	//
	// Set the nicest IO/CPU priority on most commands via 'ionice -c 2 -n 7 nice -n 19'. Default: 'ionice -c 2 -n 7'
	IoNice bool `protobuf:"varint,10,opt,name=IoNice,proto3" json:"IoNice,omitempty"`
	// UseHighCompression
	//
	// If compressing, use stronger xz compression instead of gzip. The file extension will be txz instead of tgz
	UseHighCompression bool `protobuf:"varint,11,opt,name=UseHighCompression,proto3" json:"UseHighCompression,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LogRequest) Reset() {
	*x = LogRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[0]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LogRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LogRequest) ProtoMessage() {}

func (x *LogRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[0]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LogRequest.ProtoReflect.Descriptor instead.
func (*LogRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{0}
}

func (x *LogRequest) GetSkipStatistics() bool {
	if x != nil {
		return x.SkipStatistics
	}
	return false
}

func (x *LogRequest) GetCaptureCpuAndTcpDump() bool {
	if x != nil {
		return x.CaptureCpuAndTcpDump
	}
	return false
}

func (x *LogRequest) GetNumOfDaysToCollectLogs() uint32 {
	if x != nil {
		return x.NumOfDaysToCollectLogs
	}
	return 0
}

func (x *LogRequest) GetCollectServicesLbcliEtcd() bool {
	if x != nil {
		return x.CollectServicesLbcliEtcd
	}
	return false
}

func (x *LogRequest) GetIntervalBetweenBEReadCycles() uint32 {
	if x != nil {
		return x.IntervalBetweenBEReadCycles
	}
	return 0
}

func (x *LogRequest) GetDontCollectlogs() bool {
	if x != nil {
		return x.DontCollectlogs
	}
	return false
}

func (x *LogRequest) GetLogFilename() string {
	if x != nil {
		return x.LogFilename
	}
	return ""
}

func (x *LogRequest) GetNumOfstatisticsToCapture() uint32 {
	if x != nil {
		return x.NumOfstatisticsToCapture
	}
	return 0
}

func (x *LogRequest) GetDontCompressOutput() bool {
	if x != nil {
		return x.DontCompressOutput
	}
	return false
}

func (x *LogRequest) GetIoNice() bool {
	if x != nil {
		return x.IoNice
	}
	return false
}

func (x *LogRequest) GetUseHighCompression() bool {
	if x != nil {
		return x.UseHighCompression
	}
	return false
}

type AdminEndpoint struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// port
	//
	// Admin endpoint port.
	Port uint32   `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	Ips  []string `protobuf:"bytes,2,rep,name=ips,proto3" json:"ips,omitempty"`
	// Etag
	//
	// identifier for a specific version of a resource
	ETag          string `protobuf:"bytes,3,opt,name=ETag,proto3" json:"ETag,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AdminEndpoint) Reset() {
	*x = AdminEndpoint{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[1]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AdminEndpoint) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AdminEndpoint) ProtoMessage() {}

func (x *AdminEndpoint) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[1]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AdminEndpoint.ProtoReflect.Descriptor instead.
func (*AdminEndpoint) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{1}
}

func (x *AdminEndpoint) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *AdminEndpoint) GetIps() []string {
	if x != nil {
		return x.Ips
	}
	return nil
}

func (x *AdminEndpoint) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

type GetAdminEndpointRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// port
	//
	// Admin endpoint port.
	Port          uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAdminEndpointRequest) Reset() {
	*x = GetAdminEndpointRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[2]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAdminEndpointRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAdminEndpointRequest) ProtoMessage() {}

func (x *GetAdminEndpointRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[2]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAdminEndpointRequest.ProtoReflect.Descriptor instead.
func (*GetAdminEndpointRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{2}
}

func (x *GetAdminEndpointRequest) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

type ListAdminEndpointsResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	AdminEndpoints []*AdminEndpoint       `protobuf:"bytes,1,rep,name=adminEndpoints,proto3" json:"adminEndpoints,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ListAdminEndpointsResponse) Reset() {
	*x = ListAdminEndpointsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[3]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAdminEndpointsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAdminEndpointsResponse) ProtoMessage() {}

func (x *ListAdminEndpointsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[3]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAdminEndpointsResponse.ProtoReflect.Descriptor instead.
func (*ListAdminEndpointsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{3}
}

func (x *ListAdminEndpointsResponse) GetAdminEndpoints() []*AdminEndpoint {
	if x != nil {
		return x.AdminEndpoints
	}
	return nil
}

type ListAdminEndpointsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// port
	//
	// Optionally filter by port.
	Port          uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAdminEndpointsRequest) Reset() {
	*x = ListAdminEndpointsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[4]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAdminEndpointsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAdminEndpointsRequest) ProtoMessage() {}

func (x *ListAdminEndpointsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[4]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAdminEndpointsRequest.ProtoReflect.Descriptor instead.
func (*ListAdminEndpointsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{4}
}

func (x *ListAdminEndpointsRequest) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

type CreateAdminEndpointRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// port
	//
	// Admin endpoint port.
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// ips
	// Admin endpoint IP addresses.
	Ips           []string `protobuf:"bytes,2,rep,name=ips,proto3" json:"ips,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateAdminEndpointRequest) Reset() {
	*x = CreateAdminEndpointRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[5]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateAdminEndpointRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateAdminEndpointRequest) ProtoMessage() {}

func (x *CreateAdminEndpointRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[5]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateAdminEndpointRequest.ProtoReflect.Descriptor instead.
func (*CreateAdminEndpointRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{5}
}

func (x *CreateAdminEndpointRequest) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *CreateAdminEndpointRequest) GetIps() []string {
	if x != nil {
		return x.Ips
	}
	return nil
}

type UpdateAdminEndpointRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// port
	//
	// Admin endpoint port.
	Port uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	// ips
	// Admin endpoint IP addresses.
	Ips           []string `protobuf:"bytes,2,rep,name=ips,proto3" json:"ips,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateAdminEndpointRequest) Reset() {
	*x = UpdateAdminEndpointRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[6]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateAdminEndpointRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateAdminEndpointRequest) ProtoMessage() {}

func (x *UpdateAdminEndpointRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[6]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateAdminEndpointRequest.ProtoReflect.Descriptor instead.
func (*UpdateAdminEndpointRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{6}
}

func (x *UpdateAdminEndpointRequest) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

func (x *UpdateAdminEndpointRequest) GetIps() []string {
	if x != nil {
		return x.Ips
	}
	return nil
}

type DeleteAdminEndpointRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// port
	//
	// Delete endpoint corresponding to a specified port.
	Port          uint32 `protobuf:"varint,1,opt,name=port,proto3" json:"port,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAdminEndpointRequest) Reset() {
	*x = DeleteAdminEndpointRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[7]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAdminEndpointRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAdminEndpointRequest) ProtoMessage() {}

func (x *DeleteAdminEndpointRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[7]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAdminEndpointRequest.ProtoReflect.Descriptor instead.
func (*DeleteAdminEndpointRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{7}
}

func (x *DeleteAdminEndpointRequest) GetPort() uint32 {
	if x != nil {
		return x.Port
	}
	return 0
}

type DeleteAdminEndpointResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAdminEndpointResponse) Reset() {
	*x = DeleteAdminEndpointResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[8]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAdminEndpointResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAdminEndpointResponse) ProtoMessage() {}

func (x *DeleteAdminEndpointResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[8]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAdminEndpointResponse.ProtoReflect.Descriptor instead.
func (*DeleteAdminEndpointResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{8}
}

type CreateCredentialRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// projectName
	//
	// Project name.
	ProjectName string `protobuf:"bytes,1,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// ID
	//
	// Credential ID.
	ID string `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	// type
	//
	// Type of the credentials, one of: pki rsa256pubkey cert-chain.
	Type CredsType `protobuf:"varint,3,opt,name=type,proto3,enum=lightbits.api.duros.v2.CredsType" json:"type,omitempty"`
	// payload
	//
	// Payload of the credentials.
	Payload       []byte `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateCredentialRequest) Reset() {
	*x = CreateCredentialRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[9]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateCredentialRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateCredentialRequest) ProtoMessage() {}

func (x *CreateCredentialRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[9]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateCredentialRequest.ProtoReflect.Descriptor instead.
func (*CreateCredentialRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{9}
}

func (x *CreateCredentialRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *CreateCredentialRequest) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *CreateCredentialRequest) GetType() CredsType {
	if x != nil {
		return x.Type
	}
	return CredsType_UnknownType
}

func (x *CreateCredentialRequest) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

type Credential struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	ProjectName string                 `protobuf:"bytes,1,opt,name=projectName,proto3" json:"projectName,omitempty"`
	ID          string                 `protobuf:"bytes,2,opt,name=ID,proto3" json:"ID,omitempty"`
	Type        CredsType              `protobuf:"varint,3,opt,name=type,proto3,enum=lightbits.api.duros.v2.CredsType" json:"type,omitempty"`
	Payload     []byte                 `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
	// kind
	//
	// CredsKind specifies the origin and intended usage of the credentials.
	Kind          CredsKind `protobuf:"varint,5,opt,name=kind,proto3,enum=lightbits.api.duros.v2.CredsKind" json:"kind,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Credential) Reset() {
	*x = Credential{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[10]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Credential) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Credential) ProtoMessage() {}

func (x *Credential) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[10]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Credential.ProtoReflect.Descriptor instead.
func (*Credential) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{10}
}

func (x *Credential) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *Credential) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *Credential) GetType() CredsType {
	if x != nil {
		return x.Type
	}
	return CredsType_UnknownType
}

func (x *Credential) GetPayload() []byte {
	if x != nil {
		return x.Payload
	}
	return nil
}

func (x *Credential) GetKind() CredsKind {
	if x != nil {
		return x.Kind
	}
	return CredsKind_UserCreds
}

type DeleteCredentialRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID
	//
	// Credential ID.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// projectName
	//
	// Project name.
	ProjectName   string `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteCredentialRequest) Reset() {
	*x = DeleteCredentialRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[11]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteCredentialRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteCredentialRequest) ProtoMessage() {}

func (x *DeleteCredentialRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[11]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteCredentialRequest.ProtoReflect.Descriptor instead.
func (*DeleteCredentialRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{11}
}

func (x *DeleteCredentialRequest) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *DeleteCredentialRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type DeleteCredentialResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteCredentialResponse) Reset() {
	*x = DeleteCredentialResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[12]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteCredentialResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteCredentialResponse) ProtoMessage() {}

func (x *DeleteCredentialResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[12]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteCredentialResponse.ProtoReflect.Descriptor instead.
func (*DeleteCredentialResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{12}
}

type ListCredentialsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// projectName
	//
	// Project name associated with credentials.
	ProjectName   string `protobuf:"bytes,1,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCredentialsRequest) Reset() {
	*x = ListCredentialsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[13]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCredentialsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCredentialsRequest) ProtoMessage() {}

func (x *ListCredentialsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[13]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCredentialsRequest.ProtoReflect.Descriptor instead.
func (*ListCredentialsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{13}
}

func (x *ListCredentialsRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type ListCredentialsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Credentials   []*Credential          `protobuf:"bytes,1,rep,name=credentials,proto3" json:"credentials,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListCredentialsResponse) Reset() {
	*x = ListCredentialsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[14]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListCredentialsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListCredentialsResponse) ProtoMessage() {}

func (x *ListCredentialsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[14]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListCredentialsResponse.ProtoReflect.Descriptor instead.
func (*ListCredentialsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{14}
}

func (x *ListCredentialsResponse) GetCredentials() []*Credential {
	if x != nil {
		return x.Credentials
	}
	return nil
}

type GetCredentialRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ID
	//
	// Credential ID.
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// projectName
	//
	// Project name.
	ProjectName   string `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetCredentialRequest) Reset() {
	*x = GetCredentialRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[15]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetCredentialRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetCredentialRequest) ProtoMessage() {}

func (x *GetCredentialRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[15]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetCredentialRequest.ProtoReflect.Descriptor instead.
func (*GetCredentialRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{15}
}

func (x *GetCredentialRequest) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *GetCredentialRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type DefaultPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Policy Type
	//
	// Policy Type. Available types are 'QoS' or 'Snapshot'.
	PolicyType PolicyType `protobuf:"varint,1,opt,name=policyType,proto3,enum=lightbits.api.duros.v2.PolicyType" json:"policyType,omitempty"`
	// Policy UUID
	//
	// Policy UUID
	PolicyUUID    string `protobuf:"bytes,2,opt,name=policyUUID,proto3" json:"policyUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DefaultPolicy) Reset() {
	*x = DefaultPolicy{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[16]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DefaultPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefaultPolicy) ProtoMessage() {}

func (x *DefaultPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[16]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefaultPolicy.ProtoReflect.Descriptor instead.
func (*DefaultPolicy) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{16}
}

func (x *DefaultPolicy) GetPolicyType() PolicyType {
	if x != nil {
		return x.PolicyType
	}
	return PolicyType_unknown
}

func (x *DefaultPolicy) GetPolicyUUID() string {
	if x != nil {
		return x.PolicyUUID
	}
	return ""
}

type CreateProjectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Project Name
	//
	// Project Name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Project description
	//
	// Brief (up to 256B) description of the project.
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// Default policies
	//
	// List of default polices. Such as default QoS policy.
	DefaultPolicies []*DefaultPolicy `protobuf:"bytes,3,rep,name=defaultPolicies,proto3" json:"defaultPolicies,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *CreateProjectRequest) Reset() {
	*x = CreateProjectRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[17]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateProjectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateProjectRequest) ProtoMessage() {}

func (x *CreateProjectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[17]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateProjectRequest.ProtoReflect.Descriptor instead.
func (*CreateProjectRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{17}
}

func (x *CreateProjectRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateProjectRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CreateProjectRequest) GetDefaultPolicies() []*DefaultPolicy {
	if x != nil {
		return x.DefaultPolicies
	}
	return nil
}

type Project struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Project UUID
	//
	// Project UUID.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Project Name
	//
	// Project Name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// Project description
	//
	// Brief description of project.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// Default policies
	//
	// List of default polices specified for this project.
	DefaultPolicies []*DefaultPolicy `protobuf:"bytes,4,rep,name=defaultPolicies,proto3" json:"defaultPolicies,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Project) Reset() {
	*x = Project{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[18]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Project) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Project) ProtoMessage() {}

func (x *Project) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[18]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Project.ProtoReflect.Descriptor instead.
func (*Project) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{18}
}

func (x *Project) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *Project) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Project) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Project) GetDefaultPolicies() []*DefaultPolicy {
	if x != nil {
		return x.DefaultPolicies
	}
	return nil
}

type DeleteProjectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// project name
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteProjectRequest) Reset() {
	*x = DeleteProjectRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[19]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteProjectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteProjectRequest) ProtoMessage() {}

func (x *DeleteProjectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[19]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteProjectRequest.ProtoReflect.Descriptor instead.
func (*DeleteProjectRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{19}
}

func (x *DeleteProjectRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DeleteProjectResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteProjectResponse) Reset() {
	*x = DeleteProjectResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[20]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteProjectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteProjectResponse) ProtoMessage() {}

func (x *DeleteProjectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[20]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteProjectResponse.ProtoReflect.Descriptor instead.
func (*DeleteProjectResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{20}
}

type ListProjectsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProjectsRequest) Reset() {
	*x = ListProjectsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[21]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProjectsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProjectsRequest) ProtoMessage() {}

func (x *ListProjectsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[21]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProjectsRequest.ProtoReflect.Descriptor instead.
func (*ListProjectsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{21}
}

type ListProjectsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Projects      []*Project             `protobuf:"bytes,1,rep,name=projects,proto3" json:"projects,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListProjectsResponse) Reset() {
	*x = ListProjectsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[22]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListProjectsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListProjectsResponse) ProtoMessage() {}

func (x *ListProjectsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[22]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListProjectsResponse.ProtoReflect.Descriptor instead.
func (*ListProjectsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{22}
}

func (x *ListProjectsResponse) GetProjects() []*Project {
	if x != nil {
		return x.Projects
	}
	return nil
}

type GetProjectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// project name.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetProjectRequest) Reset() {
	*x = GetProjectRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[23]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetProjectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetProjectRequest) ProtoMessage() {}

func (x *GetProjectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[23]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetProjectRequest.ProtoReflect.Descriptor instead.
func (*GetProjectRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{23}
}

func (x *GetProjectRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type StringList struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []string               `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StringList) Reset() {
	*x = StringList{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[24]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StringList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StringList) ProtoMessage() {}

func (x *StringList) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[24]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StringList.ProtoReflect.Descriptor instead.
func (*StringList) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{24}
}

func (x *StringList) GetValues() []string {
	if x != nil {
		return x.Values
	}
	return nil
}

type GetVersionRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetVersionRequest) Reset() {
	*x = GetVersionRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[25]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetVersionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetVersionRequest) ProtoMessage() {}

func (x *GetVersionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[25]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetVersionRequest.ProtoReflect.Descriptor instead.
func (*GetVersionRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{25}
}

type CreateVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// A volume's name is unique at the project level. Name length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.).
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// size
	//
	// Volume size.
	Size string `protobuf:"bytes,2,opt,name=size,proto3" json:"size,omitempty"`
	// acl
	//
	// Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE.
	Acl *StringList `protobuf:"bytes,3,opt,name=acl,proto3" json:"acl,omitempty"`
	// compression
	//
	// Volume compression. Valid values: true/enable/enabled/false/disable/disabled (default value is disable compression).
	Compression string `protobuf:"bytes,4,opt,name=compression,proto3" json:"compression,omitempty"`
	// replicaCount
	//
	// The number of replicas a volume can have. Valid values are 1, 2, and 3.
	ReplicaCount uint32 `protobuf:"varint,5,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	// IPAcl
	//
	// Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE (optional, default: ALLOW_ANY).
	IPAcl *StringList `protobuf:"bytes,6,opt,name=IPAcl,proto3" json:"IPAcl,omitempty"`
	// minReplicas
	//
	// not used.
	MinReplicas uint32 `protobuf:"varint,7,opt,name=minReplicas,proto3" json:"minReplicas,omitempty"`
	// sectorSize
	//
	// Volume sector size. Valid values: 4K (default), 512B.
	SectorSize CreateVolumeRequest_SectorSizeEnum `protobuf:"varint,8,opt,name=sectorSize,proto3,enum=lightbits.api.duros.v2.CreateVolumeRequest_SectorSizeEnum" json:"sectorSize,omitempty"`
	// projectName
	//
	// Name of the project the volume belongs to.
	ProjectName string `protobuf:"bytes,9,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// sourceSnapshotUUID
	//
	// Optionally specify a source snapshot to create a clone from (specify either sourceSnapshotUUID or sourceSnapshotName).
	SourceSnapshotUUID string `protobuf:"bytes,10,opt,name=sourceSnapshotUUID,proto3" json:"sourceSnapshotUUID,omitempty"`
	// sourceSnapshotName
	//
	// Optionally specify a source snapshot to create a clone from (specify either sourceSnapshotUUID or sourceSnapshotName).
	SourceSnapshotName string `protobuf:"bytes,11,opt,name=sourceSnapshotName,proto3" json:"sourceSnapshotName,omitempty"`
	// PlacementRestrictions
	//
	// Specify volume affinity labels for placement restrictions
	// This may only be specified for volumes of single replication (replicaCount=1), and where Dynamic Rebalance is disabled (feature flags FailInPlace and ProactiveRebalance, lbcli get feature-flag are false).
	PlacementRestrictions []*LabelMatchExpression `protobuf:"bytes,12,rep,name=placementRestrictions,proto3" json:"placementRestrictions,omitempty"`
	// qosPolicyID
	//
	// Optionally specify QoS policy to be used by volume (either name or UUID).
	//
	// Types that are valid to be assigned to QosPolicyID:
	//
	//	*CreateVolumeRequest_QosPolicyUUID
	//	*CreateVolumeRequest_QosPolicyName
	QosPolicyID isCreateVolumeRequest_QosPolicyID `protobuf_oneof:"qosPolicyID"`
	// labels
	//
	// User-defined labels are optional for a volume. Labels are key-value pairs. A volume can have up to 16 labels. label-key and label-value length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9), hyphen (-), underscore (_), and period (.). When creating a clone, if labels are passed, the clone will be created with them. Otherwise, the labels are copied from the snapshot used for the clone.
	Labels        []*Label `protobuf:"bytes,15,rep,name=labels,proto3" json:"labels,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateVolumeRequest) Reset() {
	*x = CreateVolumeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[26]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateVolumeRequest) ProtoMessage() {}

func (x *CreateVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[26]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateVolumeRequest.ProtoReflect.Descriptor instead.
func (*CreateVolumeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{26}
}

func (x *CreateVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateVolumeRequest) GetSize() string {
	if x != nil {
		return x.Size
	}
	return ""
}

func (x *CreateVolumeRequest) GetAcl() *StringList {
	if x != nil {
		return x.Acl
	}
	return nil
}

func (x *CreateVolumeRequest) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *CreateVolumeRequest) GetReplicaCount() uint32 {
	if x != nil {
		return x.ReplicaCount
	}
	return 0
}

func (x *CreateVolumeRequest) GetIPAcl() *StringList {
	if x != nil {
		return x.IPAcl
	}
	return nil
}

func (x *CreateVolumeRequest) GetMinReplicas() uint32 {
	if x != nil {
		return x.MinReplicas
	}
	return 0
}

func (x *CreateVolumeRequest) GetSectorSize() CreateVolumeRequest_SectorSizeEnum {
	if x != nil {
		return x.SectorSize
	}
	return CreateVolumeRequest_sectorSize_Default
}

func (x *CreateVolumeRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *CreateVolumeRequest) GetSourceSnapshotUUID() string {
	if x != nil {
		return x.SourceSnapshotUUID
	}
	return ""
}

func (x *CreateVolumeRequest) GetSourceSnapshotName() string {
	if x != nil {
		return x.SourceSnapshotName
	}
	return ""
}

func (x *CreateVolumeRequest) GetPlacementRestrictions() []*LabelMatchExpression {
	if x != nil {
		return x.PlacementRestrictions
	}
	return nil
}

func (x *CreateVolumeRequest) GetQosPolicyID() isCreateVolumeRequest_QosPolicyID {
	if x != nil {
		return x.QosPolicyID
	}
	return nil
}

func (x *CreateVolumeRequest) GetQosPolicyUUID() string {
	if x != nil {
		if x, ok := x.QosPolicyID.(*CreateVolumeRequest_QosPolicyUUID); ok {
			return x.QosPolicyUUID
		}
	}
	return ""
}

func (x *CreateVolumeRequest) GetQosPolicyName() string {
	if x != nil {
		if x, ok := x.QosPolicyID.(*CreateVolumeRequest_QosPolicyName); ok {
			return x.QosPolicyName
		}
	}
	return ""
}

func (x *CreateVolumeRequest) GetLabels() []*Label {
	if x != nil {
		return x.Labels
	}
	return nil
}

type isCreateVolumeRequest_QosPolicyID interface {
	isCreateVolumeRequest_QosPolicyID()
}

type CreateVolumeRequest_QosPolicyUUID struct {
	QosPolicyUUID string `protobuf:"bytes,13,opt,name=qosPolicyUUID,proto3,oneof"`
}

type CreateVolumeRequest_QosPolicyName struct {
	QosPolicyName string `protobuf:"bytes,14,opt,name=qosPolicyName,proto3,oneof"`
}

func (*CreateVolumeRequest_QosPolicyUUID) isCreateVolumeRequest_QosPolicyID() {}

func (*CreateVolumeRequest_QosPolicyName) isCreateVolumeRequest_QosPolicyID() {}

type DeleteVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The volume's UUID for the delete volume request (optional; either UUID or Name must be provided to identify the volume to delete).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// The volume's name for the delete volume request (optional; either UUID or Name must be provided to identify the volume to delete).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// projectName
	//
	// The project name of the volume to delete.
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteVolumeRequest) Reset() {
	*x = DeleteVolumeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[27]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteVolumeRequest) ProtoMessage() {}

func (x *DeleteVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[27]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteVolumeRequest.ProtoReflect.Descriptor instead.
func (*DeleteVolumeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{27}
}

func (x *DeleteVolumeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DeleteVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DeleteVolumeRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type DeleteVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteVolumeResponse) Reset() {
	*x = DeleteVolumeResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[28]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteVolumeResponse) ProtoMessage() {}

func (x *DeleteVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[28]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteVolumeResponse.ProtoReflect.Descriptor instead.
func (*DeleteVolumeResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{28}
}

type EnableServerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The server's UUID for the enable server request (either server UUID or name must be specified).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// The server's name for the enable server request (either server UUID or name must be specified).
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnableServerRequest) Reset() {
	*x = EnableServerRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[29]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnableServerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnableServerRequest) ProtoMessage() {}

func (x *EnableServerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[29]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnableServerRequest.ProtoReflect.Descriptor instead.
func (*EnableServerRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{29}
}

func (x *EnableServerRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *EnableServerRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DisableServerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The server's UUID for the disable server request (either server UUID or name must be specified).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// ForceDisable
	//
	// When set to True, the disable operation bypasses an upgradeability (loss of service) check when disabling
	// server. If the evict flag is also set to True, it will force eviction of all server data, even if it means losing single
	// replica volumes because they cannot be evicted to another server. Only set both "evict" and "ForceDisable"
	// to True if you are willing to lose your single-replica volumes.
	ForceDisable bool `protobuf:"varint,2,opt,name=ForceDisable,proto3" json:"ForceDisable,omitempty"`
	// name
	//
	// The server's name for the disable server request (either server UUID or name must be specified).
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// evictData
	//
	// Setting this to True will cause all server data to be evicted from the server.
	// Setting this to 'False' will disable the server while keeping all data on the server, so it will be there when you
	// re-enable it.
	// eviction may fail in some cases; e.g., in case of single replica volume that cant be
	// transferred to another server due to network issues between the servers, the eviction is expected to fail.
	// If you want the data eviction process, even at the risk of potentially losing some data that could not be evicted,
	// set both evictData and ForceDisable to True.
	EvictData bool `protobuf:"varint,4,opt,name=evictData,proto3" json:"evictData,omitempty"`
	// permanentFailureTimeout
	//
	// Setting a value for this parameter will override the permanent failure timeout at the cluster level.
	// This can be used  when a user wants to take a server into maintenance state and avoid data migration
	// during this time. Valid values are 1 hour or longer, "0"  value should be used to specify an infinite timeout.
	// Permanent failure timeout is a string constructed by a decimal number followed
	// by the units: ns, us, ms, s, m, h. For example: 7200s, 120m, 2h
	// This value will be override once the server is re-enabled. Default value: null
	PermanentFailureTimeout *durationpb.Duration `protobuf:"bytes,5,opt,name=permanentFailureTimeout,proto3" json:"permanentFailureTimeout,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *DisableServerRequest) Reset() {
	*x = DisableServerRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[30]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisableServerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisableServerRequest) ProtoMessage() {}

func (x *DisableServerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[30]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisableServerRequest.ProtoReflect.Descriptor instead.
func (*DisableServerRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{30}
}

func (x *DisableServerRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DisableServerRequest) GetForceDisable() bool {
	if x != nil {
		return x.ForceDisable
	}
	return false
}

func (x *DisableServerRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DisableServerRequest) GetEvictData() bool {
	if x != nil {
		return x.EvictData
	}
	return false
}

func (x *DisableServerRequest) GetPermanentFailureTimeout() *durationpb.Duration {
	if x != nil {
		return x.PermanentFailureTimeout
	}
	return nil
}

type DeleteServerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The server's UUID for the delete server request (either server UUID or Name must be specified).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// The server's name for the delete server request (either server UUID or Name must be specified).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// forceDelete
	//
	// Optional. Setting forceDelete will override some of the delete
	// server pre-checks.
	// When set to False (default), a server cannot be deleted if
	// there are any resources attached to the server (e.g., node replace
	// was issued, server nodes entered permanent failure states, and
	// resources were migrated.)
	// When set to True, the delete operation bypasses checks to verify
	// if the server still has any resources attached to it and starts the
	// delete operation in the background. The operation will not
	// complete and will remain in the background until the server
	// resources will have been detached from the server.
	// Note that a server with volumes/snapshots/clones with a single
	// replica cannot be deleted, even with forceDelete set to
	// True. You must remove the 1x replica volumes/snapshots/clones
	// before deleting the server.
	ForceDelete   bool `protobuf:"varint,3,opt,name=forceDelete,proto3" json:"forceDelete,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteServerRequest) Reset() {
	*x = DeleteServerRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[31]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteServerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteServerRequest) ProtoMessage() {}

func (x *DeleteServerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[31]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteServerRequest.ProtoReflect.Descriptor instead.
func (*DeleteServerRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{31}
}

func (x *DeleteServerRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DeleteServerRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DeleteServerRequest) GetForceDelete() bool {
	if x != nil {
		return x.ForceDelete
	}
	return false
}

type ReplaceNodeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// SrcNodeUUID
	//
	// The source node's UUID for the replace node request.
	SrcNodeUUID string `protobuf:"bytes,1,opt,name=SrcNodeUUID,proto3" json:"SrcNodeUUID,omitempty"`
	// TargetNodeUUID
	//
	// The target node's UUID for the replace node request.
	TargetNodeUUID string `protobuf:"bytes,2,opt,name=TargetNodeUUID,proto3" json:"TargetNodeUUID,omitempty"`
	// ReplaceWhileActive
	//
	// Optional. When true, the replace node operation will be performed while the server is active. Default is False.
	ReplaceWhileActive bool `protobuf:"varint,3,opt,name=ReplaceWhileActive,proto3" json:"ReplaceWhileActive,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *ReplaceNodeRequest) Reset() {
	*x = ReplaceNodeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[32]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplaceNodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceNodeRequest) ProtoMessage() {}

func (x *ReplaceNodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[32]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceNodeRequest.ProtoReflect.Descriptor instead.
func (*ReplaceNodeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{32}
}

func (x *ReplaceNodeRequest) GetSrcNodeUUID() string {
	if x != nil {
		return x.SrcNodeUUID
	}
	return ""
}

func (x *ReplaceNodeRequest) GetTargetNodeUUID() string {
	if x != nil {
		return x.TargetNodeUUID
	}
	return ""
}

func (x *ReplaceNodeRequest) GetReplaceWhileActive() bool {
	if x != nil {
		return x.ReplaceWhileActive
	}
	return false
}

type CreateServerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// serverEndpoints
	//
	// Etcd member endpoint. In the current version, only a single point is allowed.
	ServerEndpoints []string `protobuf:"bytes,1,rep,name=serverEndpoints,proto3" json:"serverEndpoints,omitempty"`
	// serverUUID
	//
	// The server's UUID for the create server request.
	ServerUUID string `protobuf:"bytes,2,opt,name=serverUUID,proto3" json:"serverUUID,omitempty"`
	// reuseIP
	//
	// Optional. When true, bypasses validation if a given endpoint is used by another server.
	ReuseIP bool `protobuf:"varint,3,opt,name=reuseIP,proto3" json:"reuseIP,omitempty"`
	// extendCluster
	//
	// Optional. When true, the cluster is extended with a new server and its resources, enabling new volumes placement on the server (the nodes of this server will come up as active). Default is False (the nodes of this server will be added to the cluster as unattached, and may be used to move over resources from an existing failed server using the replace node API command).
	ExtendCluster bool `protobuf:"varint,4,opt,name=extendCluster,proto3" json:"extendCluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateServerRequest) Reset() {
	*x = CreateServerRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[33]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateServerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateServerRequest) ProtoMessage() {}

func (x *CreateServerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[33]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateServerRequest.ProtoReflect.Descriptor instead.
func (*CreateServerRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{33}
}

func (x *CreateServerRequest) GetServerEndpoints() []string {
	if x != nil {
		return x.ServerEndpoints
	}
	return nil
}

func (x *CreateServerRequest) GetServerUUID() string {
	if x != nil {
		return x.ServerUUID
	}
	return ""
}

func (x *CreateServerRequest) GetReuseIP() bool {
	if x != nil {
		return x.ReuseIP
	}
	return false
}

func (x *CreateServerRequest) GetExtendCluster() bool {
	if x != nil {
		return x.ExtendCluster
	}
	return false
}

type UpdateVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Optional identifier of the volume to update (command must use either name or UUID fields to identify volume).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// acl
	//
	// Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
	Acl *StringList `protobuf:"bytes,2,opt,name=acl,proto3" json:"acl,omitempty"`
	// IPAcl
	//
	// Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE
	IPAcl *StringList `protobuf:"bytes,3,opt,name=IPAcl,proto3" json:"IPAcl,omitempty"`
	Size  string      `protobuf:"bytes,4,opt,name=size,proto3" json:"size,omitempty"`
	// compression
	//
	// valid values: true/enable/enabled or false/disable/disabled
	Compression string `protobuf:"bytes,5,opt,name=compression,proto3" json:"compression,omitempty"`
	// project name
	//
	// Name of the project the volume belongs to.
	ProjectName string `protobuf:"bytes,6,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// qosPolicyID
	//
	// QoS Policy, optionally specify QoS policy to be used by volume (either name or UUID).
	//
	// Types that are valid to be assigned to QosPolicyID:
	//
	//	*UpdateVolumeRequest_QosPolicyUUID
	//	*UpdateVolumeRequest_QosPolicyName
	QosPolicyID isUpdateVolumeRequest_QosPolicyID `protobuf_oneof:"qosPolicyID"`
	// Force
	//
	// To intentionally shrink volume size, provide updated volume size and set force to true.
	Force bool `protobuf:"varint,9,opt,name=Force,proto3" json:"Force,omitempty"`
	// name
	//
	// Optional identifier of the volume to update (command must use either name or UUID fields to identify volume).
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// labels
	//
	// User-defined labels are optional for a volume. Labels are key-value pairs. A volume can have up to 16 labels. label-key and label-value length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.). If labels are passed during volume update, the existing volume's labels are replaced with the new ones. Otherwise, the labels are untouched.
	Labels []*Label `protobuf:"bytes,11,rep,name=labels,proto3" json:"labels,omitempty"`
	// new name
	//
	// Volume new name. A volume's name is unique on the project level. Name length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.).
	NewName       string `protobuf:"bytes,12,opt,name=newName,proto3" json:"newName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateVolumeRequest) Reset() {
	*x = UpdateVolumeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[34]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateVolumeRequest) ProtoMessage() {}

func (x *UpdateVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[34]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateVolumeRequest.ProtoReflect.Descriptor instead.
func (*UpdateVolumeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{34}
}

func (x *UpdateVolumeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *UpdateVolumeRequest) GetAcl() *StringList {
	if x != nil {
		return x.Acl
	}
	return nil
}

func (x *UpdateVolumeRequest) GetIPAcl() *StringList {
	if x != nil {
		return x.IPAcl
	}
	return nil
}

func (x *UpdateVolumeRequest) GetSize() string {
	if x != nil {
		return x.Size
	}
	return ""
}

func (x *UpdateVolumeRequest) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *UpdateVolumeRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *UpdateVolumeRequest) GetQosPolicyID() isUpdateVolumeRequest_QosPolicyID {
	if x != nil {
		return x.QosPolicyID
	}
	return nil
}

func (x *UpdateVolumeRequest) GetQosPolicyUUID() string {
	if x != nil {
		if x, ok := x.QosPolicyID.(*UpdateVolumeRequest_QosPolicyUUID); ok {
			return x.QosPolicyUUID
		}
	}
	return ""
}

func (x *UpdateVolumeRequest) GetQosPolicyName() string {
	if x != nil {
		if x, ok := x.QosPolicyID.(*UpdateVolumeRequest_QosPolicyName); ok {
			return x.QosPolicyName
		}
	}
	return ""
}

func (x *UpdateVolumeRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

func (x *UpdateVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateVolumeRequest) GetLabels() []*Label {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *UpdateVolumeRequest) GetNewName() string {
	if x != nil {
		return x.NewName
	}
	return ""
}

type isUpdateVolumeRequest_QosPolicyID interface {
	isUpdateVolumeRequest_QosPolicyID()
}

type UpdateVolumeRequest_QosPolicyUUID struct {
	QosPolicyUUID string `protobuf:"bytes,7,opt,name=qosPolicyUUID,proto3,oneof"`
}

type UpdateVolumeRequest_QosPolicyName struct {
	QosPolicyName string `protobuf:"bytes,8,opt,name=qosPolicyName,proto3,oneof"`
}

func (*UpdateVolumeRequest_QosPolicyUUID) isUpdateVolumeRequest_QosPolicyID() {}

func (*UpdateVolumeRequest_QosPolicyName) isUpdateVolumeRequest_QosPolicyID() {}

type UpgradeServerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The server's UUID for the upgrade server request.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// InstallPkgUri
	//
	// URI of Lightbits package to install.
	InstallPkgUri string `protobuf:"bytes,2,opt,name=InstallPkgUri,proto3" json:"InstallPkgUri,omitempty"`
	// ForceUpgrade
	//
	// Optional. When true, bypasses the upgradability (loss of service) check.
	ForceUpgrade bool `protobuf:"varint,3,opt,name=ForceUpgrade,proto3" json:"ForceUpgrade,omitempty"`
	// ProxyInfo
	//
	// Optional. Proxy server information for upgrade behind proxy.
	ProxyInfo     *ProxyInfo `protobuf:"bytes,4,opt,name=ProxyInfo,proto3" json:"ProxyInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpgradeServerRequest) Reset() {
	*x = UpgradeServerRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[35]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpgradeServerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpgradeServerRequest) ProtoMessage() {}

func (x *UpgradeServerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[35]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpgradeServerRequest.ProtoReflect.Descriptor instead.
func (*UpgradeServerRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{35}
}

func (x *UpgradeServerRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *UpgradeServerRequest) GetInstallPkgUri() string {
	if x != nil {
		return x.InstallPkgUri
	}
	return ""
}

func (x *UpgradeServerRequest) GetForceUpgrade() bool {
	if x != nil {
		return x.ForceUpgrade
	}
	return false
}

func (x *UpgradeServerRequest) GetProxyInfo() *ProxyInfo {
	if x != nil {
		return x.ProxyInfo
	}
	return nil
}

type UpgradeClusterRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// InstallPkgUri
	//
	// URI of Lightbits package to install.
	InstallPkgUri string `protobuf:"bytes,1,opt,name=InstallPkgUri,proto3" json:"InstallPkgUri,omitempty"`
	// UUIDs
	//
	// Optional. Servers with given UUIDs are upgraded. If not given, all servers in the cluster are upgraded according to an upgradability (loss of service) check.
	UUIDs []string `protobuf:"bytes,2,rep,name=UUIDs,proto3" json:"UUIDs,omitempty"`
	// ProxyInfo
	//
	// Optional. Proxy server information for upgrade behind proxy.
	ProxyInfo     *ProxyInfo `protobuf:"bytes,3,opt,name=ProxyInfo,proto3" json:"ProxyInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpgradeClusterRequest) Reset() {
	*x = UpgradeClusterRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[36]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpgradeClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpgradeClusterRequest) ProtoMessage() {}

func (x *UpgradeClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[36]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpgradeClusterRequest.ProtoReflect.Descriptor instead.
func (*UpgradeClusterRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{36}
}

func (x *UpgradeClusterRequest) GetInstallPkgUri() string {
	if x != nil {
		return x.InstallPkgUri
	}
	return ""
}

func (x *UpgradeClusterRequest) GetUUIDs() []string {
	if x != nil {
		return x.UUIDs
	}
	return nil
}

func (x *UpgradeClusterRequest) GetProxyInfo() *ProxyInfo {
	if x != nil {
		return x.ProxyInfo
	}
	return nil
}

type EnableClusterEncryptionRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// KeyStore
	//
	// Optional. Where to store the Encryption KEK on file or in tpm.
	KeyStore      EnableClusterEncryptionRequest_KeyStore `protobuf:"varint,1,opt,name=keyStore,proto3,enum=lightbits.api.duros.v2.EnableClusterEncryptionRequest_KeyStore" json:"keyStore,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnableClusterEncryptionRequest) Reset() {
	*x = EnableClusterEncryptionRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[37]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnableClusterEncryptionRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnableClusterEncryptionRequest) ProtoMessage() {}

func (x *EnableClusterEncryptionRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[37]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnableClusterEncryptionRequest.ProtoReflect.Descriptor instead.
func (*EnableClusterEncryptionRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{37}
}

func (x *EnableClusterEncryptionRequest) GetKeyStore() EnableClusterEncryptionRequest_KeyStore {
	if x != nil {
		return x.KeyStore
	}
	return EnableClusterEncryptionRequest_file
}

type GetClusterRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterRequest) Reset() {
	*x = GetClusterRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[38]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterRequest) ProtoMessage() {}

func (x *GetClusterRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[38]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterRequest.ProtoReflect.Descriptor instead.
func (*GetClusterRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{38}
}

type UpdateNvmeDeviceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// serverUUID
	//
	// Server UUID of the NVMe device to update.
	ServerUUID string `protobuf:"bytes,1,opt,name=serverUUID,proto3" json:"serverUUID,omitempty"`
	// serialNumber
	//
	// NVMe device serial number.
	SerialNumber string `protobuf:"bytes,2,opt,name=serialNumber,proto3" json:"serialNumber,omitempty"`
	// ledPattern
	//
	// NVMe device LED pattern. specify either "locate", "rebuild" or "locate-off"
	LedPattern    string `protobuf:"bytes,3,opt,name=ledPattern,proto3" json:"ledPattern,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateNvmeDeviceRequest) Reset() {
	*x = UpdateNvmeDeviceRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[39]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateNvmeDeviceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateNvmeDeviceRequest) ProtoMessage() {}

func (x *UpdateNvmeDeviceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[39]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateNvmeDeviceRequest.ProtoReflect.Descriptor instead.
func (*UpdateNvmeDeviceRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{39}
}

func (x *UpdateNvmeDeviceRequest) GetServerUUID() string {
	if x != nil {
		return x.ServerUUID
	}
	return ""
}

func (x *UpdateNvmeDeviceRequest) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *UpdateNvmeDeviceRequest) GetLedPattern() string {
	if x != nil {
		return x.LedPattern
	}
	return ""
}

type AddNvmeDeviceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// serialNumber
	//
	// NVMe device serial number.
	SerialNumber string `protobuf:"bytes,1,opt,name=serialNumber,proto3" json:"serialNumber,omitempty"`
	// nodeUUID
	//
	// UUID of node to add the NVMe device to.
	NodeUUID      string `protobuf:"bytes,2,opt,name=nodeUUID,proto3" json:"nodeUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddNvmeDeviceRequest) Reset() {
	*x = AddNvmeDeviceRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[40]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddNvmeDeviceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddNvmeDeviceRequest) ProtoMessage() {}

func (x *AddNvmeDeviceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[40]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddNvmeDeviceRequest.ProtoReflect.Descriptor instead.
func (*AddNvmeDeviceRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{40}
}

func (x *AddNvmeDeviceRequest) GetSerialNumber() string {
	if x != nil {
		return x.SerialNumber
	}
	return ""
}

func (x *AddNvmeDeviceRequest) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

type GetHostRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// hostNQN
	//
	// Host NQN to get.
	HostNQN       string `protobuf:"bytes,1,opt,name=hostNQN,proto3" json:"hostNQN,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetHostRequest) Reset() {
	*x = GetHostRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[41]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetHostRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetHostRequest) ProtoMessage() {}

func (x *GetHostRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[41]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetHostRequest.ProtoReflect.Descriptor instead.
func (*GetHostRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{41}
}

func (x *GetHostRequest) GetHostNQN() string {
	if x != nil {
		return x.HostNQN
	}
	return ""
}

type ListHostsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// hostNQN
	//
	// Not supported (hostNQN filtering parameter is ignored and all connected hosts will be returned).
	HostNQN string `protobuf:"bytes,1,opt,name=hostNQN,proto3" json:"hostNQN,omitempty"`
	// hostNQN
	//
	// Optionally filter hosts associated with a specific volume (the default operation will return all hosts connected to the cluster).
	VolumeUUID    string `protobuf:"bytes,2,opt,name=volumeUUID,proto3" json:"volumeUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListHostsRequest) Reset() {
	*x = ListHostsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[42]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListHostsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListHostsRequest) ProtoMessage() {}

func (x *ListHostsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[42]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListHostsRequest.ProtoReflect.Descriptor instead.
func (*ListHostsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{42}
}

func (x *ListHostsRequest) GetHostNQN() string {
	if x != nil {
		return x.HostNQN
	}
	return ""
}

func (x *ListHostsRequest) GetVolumeUUID() string {
	if x != nil {
		return x.VolumeUUID
	}
	return ""
}

type ListHostsResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	ConnectedHosts []*ConnectedHost       `protobuf:"bytes,1,rep,name=connectedHosts,proto3" json:"connectedHosts,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ListHostsResponse) Reset() {
	*x = ListHostsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[43]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListHostsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListHostsResponse) ProtoMessage() {}

func (x *ListHostsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[43]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListHostsResponse.ProtoReflect.Descriptor instead.
func (*ListHostsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{43}
}

func (x *ListHostsResponse) GetConnectedHosts() []*ConnectedHost {
	if x != nil {
		return x.ConnectedHosts
	}
	return nil
}

type ListNodeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Name
	//
	// Filter nodes by node name (either no filter, or only name, UUID, or failureDomain should be specified).
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Name
	//
	// Filter nodes by node name (either no filter, or only name, UUID, or failureDomain should be specified).
	UUID string `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// failureDomain
	//
	// Filter nodes by a failure domain associated with nodes (either no filter, or only name, UUID, or failureDomain should be specified).
	FailureDomain string `protobuf:"bytes,3,opt,name=failureDomain,proto3" json:"failureDomain,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListNodeRequest) Reset() {
	*x = ListNodeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[44]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListNodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListNodeRequest) ProtoMessage() {}

func (x *ListNodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[44]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListNodeRequest.ProtoReflect.Descriptor instead.
func (*ListNodeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{44}
}

func (x *ListNodeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListNodeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ListNodeRequest) GetFailureDomain() string {
	if x != nil {
		return x.FailureDomain
	}
	return ""
}

type ListEventsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// projectName
	//
	// List only events that are associated with the specified project.
	ProjectName string `protobuf:"bytes,1,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// nextToken
	//
	// Optional. Specifies the first event to return when using consecutive paginated requests. Use the nextToken returned in the response of the previous request as the indication for the first event the new request should fetch. The value of nextToken is an event ID.
	NextToken string `protobuf:"bytes,2,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
	// since
	//
	// Optional. Return a list of events with a timestamp not earlier than the given timestamp. The timestamp format must be given in UTC time in ISO-8601, e.g.: 2000-01-01T12:00:00.000Z.
	Since string `protobuf:"bytes,3,opt,name=since,proto3" json:"since,omitempty"`
	// until
	//
	// Optional. Return a list of events with a timestamp not later than the given timestamp. The timestamp format must be given in UTC time in ISO-8601, e.g.: 2000-01-01T12:00:00.000Z.
	Until string `protobuf:"bytes,4,opt,name=until,proto3" json:"until,omitempty"`
	// limit
	//
	// Optional. Set a limit for the maximum number of events that can be returned in this response.
	Limit int64 `protobuf:"varint,6,opt,name=limit,proto3" json:"limit,omitempty"`
	// severity
	//
	// Optional. Return only events of the given severity.
	Severity []string `protobuf:"bytes,7,rep,name=severity,proto3" json:"severity,omitempty"`
	// component type
	//
	// Optional. Return only events of the given component type.
	ComponentType string `protobuf:"bytes,8,opt,name=componentType,proto3" json:"componentType,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListEventsRequest) Reset() {
	*x = ListEventsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[45]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListEventsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListEventsRequest) ProtoMessage() {}

func (x *ListEventsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[45]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListEventsRequest.ProtoReflect.Descriptor instead.
func (*ListEventsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{45}
}

func (x *ListEventsRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *ListEventsRequest) GetNextToken() string {
	if x != nil {
		return x.NextToken
	}
	return ""
}

func (x *ListEventsRequest) GetSince() string {
	if x != nil {
		return x.Since
	}
	return ""
}

func (x *ListEventsRequest) GetUntil() string {
	if x != nil {
		return x.Until
	}
	return ""
}

func (x *ListEventsRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListEventsRequest) GetSeverity() []string {
	if x != nil {
		return x.Severity
	}
	return nil
}

func (x *ListEventsRequest) GetComponentType() string {
	if x != nil {
		return x.ComponentType
	}
	return ""
}

type ListEventsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Events        []*Event               `protobuf:"bytes,1,rep,name=events,proto3" json:"events,omitempty"`
	NextToken     string                 `protobuf:"bytes,2,opt,name=nextToken,proto3" json:"nextToken,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListEventsResponse) Reset() {
	*x = ListEventsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[46]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListEventsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListEventsResponse) ProtoMessage() {}

func (x *ListEventsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[46]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListEventsResponse.ProtoReflect.Descriptor instead.
func (*ListEventsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{46}
}

func (x *ListEventsResponse) GetEvents() []*Event {
	if x != nil {
		return x.Events
	}
	return nil
}

func (x *ListEventsResponse) GetNextToken() string {
	if x != nil {
		return x.NextToken
	}
	return ""
}

type GetVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Optional. The volume's UUID. Either UUID or Name must be provided to identify the volume to get.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Name
	//
	// Optional. The volume's name. Either UUID or Name must be provided to identify the volume to get.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// projectName
	//
	// Name of project volume belongs to.
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetVolumeRequest) Reset() {
	*x = GetVolumeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[47]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetVolumeRequest) ProtoMessage() {}

func (x *GetVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[47]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetVolumeRequest.ProtoReflect.Descriptor instead.
func (*GetVolumeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{47}
}

func (x *GetVolumeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *GetVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetVolumeRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type GetNodeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// ID of node to get.
	UUID          string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetNodeRequest) Reset() {
	*x = GetNodeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[48]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNodeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNodeRequest) ProtoMessage() {}

func (x *GetNodeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[48]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNodeRequest.ProtoReflect.Descriptor instead.
func (*GetNodeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{48}
}

func (x *GetNodeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

type ListVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// List only volume with matching UUID.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Name
	//
	// List only volumes with specified name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// failureDomain
	//
	// List volumes according to failureDomains volumes replicas are placed on.
	FailureDomain string `protobuf:"bytes,3,opt,name=failureDomain,proto3" json:"failureDomain,omitempty"`
	// offsetUUID
	//
	// When provided, returned list starts with next to offsetUUID volume.
	OffsetUUID string `protobuf:"bytes,4,opt,name=offsetUUID,proto3" json:"offsetUUID,omitempty"`
	// limit
	//
	// Limits the number of volumes in the response (default/maximum value is 1000 volumes).
	Limit int64 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	// projectName
	//
	// Optional. Return only volumes of the given project.
	ProjectName string `protobuf:"bytes,6,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// source snapshot UUID
	//
	// Return only volumes created from this source snapshot.
	SnapshotUUID string `protobuf:"bytes,7,opt,name=snapshotUUID,proto3" json:"snapshotUUID,omitempty"`
	// showAll
	//
	// Optional. Show also volumes in Deleting state (the default is false).
	ShowAll       bool `protobuf:"varint,8,opt,name=showAll,proto3" json:"showAll,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListVolumeRequest) Reset() {
	*x = ListVolumeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[49]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListVolumeRequest) ProtoMessage() {}

func (x *ListVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[49]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListVolumeRequest.ProtoReflect.Descriptor instead.
func (*ListVolumeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{49}
}

func (x *ListVolumeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ListVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListVolumeRequest) GetFailureDomain() string {
	if x != nil {
		return x.FailureDomain
	}
	return ""
}

func (x *ListVolumeRequest) GetOffsetUUID() string {
	if x != nil {
		return x.OffsetUUID
	}
	return ""
}

func (x *ListVolumeRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListVolumeRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *ListVolumeRequest) GetSnapshotUUID() string {
	if x != nil {
		return x.SnapshotUUID
	}
	return ""
}

func (x *ListVolumeRequest) GetShowAll() bool {
	if x != nil {
		return x.ShowAll
	}
	return false
}

type ListNvmeDevicesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// nodeUUID
	//
	// Optionally, list all NVMe devices managed by a specified node.
	NodeUUID string `protobuf:"bytes,1,opt,name=nodeUUID,proto3" json:"nodeUUID,omitempty"`
	// serverUUID
	//
	// Optionally, list all NVMe devices attached to a specified server.
	ServerUUID string `protobuf:"bytes,2,opt,name=serverUUID,proto3" json:"serverUUID,omitempty"`
	// deviceUsage
	//
	// Optionally, filter NVMe devices by their usage
	DeviceUsages  []UserNvmeDevicesResponse_DeviceUsageEnum `protobuf:"varint,3,rep,packed,name=deviceUsages,proto3,enum=lightbits.api.duros.v2.UserNvmeDevicesResponse_DeviceUsageEnum" json:"deviceUsages,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListNvmeDevicesRequest) Reset() {
	*x = ListNvmeDevicesRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[50]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListNvmeDevicesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListNvmeDevicesRequest) ProtoMessage() {}

func (x *ListNvmeDevicesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[50]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListNvmeDevicesRequest.ProtoReflect.Descriptor instead.
func (*ListNvmeDevicesRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{50}
}

func (x *ListNvmeDevicesRequest) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

func (x *ListNvmeDevicesRequest) GetServerUUID() string {
	if x != nil {
		return x.ServerUUID
	}
	return ""
}

func (x *ListNvmeDevicesRequest) GetDeviceUsages() []UserNvmeDevicesResponse_DeviceUsageEnum {
	if x != nil {
		return x.DeviceUsages
	}
	return nil
}

type GetNvmeDeviceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Serial
	//
	// Serial number of the NVMe device to get.
	Serial        string `protobuf:"bytes,1,opt,name=Serial,proto3" json:"Serial,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetNvmeDeviceRequest) Reset() {
	*x = GetNvmeDeviceRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[51]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetNvmeDeviceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetNvmeDeviceRequest) ProtoMessage() {}

func (x *GetNvmeDeviceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[51]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetNvmeDeviceRequest.ProtoReflect.Descriptor instead.
func (*GetNvmeDeviceRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{51}
}

func (x *GetNvmeDeviceRequest) GetSerial() string {
	if x != nil {
		return x.Serial
	}
	return ""
}

type ListNvmeDevicesResponse struct {
	state         protoimpl.MessageState     `protogen:"open.v1"`
	NvmeDevices   []*UserNvmeDevicesResponse `protobuf:"bytes,1,rep,name=NvmeDevices,proto3" json:"NvmeDevices,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListNvmeDevicesResponse) Reset() {
	*x = ListNvmeDevicesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[52]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListNvmeDevicesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListNvmeDevicesResponse) ProtoMessage() {}

func (x *ListNvmeDevicesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[52]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListNvmeDevicesResponse.ProtoReflect.Descriptor instead.
func (*ListNvmeDevicesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{52}
}

func (x *ListNvmeDevicesResponse) GetNvmeDevices() []*UserNvmeDevicesResponse {
	if x != nil {
		return x.NvmeDevices
	}
	return nil
}

type ConnectedHost struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// hostNQN
	//
	// Host's NVMe qualified name (NQN).
	HostNQN string `protobuf:"bytes,1,opt,name=hostNQN,proto3" json:"hostNQN,omitempty"`
	// iPAddress
	//
	// Host's IP addresses.
	IPAddress string `protobuf:"bytes,2,opt,name=iPAddress,proto3" json:"iPAddress,omitempty"`
	// hostname
	//
	// Host's name.
	Hostname string `protobuf:"bytes,3,opt,name=hostname,proto3" json:"hostname,omitempty"`
	// volumeUUIDs
	//
	// list of volumes to which this host connects to.
	VolumeUUIDs   []string `protobuf:"bytes,4,rep,name=volumeUUIDs,proto3" json:"volumeUUIDs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ConnectedHost) Reset() {
	*x = ConnectedHost{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[53]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ConnectedHost) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ConnectedHost) ProtoMessage() {}

func (x *ConnectedHost) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[53]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ConnectedHost.ProtoReflect.Descriptor instead.
func (*ConnectedHost) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{53}
}

func (x *ConnectedHost) GetHostNQN() string {
	if x != nil {
		return x.HostNQN
	}
	return ""
}

func (x *ConnectedHost) GetIPAddress() string {
	if x != nil {
		return x.IPAddress
	}
	return ""
}

func (x *ConnectedHost) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *ConnectedHost) GetVolumeUUIDs() []string {
	if x != nil {
		return x.VolumeUUIDs
	}
	return nil
}

type UserNvmeDevicesResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// size
	//
	// Total capacity of the device in bytes.
	Size uint64 `protobuf:"varint,1,opt,name=size,proto3" json:"size,omitempty"`
	// numaNodeID
	//
	// The NUMA node ID this device is associated with.
	NumaNodeID uint64 `protobuf:"varint,2,opt,name=numaNodeID,proto3" json:"numaNodeID,omitempty"`
	// model
	//
	// Model string of the device, if exists.
	Model string `protobuf:"bytes,3,opt,name=model,proto3" json:"model,omitempty"`
	// serial
	//
	// Serial of the block device, if exists.
	Serial string `protobuf:"bytes,4,opt,name=serial,proto3" json:"serial,omitempty"`
	// server UUID
	//
	// The UUID of the server to which the block device is installed.
	ServerUUID string `protobuf:"bytes,5,opt,name=serverUUID,proto3" json:"serverUUID,omitempty"`
	// device state
	//
	// Describes the state of the device. Unmanaged device state will be None.
	State UserNvmeDevicesResponse_StateEnum `protobuf:"varint,6,opt,name=state,proto3,enum=lightbits.api.duros.v2.UserNvmeDevicesResponse_StateEnum" json:"state,omitempty"`
	// device time of failure
	//
	// Relevant only for NVMe devices with deviceUsage set to Data.
	// Timestamp that will be updated in case the device has failed.
	FailureTime *timestamppb.Timestamp `protobuf:"bytes,7,opt,name=failureTime,proto3" json:"failureTime,omitempty"`
	// device rebuild completion time
	//
	// Relevant only for NVMe devices with deviceUsage set to Data.
	// Timestamp that will be updated once GFTL has completed
	// to rebuild all the data that the device had, and we are safe
	// for second failure.
	RebuildCompletionTime *timestamppb.Timestamp `protobuf:"bytes,8,opt,name=rebuildCompletionTime,proto3" json:"rebuildCompletionTime,omitempty"`
	// name
	//
	// Device name or address.
	Name string `protobuf:"bytes,9,opt,name=name,proto3" json:"name,omitempty"`
	// node UUID that manages the device
	//
	// The UUID of the node that manages the device. Empty string if the device is not managed.
	NodeUUID string `protobuf:"bytes,12,opt,name=nodeUUID,proto3" json:"nodeUUID,omitempty"`
	// Etag
	//
	// identifier for a specific version of a resource.
	ETag string `protobuf:"bytes,13,opt,name=ETag,proto3" json:"ETag,omitempty"`
	// Statistics
	//
	// Relevant only for NVMe devices with deviceUsage set to Data.
	// Various nvme-device related statistics.
	Statistics *NvmeDeviceStatisticsApi `protobuf:"bytes,14,opt,name=statistics,proto3" json:"statistics,omitempty"`
	// DeviceUsage
	//
	// Specifies the assignment of the NVMe device for example data, journal, etc..
	DeviceUsage   UserNvmeDevicesResponse_DeviceUsageEnum `protobuf:"varint,15,opt,name=deviceUsage,proto3,enum=lightbits.api.duros.v2.UserNvmeDevicesResponse_DeviceUsageEnum" json:"deviceUsage,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UserNvmeDevicesResponse) Reset() {
	*x = UserNvmeDevicesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[54]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UserNvmeDevicesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UserNvmeDevicesResponse) ProtoMessage() {}

func (x *UserNvmeDevicesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[54]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UserNvmeDevicesResponse.ProtoReflect.Descriptor instead.
func (*UserNvmeDevicesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{54}
}

func (x *UserNvmeDevicesResponse) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *UserNvmeDevicesResponse) GetNumaNodeID() uint64 {
	if x != nil {
		return x.NumaNodeID
	}
	return 0
}

func (x *UserNvmeDevicesResponse) GetModel() string {
	if x != nil {
		return x.Model
	}
	return ""
}

func (x *UserNvmeDevicesResponse) GetSerial() string {
	if x != nil {
		return x.Serial
	}
	return ""
}

func (x *UserNvmeDevicesResponse) GetServerUUID() string {
	if x != nil {
		return x.ServerUUID
	}
	return ""
}

func (x *UserNvmeDevicesResponse) GetState() UserNvmeDevicesResponse_StateEnum {
	if x != nil {
		return x.State
	}
	return UserNvmeDevicesResponse_None
}

func (x *UserNvmeDevicesResponse) GetFailureTime() *timestamppb.Timestamp {
	if x != nil {
		return x.FailureTime
	}
	return nil
}

func (x *UserNvmeDevicesResponse) GetRebuildCompletionTime() *timestamppb.Timestamp {
	if x != nil {
		return x.RebuildCompletionTime
	}
	return nil
}

func (x *UserNvmeDevicesResponse) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UserNvmeDevicesResponse) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

func (x *UserNvmeDevicesResponse) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *UserNvmeDevicesResponse) GetStatistics() *NvmeDeviceStatisticsApi {
	if x != nil {
		return x.Statistics
	}
	return nil
}

func (x *UserNvmeDevicesResponse) GetDeviceUsage() UserNvmeDevicesResponse_DeviceUsageEnum {
	if x != nil {
		return x.DeviceUsage
	}
	return UserNvmeDevicesResponse_Unknown
}

type DurosNodeInfo struct {
	state  protoimpl.MessageState   `protogen:"open.v1"`
	Name   string                   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	UUID   string                   `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	State  DurosNodeInfo_State      `protobuf:"varint,3,opt,name=state,proto3,enum=lightbits.api.duros.v2.DurosNodeInfo_State" json:"state,omitempty"`
	Status DurosNodeInfo_StatusEnum `protobuf:"varint,4,opt,name=status,proto3,enum=lightbits.api.duros.v2.DurosNodeInfo_StatusEnum" json:"status,omitempty"`
	// peer <ip>:<port> service data-path IP
	NvmeEndpoint         string             `protobuf:"bytes,5,opt,name=nvmeEndpoint,proto3" json:"nvmeEndpoint,omitempty"`
	FailureDomains       []string           `protobuf:"bytes,6,rep,name=failureDomains,proto3" json:"failureDomains,omitempty"`
	FailureInfo          string             `protobuf:"bytes,7,opt,name=failureInfo,proto3" json:"failureInfo,omitempty"`
	Hostname             string             `protobuf:"bytes,9,opt,name=hostname,proto3" json:"hostname,omitempty"`
	InLocalRebuild       bool               `protobuf:"varint,10,opt,name=inLocalRebuild,proto3" json:"inLocalRebuild,omitempty"`
	LocalRebuildProgress uint32             `protobuf:"varint,11,opt,name=localRebuildProgress,proto3" json:"localRebuildProgress,omitempty"`
	NumManagedDevices    int32              `protobuf:"varint,12,opt,name=numManagedDevices,proto3" json:"numManagedDevices,omitempty"`
	MaxNvmeDevices       uint32             `protobuf:"varint,13,opt,name=maxNvmeDevices,proto3" json:"maxNvmeDevices,omitempty"`
	Ec                   bool               `protobuf:"varint,14,opt,name=ec,proto3" json:"ec,omitempty"`
	Statistics           *NodeStatisticsApi `protobuf:"bytes,15,opt,name=statistics,proto3" json:"statistics,omitempty"`
	ServerUUID           string             `protobuf:"bytes,16,opt,name=serverUUID,proto3" json:"serverUUID,omitempty"`
	// Etag
	//
	// identifier for a specific version of a resource
	ETag             string `protobuf:"bytes,17,opt,name=ETag,proto3" json:"ETag,omitempty"`
	ReadOnly         bool   `protobuf:"varint,18,opt,name=readOnly,proto3" json:"readOnly,omitempty"`
	PowerupProgress  uint32 `protobuf:"varint,19,opt,name=powerupProgress,proto3" json:"powerupProgress,omitempty"`
	PermanentFailure bool   `protobuf:"varint,20,opt,name=permanentFailure,proto3" json:"permanentFailure,omitempty"`
	// Types that are valid to be assigned to JournalDeviceInfo:
	//
	//	*DurosNodeInfo_JournalDeviceNotFound
	//	*DurosNodeInfo_JournalNvmeDevice
	//	*DurosNodeInfo_JournalRaidDevice
	JournalDeviceInfo isDurosNodeInfo_JournalDeviceInfo `protobuf_oneof:"JournalDeviceInfo"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *DurosNodeInfo) Reset() {
	*x = DurosNodeInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[55]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DurosNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DurosNodeInfo) ProtoMessage() {}

func (x *DurosNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[55]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DurosNodeInfo.ProtoReflect.Descriptor instead.
func (*DurosNodeInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{55}
}

func (x *DurosNodeInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DurosNodeInfo) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DurosNodeInfo) GetState() DurosNodeInfo_State {
	if x != nil {
		return x.State
	}
	return DurosNodeInfo_Unknown
}

func (x *DurosNodeInfo) GetStatus() DurosNodeInfo_StatusEnum {
	if x != nil {
		return x.Status
	}
	return DurosNodeInfo_NoStatus
}

func (x *DurosNodeInfo) GetNvmeEndpoint() string {
	if x != nil {
		return x.NvmeEndpoint
	}
	return ""
}

func (x *DurosNodeInfo) GetFailureDomains() []string {
	if x != nil {
		return x.FailureDomains
	}
	return nil
}

func (x *DurosNodeInfo) GetFailureInfo() string {
	if x != nil {
		return x.FailureInfo
	}
	return ""
}

func (x *DurosNodeInfo) GetHostname() string {
	if x != nil {
		return x.Hostname
	}
	return ""
}

func (x *DurosNodeInfo) GetInLocalRebuild() bool {
	if x != nil {
		return x.InLocalRebuild
	}
	return false
}

func (x *DurosNodeInfo) GetLocalRebuildProgress() uint32 {
	if x != nil {
		return x.LocalRebuildProgress
	}
	return 0
}

func (x *DurosNodeInfo) GetNumManagedDevices() int32 {
	if x != nil {
		return x.NumManagedDevices
	}
	return 0
}

func (x *DurosNodeInfo) GetMaxNvmeDevices() uint32 {
	if x != nil {
		return x.MaxNvmeDevices
	}
	return 0
}

func (x *DurosNodeInfo) GetEc() bool {
	if x != nil {
		return x.Ec
	}
	return false
}

func (x *DurosNodeInfo) GetStatistics() *NodeStatisticsApi {
	if x != nil {
		return x.Statistics
	}
	return nil
}

func (x *DurosNodeInfo) GetServerUUID() string {
	if x != nil {
		return x.ServerUUID
	}
	return ""
}

func (x *DurosNodeInfo) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *DurosNodeInfo) GetReadOnly() bool {
	if x != nil {
		return x.ReadOnly
	}
	return false
}

func (x *DurosNodeInfo) GetPowerupProgress() uint32 {
	if x != nil {
		return x.PowerupProgress
	}
	return 0
}

func (x *DurosNodeInfo) GetPermanentFailure() bool {
	if x != nil {
		return x.PermanentFailure
	}
	return false
}

func (x *DurosNodeInfo) GetJournalDeviceInfo() isDurosNodeInfo_JournalDeviceInfo {
	if x != nil {
		return x.JournalDeviceInfo
	}
	return nil
}

func (x *DurosNodeInfo) GetJournalDeviceNotFound() string {
	if x != nil {
		if x, ok := x.JournalDeviceInfo.(*DurosNodeInfo_JournalDeviceNotFound); ok {
			return x.JournalDeviceNotFound
		}
	}
	return ""
}

func (x *DurosNodeInfo) GetJournalNvmeDevice() *JournalNvmeDevice {
	if x != nil {
		if x, ok := x.JournalDeviceInfo.(*DurosNodeInfo_JournalNvmeDevice); ok {
			return x.JournalNvmeDevice
		}
	}
	return nil
}

func (x *DurosNodeInfo) GetJournalRaidDevice() *JournalRaidDevice {
	if x != nil {
		if x, ok := x.JournalDeviceInfo.(*DurosNodeInfo_JournalRaidDevice); ok {
			return x.JournalRaidDevice
		}
	}
	return nil
}

type isDurosNodeInfo_JournalDeviceInfo interface {
	isDurosNodeInfo_JournalDeviceInfo()
}

type DurosNodeInfo_JournalDeviceNotFound struct {
	JournalDeviceNotFound string `protobuf:"bytes,21,opt,name=journalDeviceNotFound,proto3,oneof"`
}

type DurosNodeInfo_JournalNvmeDevice struct {
	JournalNvmeDevice *JournalNvmeDevice `protobuf:"bytes,22,opt,name=journalNvmeDevice,proto3,oneof"`
}

type DurosNodeInfo_JournalRaidDevice struct {
	JournalRaidDevice *JournalRaidDevice `protobuf:"bytes,23,opt,name=journalRaidDevice,proto3,oneof"`
}

func (*DurosNodeInfo_JournalDeviceNotFound) isDurosNodeInfo_JournalDeviceInfo() {}

func (*DurosNodeInfo_JournalNvmeDevice) isDurosNodeInfo_JournalDeviceInfo() {}

func (*DurosNodeInfo_JournalRaidDevice) isDurosNodeInfo_JournalDeviceInfo() {}

type JournalRaidDevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// deviceUUID
	//
	// The UUID of the RAID device.
	DeviceUUID string `protobuf:"bytes,1,opt,name=deviceUUID,proto3" json:"deviceUUID,omitempty"`
	// memberDeviceSerials
	//
	// Serial numbers of the devices participating in the RAID array.
	MemberDeviceSerials []string `protobuf:"bytes,2,rep,name=memberDeviceSerials,proto3" json:"memberDeviceSerials,omitempty"`
	unknownFields       protoimpl.UnknownFields
	sizeCache           protoimpl.SizeCache
}

func (x *JournalRaidDevice) Reset() {
	*x = JournalRaidDevice{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[56]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JournalRaidDevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JournalRaidDevice) ProtoMessage() {}

func (x *JournalRaidDevice) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[56]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JournalRaidDevice.ProtoReflect.Descriptor instead.
func (*JournalRaidDevice) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{56}
}

func (x *JournalRaidDevice) GetDeviceUUID() string {
	if x != nil {
		return x.DeviceUUID
	}
	return ""
}

func (x *JournalRaidDevice) GetMemberDeviceSerials() []string {
	if x != nil {
		return x.MemberDeviceSerials
	}
	return nil
}

type JournalNvmeDevice struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// deviceSerial
	//
	// The serial number of the NVMe device.
	DeviceSerial  string `protobuf:"bytes,1,opt,name=deviceSerial,proto3" json:"deviceSerial,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *JournalNvmeDevice) Reset() {
	*x = JournalNvmeDevice{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[57]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *JournalNvmeDevice) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*JournalNvmeDevice) ProtoMessage() {}

func (x *JournalNvmeDevice) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[57]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use JournalNvmeDevice.ProtoReflect.Descriptor instead.
func (*JournalNvmeDevice) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{57}
}

func (x *JournalNvmeDevice) GetDeviceSerial() string {
	if x != nil {
		return x.DeviceSerial
	}
	return ""
}

type ListNodesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Nodes         []*DurosNodeInfo       `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListNodesResponse) Reset() {
	*x = ListNodesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[58]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListNodesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListNodesResponse) ProtoMessage() {}

func (x *ListNodesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[58]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListNodesResponse.ProtoReflect.Descriptor instead.
func (*ListNodesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{58}
}

func (x *ListNodesResponse) GetNodes() []*DurosNodeInfo {
	if x != nil {
		return x.Nodes
	}
	return nil
}

type ListVolumesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Volumes       []*Volume              `protobuf:"bytes,1,rep,name=volumes,proto3" json:"volumes,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListVolumesResponse) Reset() {
	*x = ListVolumesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[59]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListVolumesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListVolumesResponse) ProtoMessage() {}

func (x *ListVolumesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[59]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListVolumesResponse.ProtoReflect.Descriptor instead.
func (*ListVolumesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{59}
}

func (x *ListVolumesResponse) GetVolumes() []*Volume {
	if x != nil {
		return x.Volumes
	}
	return nil
}

type UpdateNvmeDeviceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateNvmeDeviceResponse) Reset() {
	*x = UpdateNvmeDeviceResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[60]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateNvmeDeviceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateNvmeDeviceResponse) ProtoMessage() {}

func (x *UpdateNvmeDeviceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[60]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateNvmeDeviceResponse.ProtoReflect.Descriptor instead.
func (*UpdateNvmeDeviceResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{60}
}

type AddNvmeDeviceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *AddNvmeDeviceResponse) Reset() {
	*x = AddNvmeDeviceResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[61]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AddNvmeDeviceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AddNvmeDeviceResponse) ProtoMessage() {}

func (x *AddNvmeDeviceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[61]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AddNvmeDeviceResponse.ProtoReflect.Descriptor instead.
func (*AddNvmeDeviceResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{61}
}

type UpdateVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateVolumeResponse) Reset() {
	*x = UpdateVolumeResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[62]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateVolumeResponse) ProtoMessage() {}

func (x *UpdateVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[62]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateVolumeResponse.ProtoReflect.Descriptor instead.
func (*UpdateVolumeResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{62}
}

type UpgradeServerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpgradeServerResponse) Reset() {
	*x = UpgradeServerResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[63]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpgradeServerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpgradeServerResponse) ProtoMessage() {}

func (x *UpgradeServerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[63]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpgradeServerResponse.ProtoReflect.Descriptor instead.
func (*UpgradeServerResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{63}
}

type UpgradeClusterResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpgradeClusterResponse) Reset() {
	*x = UpgradeClusterResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[64]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpgradeClusterResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpgradeClusterResponse) ProtoMessage() {}

func (x *UpgradeClusterResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[64]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpgradeClusterResponse.ProtoReflect.Descriptor instead.
func (*UpgradeClusterResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{64}
}

type EnableClusterEncryptionResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnableClusterEncryptionResponse) Reset() {
	*x = EnableClusterEncryptionResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[65]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnableClusterEncryptionResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnableClusterEncryptionResponse) ProtoMessage() {}

func (x *EnableClusterEncryptionResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[65]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnableClusterEncryptionResponse.ProtoReflect.Descriptor instead.
func (*EnableClusterEncryptionResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{65}
}

type ReplaceNodeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ReplaceNodeResponse) Reset() {
	*x = ReplaceNodeResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[66]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ReplaceNodeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ReplaceNodeResponse) ProtoMessage() {}

func (x *ReplaceNodeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[66]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ReplaceNodeResponse.ProtoReflect.Descriptor instead.
func (*ReplaceNodeResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{66}
}

type DeleteServerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteServerResponse) Reset() {
	*x = DeleteServerResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[67]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteServerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteServerResponse) ProtoMessage() {}

func (x *DeleteServerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[67]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteServerResponse.ProtoReflect.Descriptor instead.
func (*DeleteServerResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{67}
}

type DisableServerResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisableServerResponse) Reset() {
	*x = DisableServerResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[68]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisableServerResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisableServerResponse) ProtoMessage() {}

func (x *DisableServerResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[68]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisableServerResponse.ProtoReflect.Descriptor instead.
func (*DisableServerResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{68}
}

type StartNodeInstanceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// nodeUUID
	//
	// The UUID of the node to start.
	NodeUUID      string `protobuf:"bytes,1,opt,name=nodeUUID,proto3" json:"nodeUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartNodeInstanceRequest) Reset() {
	*x = StartNodeInstanceRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[69]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartNodeInstanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartNodeInstanceRequest) ProtoMessage() {}

func (x *StartNodeInstanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[69]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartNodeInstanceRequest.ProtoReflect.Descriptor instead.
func (*StartNodeInstanceRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{69}
}

func (x *StartNodeInstanceRequest) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

type StartNodeInstanceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StartNodeInstanceResponse) Reset() {
	*x = StartNodeInstanceResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[70]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StartNodeInstanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StartNodeInstanceResponse) ProtoMessage() {}

func (x *StartNodeInstanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[70]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StartNodeInstanceResponse.ProtoReflect.Descriptor instead.
func (*StartNodeInstanceResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{70}
}

type StopNodeInstanceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// nodeUUID
	//
	// The UUID of the node to stop.
	NodeUUID string `protobuf:"bytes,1,opt,name=nodeUUID,proto3" json:"nodeUUID,omitempty"`
	// force
	//
	// When set to true, bypasses the safety check that prevents stopping a node
	// if it would cause volumes to become unavailable or read-only.
	// WARNING: Using force=true may cause data unavailability.
	// Default: false
	Force         bool `protobuf:"varint,2,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopNodeInstanceRequest) Reset() {
	*x = StopNodeInstanceRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[71]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopNodeInstanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopNodeInstanceRequest) ProtoMessage() {}

func (x *StopNodeInstanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[71]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopNodeInstanceRequest.ProtoReflect.Descriptor instead.
func (*StopNodeInstanceRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{71}
}

func (x *StopNodeInstanceRequest) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

func (x *StopNodeInstanceRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

type StopNodeInstanceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *StopNodeInstanceResponse) Reset() {
	*x = StopNodeInstanceResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[72]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *StopNodeInstanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*StopNodeInstanceResponse) ProtoMessage() {}

func (x *StopNodeInstanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[72]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use StopNodeInstanceResponse.ProtoReflect.Descriptor instead.
func (*StopNodeInstanceResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{72}
}

type RestartNodeInstanceRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// nodeUUID
	//
	// The UUID of the node to restart.
	NodeUUID string `protobuf:"bytes,1,opt,name=nodeUUID,proto3" json:"nodeUUID,omitempty"`
	// considerBackend
	//
	// Whether to include the backend (gftl) when restarting the node.
	// When true, both duroslight and gftl backend will be restarted.
	// When false (default), only duroslight and control plane components will be restarted.
	// Default: false
	ConsiderBackend bool `protobuf:"varint,2,opt,name=considerBackend,proto3" json:"considerBackend,omitempty"`
	// force
	//
	// When set to true, bypasses the safety check that prevents restarting a node
	// if it would cause volumes to become unavailable or read-only.
	// WARNING: Using force=true may cause temporary data unavailability.
	// Default: false
	Force         bool `protobuf:"varint,3,opt,name=force,proto3" json:"force,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RestartNodeInstanceRequest) Reset() {
	*x = RestartNodeInstanceRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[73]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RestartNodeInstanceRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestartNodeInstanceRequest) ProtoMessage() {}

func (x *RestartNodeInstanceRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[73]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RestartNodeInstanceRequest.ProtoReflect.Descriptor instead.
func (*RestartNodeInstanceRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{73}
}

func (x *RestartNodeInstanceRequest) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

func (x *RestartNodeInstanceRequest) GetConsiderBackend() bool {
	if x != nil {
		return x.ConsiderBackend
	}
	return false
}

func (x *RestartNodeInstanceRequest) GetForce() bool {
	if x != nil {
		return x.Force
	}
	return false
}

type RestartNodeInstanceResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RestartNodeInstanceResponse) Reset() {
	*x = RestartNodeInstanceResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[74]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RestartNodeInstanceResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RestartNodeInstanceResponse) ProtoMessage() {}

func (x *RestartNodeInstanceResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[74]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RestartNodeInstanceResponse.ProtoReflect.Descriptor instead.
func (*RestartNodeInstanceResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{74}
}

type ListServersRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Filter server by the server's UUID.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Name
	//
	// Filter server by the server's name.
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// RiskOfServiceLoss
	//
	// List only servers in a RiskOfServiceLoss state matching the specified state.
	RiskOfServiceLoss Server_RiskOfServiceLossEnum `protobuf:"varint,3,opt,name=RiskOfServiceLoss,proto3,enum=lightbits.api.duros.v2.Server_RiskOfServiceLossEnum" json:"RiskOfServiceLoss,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ListServersRequest) Reset() {
	*x = ListServersRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[75]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListServersRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListServersRequest) ProtoMessage() {}

func (x *ListServersRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[75]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListServersRequest.ProtoReflect.Descriptor instead.
func (*ListServersRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{75}
}

func (x *ListServersRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ListServersRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListServersRequest) GetRiskOfServiceLoss() Server_RiskOfServiceLossEnum {
	if x != nil {
		return x.RiskOfServiceLoss
	}
	return Server_UnknownRiskOfServiceLoss
}

type GetServerRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The server's UUID for the get server request.
	UUID          string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetServerRequest) Reset() {
	*x = GetServerRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[76]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetServerRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetServerRequest) ProtoMessage() {}

func (x *GetServerRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[76]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetServerRequest.ProtoReflect.Descriptor instead.
func (*GetServerRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{76}
}

func (x *GetServerRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

type ListServersResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Servers       []*Server              `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListServersResponse) Reset() {
	*x = ListServersResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[77]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListServersResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListServersResponse) ProtoMessage() {}

func (x *ListServersResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[77]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListServersResponse.ProtoReflect.Descriptor instead.
func (*ListServersResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{77}
}

func (x *ListServersResponse) GetServers() []*Server {
	if x != nil {
		return x.Servers
	}
	return nil
}

type ClusterUpgradeStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Cluster       *ClusterInfo           `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterUpgradeStatusResponse) Reset() {
	*x = ClusterUpgradeStatusResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[78]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterUpgradeStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterUpgradeStatusResponse) ProtoMessage() {}

func (x *ClusterUpgradeStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[78]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterUpgradeStatusResponse.ProtoReflect.Descriptor instead.
func (*ClusterUpgradeStatusResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{78}
}

func (x *ClusterUpgradeStatusResponse) GetCluster() *ClusterInfo {
	if x != nil {
		return x.Cluster
	}
	return nil
}

type ListUpgradeStatusResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Servers       []*Server              `protobuf:"bytes,1,rep,name=servers,proto3" json:"servers,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListUpgradeStatusResponse) Reset() {
	*x = ListUpgradeStatusResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[79]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListUpgradeStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListUpgradeStatusResponse) ProtoMessage() {}

func (x *ListUpgradeStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[79]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListUpgradeStatusResponse.ProtoReflect.Descriptor instead.
func (*ListUpgradeStatusResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{79}
}

func (x *ListUpgradeStatusResponse) GetServers() []*Server {
	if x != nil {
		return x.Servers
	}
	return nil
}

type Version struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// latest user API version
	ApiVersion    string `protobuf:"bytes,4,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Version) Reset() {
	*x = Version{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[80]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Version) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Version) ProtoMessage() {}

func (x *Version) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[80]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Version.ProtoReflect.Descriptor instead.
func (*Version) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{80}
}

func (x *Version) GetApiVersion() string {
	if x != nil {
		return x.ApiVersion
	}
	return ""
}

type ClusterLastUpgrade struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Status
	//
	// The status of the upgrade operation
	Status ClusterLastUpgrade_UpgradeStatusEnum `protobuf:"varint,1,opt,name=Status,proto3,enum=lightbits.api.duros.v2.ClusterLastUpgrade_UpgradeStatusEnum" json:"Status,omitempty"`
	// StartTime
	//
	// The time of the upgrade task start
	StartTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	// EndTime
	//
	// The time of closing the upgrade task (completed or failed). Reset when the next upgrade starts.
	EndTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	// TargetVersion
	//
	// The version that should be installed by the end of the process.
	TargetVersion string `protobuf:"bytes,4,opt,name=TargetVersion,proto3" json:"TargetVersion,omitempty"`
	// ErrorMessage
	//
	// Free formatted text, describes the error if such an error occurred.
	ErrorMessage string `protobuf:"bytes,5,opt,name=ErrorMessage,proto3" json:"ErrorMessage,omitempty"`
	// ProgressStep
	//
	// Current upgrade step. You can use ProgressTotal to calculate percentage as ProgressStep/ProgressTotal.
	ProgressStep uint32 `protobuf:"varint,6,opt,name=ProgressStep,proto3" json:"ProgressStep,omitempty"`
	// ProgressTotal
	//
	// Total possible upgrade progress steps.
	ProgressTotal uint32 `protobuf:"varint,7,opt,name=ProgressTotal,proto3" json:"ProgressTotal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterLastUpgrade) Reset() {
	*x = ClusterLastUpgrade{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[81]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterLastUpgrade) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterLastUpgrade) ProtoMessage() {}

func (x *ClusterLastUpgrade) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[81]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterLastUpgrade.ProtoReflect.Descriptor instead.
func (*ClusterLastUpgrade) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{81}
}

func (x *ClusterLastUpgrade) GetStatus() ClusterLastUpgrade_UpgradeStatusEnum {
	if x != nil {
		return x.Status
	}
	return ClusterLastUpgrade_Unknown
}

func (x *ClusterLastUpgrade) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ClusterLastUpgrade) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *ClusterLastUpgrade) GetTargetVersion() string {
	if x != nil {
		return x.TargetVersion
	}
	return ""
}

func (x *ClusterLastUpgrade) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *ClusterLastUpgrade) GetProgressStep() uint32 {
	if x != nil {
		return x.ProgressStep
	}
	return 0
}

func (x *ClusterLastUpgrade) GetProgressTotal() uint32 {
	if x != nil {
		return x.ProgressTotal
	}
	return 0
}

type ClusterInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cluster UUID
	//
	// UUID of cluster
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// subsystemNQN
	//
	// Subsystem NQN that should be used by the hosts to connect to volumes on this cluster.
	SubsystemNQN string `protobuf:"bytes,2,opt,name=subsystemNQN,proto3" json:"subsystemNQN,omitempty"`
	// Current maximum number of replicas per volume
	//
	// A maximal number of replicas that a new volume can have, given the current state of the nodes. This value depends on the healthiness of the nodes.
	CurrentMaxReplicas uint32 `protobuf:"varint,3,opt,name=currentMaxReplicas,proto3" json:"currentMaxReplicas,omitempty"`
	// Maximum number of replicas per volume supported by cluster.
	//
	// A maximal number of replicas that a volume can have, given cluster installation parameters (Number of Servers, Failure Domains...).
	SupportedMaxReplicas uint32 `protobuf:"varint,4,opt,name=supportedMaxReplicas,proto3" json:"supportedMaxReplicas,omitempty"`
	// cluster statistics
	//
	// Cluster statistics (storage capacity, used storage, compression ration...)
	Statistics *ClusterStatisticsApi `protobuf:"bytes,5,opt,name=statistics,proto3" json:"statistics,omitempty"`
	// Etag
	//
	// Identifier for a specific version of a resource.
	ETag string `protobuf:"bytes,6,opt,name=ETag,proto3" json:"ETag,omitempty"`
	// Cluster Health
	//
	// Cluster health: OK- cluster healthy, Warning - Inactive node(s) and/or degraded volumes in cluster, Error - ReadOnly/Unavailable volumes in cluster.
	Health *ClusterHealth `protobuf:"bytes,7,opt,name=health,proto3" json:"health,omitempty"`
	// Minimal Lightbits version
	//
	// Lowest version of Lightbits running on one of the servers in the cluster.
	MinVersionInCluster string `protobuf:"bytes,8,opt,name=MinVersionInCluster,proto3" json:"MinVersionInCluster,omitempty"`
	// Minimal allowed Lightbits version
	//
	// For Lightbits internal use.
	MinAllowedVersion string `protobuf:"bytes,9,opt,name=MinAllowedVersion,proto3" json:"MinAllowedVersion,omitempty"`
	// Maximal allowed Lightbits version
	//
	// Lightbits version this cluster can be upgraded to.
	MaxAllowedVersion string `protobuf:"bytes,10,opt,name=MaxAllowedVersion,proto3" json:"MaxAllowedVersion,omitempty"`
	// Addresses of the API Service
	//
	// A list of REST/gRPC endpoints - <ip>:<port> pairs that the API listen on.
	// Example entries:
	// - 192.168.16.16:443
	// - 192.168.16.17:443
	ApiEndpoints []string `protobuf:"bytes,11,rep,name=apiEndpoints,proto3" json:"apiEndpoints,omitempty"`
	// Addresses of the Discovery Service
	//
	// A list of TCP endpoints - <ip>:<port> pairs that the Discovery Service listen on.
	// Example entries:
	// - 192.168.16.16:8009
	// - 192.168.16.17:8009
	DiscoveryEndpoints []string `protobuf:"bytes,12,rep,name=discoveryEndpoints,proto3" json:"discoveryEndpoints,omitempty"`
	// cluster name
	//
	// Cluster name.
	ClusterName string `protobuf:"bytes,13,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	// lastUpgrade
	//
	// Parameters of the last (or active) cluster upgrade process.
	LastUpgrade *ClusterLastUpgrade `protobuf:"bytes,14,opt,name=lastUpgrade,proto3" json:"lastUpgrade,omitempty"`
	// inBandAuthMode
	//
	// Defines whether In-Band Authentication is enabled for the cluster(Enabled/Disabled).
	// When enabled, authentication is required for hosts to connect to the Lightbits cluster.
	InBandAuthMode ClusterInfo_AuthenticationMode `protobuf:"varint,15,opt,name=inBandAuthMode,proto3,enum=lightbits.api.duros.v2.ClusterInfo_AuthenticationMode" json:"inBandAuthMode,omitempty"`
	// encryptionStatus
	//
	// Information about the state of Cluster Level Encryption.
	EncryptionStatus *ClusterEncryptionStatus `protobuf:"bytes,16,opt,name=encryptionStatus,proto3" json:"encryptionStatus,omitempty"`
	// federatedAuthenticationStatus
	//
	// Information about the state of Federated Authentication
	FederatedAuthenticationStatus *FederatedAuthenticationStatus `protobuf:"bytes,17,opt,name=federatedAuthenticationStatus,proto3" json:"federatedAuthenticationStatus,omitempty"`
	unknownFields                 protoimpl.UnknownFields
	sizeCache                     protoimpl.SizeCache
}

func (x *ClusterInfo) Reset() {
	*x = ClusterInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[82]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterInfo) ProtoMessage() {}

func (x *ClusterInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[82]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterInfo.ProtoReflect.Descriptor instead.
func (*ClusterInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{82}
}

func (x *ClusterInfo) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ClusterInfo) GetSubsystemNQN() string {
	if x != nil {
		return x.SubsystemNQN
	}
	return ""
}

func (x *ClusterInfo) GetCurrentMaxReplicas() uint32 {
	if x != nil {
		return x.CurrentMaxReplicas
	}
	return 0
}

func (x *ClusterInfo) GetSupportedMaxReplicas() uint32 {
	if x != nil {
		return x.SupportedMaxReplicas
	}
	return 0
}

func (x *ClusterInfo) GetStatistics() *ClusterStatisticsApi {
	if x != nil {
		return x.Statistics
	}
	return nil
}

func (x *ClusterInfo) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *ClusterInfo) GetHealth() *ClusterHealth {
	if x != nil {
		return x.Health
	}
	return nil
}

func (x *ClusterInfo) GetMinVersionInCluster() string {
	if x != nil {
		return x.MinVersionInCluster
	}
	return ""
}

func (x *ClusterInfo) GetMinAllowedVersion() string {
	if x != nil {
		return x.MinAllowedVersion
	}
	return ""
}

func (x *ClusterInfo) GetMaxAllowedVersion() string {
	if x != nil {
		return x.MaxAllowedVersion
	}
	return ""
}

func (x *ClusterInfo) GetApiEndpoints() []string {
	if x != nil {
		return x.ApiEndpoints
	}
	return nil
}

func (x *ClusterInfo) GetDiscoveryEndpoints() []string {
	if x != nil {
		return x.DiscoveryEndpoints
	}
	return nil
}

func (x *ClusterInfo) GetClusterName() string {
	if x != nil {
		return x.ClusterName
	}
	return ""
}

func (x *ClusterInfo) GetLastUpgrade() *ClusterLastUpgrade {
	if x != nil {
		return x.LastUpgrade
	}
	return nil
}

func (x *ClusterInfo) GetInBandAuthMode() ClusterInfo_AuthenticationMode {
	if x != nil {
		return x.InBandAuthMode
	}
	return ClusterInfo_UnKnown
}

func (x *ClusterInfo) GetEncryptionStatus() *ClusterEncryptionStatus {
	if x != nil {
		return x.EncryptionStatus
	}
	return nil
}

func (x *ClusterInfo) GetFederatedAuthenticationStatus() *FederatedAuthenticationStatus {
	if x != nil {
		return x.FederatedAuthenticationStatus
	}
	return nil
}

type ClusterInfoV2 struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cluster UUID
	//
	// UUID of cluster
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// subsystemNQN
	//
	// Subsystem NQN that should be used by the hosts to connect to volumes on this server.
	SubsystemNQN string `protobuf:"bytes,2,opt,name=subsystemNQN,proto3" json:"subsystemNQN,omitempty"`
	// Current maximum number of replicas per volume
	//
	// A maximal number of replicas that a new volume can have, given the current state of the nodes. This value depends on the healthiness of the nodes.
	CurrentMaxReplicas uint32 `protobuf:"varint,3,opt,name=currentMaxReplicas,proto3" json:"currentMaxReplicas,omitempty"`
	// Maximum number of replicas per volume supported by the cluster
	//
	// A maximal number of replicas that a volume can have, given the cluster installation parameters.
	SupportedMaxReplicas uint32 `protobuf:"varint,4,opt,name=supportedMaxReplicas,proto3" json:"supportedMaxReplicas,omitempty"`
	// Etag
	//
	// identifier for a specific version of a resource.
	ETag string `protobuf:"bytes,6,opt,name=ETag,proto3" json:"ETag,omitempty"`
	// Addresses of the API Service
	//
	// A list of REST/gRPC endpoints - <ip>:<port> pairs that the API listen on.
	// Example entries:
	// - 192.168.16.16:443
	// - 192.168.16.17:443
	ApiEndpoints []string `protobuf:"bytes,11,rep,name=apiEndpoints,proto3" json:"apiEndpoints,omitempty"`
	// Addresses of the Discovery Service
	//
	// A list of TCP endpoints - <ip>:<port> pairs that the Discovery Service listen on.
	// Example entries:
	// - 192.168.16.16:8009
	// - 192.168.16.17:8009
	DiscoveryEndpoints []string `protobuf:"bytes,12,rep,name=discoveryEndpoints,proto3" json:"discoveryEndpoints,omitempty"`
	// Addresses of the NVMe endpoints
	//
	// A list of TCP endpoints - <ip>:<port> pairs that the NVMe targets listen on.
	// Example entries:
	// - 192.168.16.16:4420
	// - 192.168.16.17:4420
	NvmeEndpoints []string `protobuf:"bytes,13,rep,name=nvmeEndpoints,proto3" json:"nvmeEndpoints,omitempty"`
	// cluster name
	//
	// cluster name.
	ClusterName string `protobuf:"bytes,14,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	// lastUpgrade
	//
	// Parameters of the last (or active) cluster upgrade process
	LastUpgrade *ClusterLastUpgrade `protobuf:"bytes,15,opt,name=lastUpgrade,proto3" json:"lastUpgrade,omitempty"`
	// encryptionStatus
	//
	// Information about the state of Cluster Level Encryption
	EncryptionStatus *ClusterEncryptionStatus `protobuf:"bytes,16,opt,name=encryptionStatus,proto3" json:"encryptionStatus,omitempty"`
	// Defines whether In-Band Authentication is enabled for the cluster(Enabled/Disabled).
	// When enabled, authentication is required for hosts to connect to the Lightbits cluster.
	InBandAuthMode ClusterInfo_AuthenticationMode `protobuf:"varint,17,opt,name=inBandAuthMode,proto3,enum=lightbits.api.duros.v2.ClusterInfo_AuthenticationMode" json:"inBandAuthMode,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ClusterInfoV2) Reset() {
	*x = ClusterInfoV2{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[83]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterInfoV2) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterInfoV2) ProtoMessage() {}

func (x *ClusterInfoV2) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[83]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterInfoV2.ProtoReflect.Descriptor instead.
func (*ClusterInfoV2) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{83}
}

func (x *ClusterInfoV2) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ClusterInfoV2) GetSubsystemNQN() string {
	if x != nil {
		return x.SubsystemNQN
	}
	return ""
}

func (x *ClusterInfoV2) GetCurrentMaxReplicas() uint32 {
	if x != nil {
		return x.CurrentMaxReplicas
	}
	return 0
}

func (x *ClusterInfoV2) GetSupportedMaxReplicas() uint32 {
	if x != nil {
		return x.SupportedMaxReplicas
	}
	return 0
}

func (x *ClusterInfoV2) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *ClusterInfoV2) GetApiEndpoints() []string {
	if x != nil {
		return x.ApiEndpoints
	}
	return nil
}

func (x *ClusterInfoV2) GetDiscoveryEndpoints() []string {
	if x != nil {
		return x.DiscoveryEndpoints
	}
	return nil
}

func (x *ClusterInfoV2) GetNvmeEndpoints() []string {
	if x != nil {
		return x.NvmeEndpoints
	}
	return nil
}

func (x *ClusterInfoV2) GetClusterName() string {
	if x != nil {
		return x.ClusterName
	}
	return ""
}

func (x *ClusterInfoV2) GetLastUpgrade() *ClusterLastUpgrade {
	if x != nil {
		return x.LastUpgrade
	}
	return nil
}

func (x *ClusterInfoV2) GetEncryptionStatus() *ClusterEncryptionStatus {
	if x != nil {
		return x.EncryptionStatus
	}
	return nil
}

func (x *ClusterInfoV2) GetInBandAuthMode() ClusterInfo_AuthenticationMode {
	if x != nil {
		return x.InBandAuthMode
	}
	return ClusterInfo_UnKnown
}

type ClusterHealth struct {
	state                  protoimpl.MessageState `protogen:"open.v1"`
	State                  ClusterHealth_State    `protobuf:"varint,1,opt,name=state,proto3,enum=lightbits.api.duros.v2.ClusterHealth_State" json:"state,omitempty"`
	NumDegradedVolumes     uint32                 `protobuf:"varint,2,opt,name=numDegradedVolumes,proto3" json:"numDegradedVolumes,omitempty"`
	NumReadOnlyVolumes     uint32                 `protobuf:"varint,3,opt,name=numReadOnlyVolumes,proto3" json:"numReadOnlyVolumes,omitempty"`
	NumNotAvailableVolumes uint32                 `protobuf:"varint,4,opt,name=numNotAvailableVolumes,proto3" json:"numNotAvailableVolumes,omitempty"`
	NumInactiveNodes       uint32                 `protobuf:"varint,5,opt,name=numInactiveNodes,proto3" json:"numInactiveNodes,omitempty"`
	NumHealthyVolumes      uint32                 `protobuf:"varint,6,opt,name=numHealthyVolumes,proto3" json:"numHealthyVolumes,omitempty"`
	unknownFields          protoimpl.UnknownFields
	sizeCache              protoimpl.SizeCache
}

func (x *ClusterHealth) Reset() {
	*x = ClusterHealth{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[84]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterHealth) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterHealth) ProtoMessage() {}

func (x *ClusterHealth) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[84]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterHealth.ProtoReflect.Descriptor instead.
func (*ClusterHealth) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{84}
}

func (x *ClusterHealth) GetState() ClusterHealth_State {
	if x != nil {
		return x.State
	}
	return ClusterHealth_None
}

func (x *ClusterHealth) GetNumDegradedVolumes() uint32 {
	if x != nil {
		return x.NumDegradedVolumes
	}
	return 0
}

func (x *ClusterHealth) GetNumReadOnlyVolumes() uint32 {
	if x != nil {
		return x.NumReadOnlyVolumes
	}
	return 0
}

func (x *ClusterHealth) GetNumNotAvailableVolumes() uint32 {
	if x != nil {
		return x.NumNotAvailableVolumes
	}
	return 0
}

func (x *ClusterHealth) GetNumInactiveNodes() uint32 {
	if x != nil {
		return x.NumInactiveNodes
	}
	return 0
}

func (x *ClusterHealth) GetNumHealthyVolumes() uint32 {
	if x != nil {
		return x.NumHealthyVolumes
	}
	return 0
}

type Volume struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// State
	//
	// Indicates the current state of the volume in its creation/update/delete lifetime. It will reflect the state of execution of a user invoked API (CreateVolume, UpdateVolume..)
	// or an internal operation (Volume migration).
	State Volume_StateEnum `protobuf:"varint,1,opt,name=state,proto3,enum=lightbits.api.duros.v2.Volume_StateEnum" json:"state,omitempty"`
	// Protection state
	//
	// Indicates volume's data availability derived from the health of each of the replica's it resides on.
	ProtectionState ProtectionStateEnum `protobuf:"varint,2,opt,name=protectionState,proto3,enum=lightbits.api.duros.v2.ProtectionStateEnum" json:"protectionState,omitempty"`
	// replicaCount
	//
	// The number of replicas a volume can have. Valid values are 1, 2, and 3.
	ReplicaCount uint32 `protobuf:"varint,3,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	// nodeList
	//
	// List of node UUIDs this volume is placed over.
	NodeList []string `protobuf:"bytes,4,rep,name=nodeList,proto3" json:"nodeList,omitempty"`
	UUID     string   `protobuf:"bytes,5,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// NSID
	//
	// Volume's Namespace ID
	Nsid uint32 `protobuf:"varint,6,opt,name=nsid,proto3" json:"nsid,omitempty"`
	// acl
	//
	// Access control list of strings (host NQN). Valid values: list of strings/ALLOW_ANY/ALLOW_NONE
	Acl *StringList `protobuf:"bytes,7,opt,name=acl,proto3" json:"acl,omitempty"`
	// compression
	//
	// valid values: true/enable/enabled or false/disable/disabled
	Compression string `protobuf:"bytes,8,opt,name=compression,proto3" json:"compression,omitempty"`
	Size        uint64 `protobuf:"varint,9,opt,name=size,proto3" json:"size,omitempty"`
	// name
	//
	// A volume's name is unique at the project level. Name length must be between 1 and 253 characters and can contain any of: alphanumeric characters (a-z, A-Z, 0-9) ,hyphen (-), underscore (_) and period (.).
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// rebuildProgress
	//
	// Progress of the volume's replica rebuild operation in percent.
	RebuildProgress string `protobuf:"bytes,11,opt,name=rebuildProgress,proto3" json:"rebuildProgress,omitempty"`
	// statistics
	//
	// Volume statistics. Contains information about the physical used capacity, used memory, compression ratio, and more.
	Statistics *VolumeStatisticsApi `protobuf:"bytes,12,opt,name=statistics,proto3" json:"statistics,omitempty"`
	// IPAcl
	//
	// Access control list of IP addresses. Valid values: list of valid IP addresses/ALLOW_ANY/ALLOW_NONE (optional, default: ALLOW_ANY).
	IPAcl *StringList `protobuf:"bytes,13,opt,name=IPAcl,proto3" json:"IPAcl,omitempty"`
	// Etag
	//
	// Identifier for a specific version of a resource.
	ETag           string   `protobuf:"bytes,14,opt,name=ETag,proto3" json:"ETag,omitempty"`
	ConnectedHosts []string `protobuf:"bytes,15,rep,name=connectedHosts,proto3" json:"connectedHosts,omitempty"`
	// sectorSize
	//
	// Volume sector size. Valid values: 4K (default), 512B.
	SectorSize uint32 `protobuf:"varint,16,opt,name=sectorSize,proto3" json:"sectorSize,omitempty"`
	// projectName
	//
	// Project name.
	ProjectName string `protobuf:"bytes,17,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// sourceSnapshotUUID
	//
	// For a cloned volume, specify the source snapshot of this clone.
	SourceSnapshotUUID string `protobuf:"bytes,18,opt,name=sourceSnapshotUUID,proto3" json:"sourceSnapshotUUID,omitempty"`
	// sourceSnapshotName
	//
	// For a cloned volume, specify the source snapshot of this clone.
	SourceSnapshotName    string                  `protobuf:"bytes,19,opt,name=sourceSnapshotName,proto3" json:"sourceSnapshotName,omitempty"`
	PlacementRestrictions []*LabelMatchExpression `protobuf:"bytes,20,rep,name=placementRestrictions,proto3" json:"placementRestrictions,omitempty"`
	// qosPolicyUUID
	//
	// Optional volume's QoS policy UUID (if not specified the QoS policy defined in volume's project is used).
	QosPolicyUUID string `protobuf:"bytes,21,opt,name=qosPolicyUUID,proto3" json:"qosPolicyUUID,omitempty"`
	// qosPolicyName
	//
	// Optional volume's QoS policy name (if not specified the QoS policy defined in volume's project is used)
	QosPolicyName string `protobuf:"bytes,22,opt,name=qosPolicyName,proto3" json:"qosPolicyName,omitempty"`
	// primaryNodeUUID
	//
	// UUID of the primary node data is Read/Written for this volume.
	PrimaryNodeUUID string `protobuf:"bytes,23,opt,name=primaryNodeUUID,proto3" json:"primaryNodeUUID,omitempty"`
	// creationTime
	//
	// Time of volume creation (UTC).
	CreationTime *timestamppb.Timestamp `protobuf:"bytes,24,opt,name=creationTime,proto3" json:"creationTime,omitempty"`
	// labels
	//
	// Optionally add labels to a volume.
	Labels []*Label `protobuf:"bytes,25,rep,name=labels,proto3" json:"labels,omitempty"`
	// clusterId
	//
	// The ID of the cluster where the volume resides.
	ClusterId string `protobuf:"bytes,26,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	// PG UUID
	//
	// The Protection Group this volume is placed in.
	PgUUID        string `protobuf:"bytes,27,opt,name=pgUUID,proto3" json:"pgUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Volume) Reset() {
	*x = Volume{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[85]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Volume) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Volume) ProtoMessage() {}

func (x *Volume) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[85]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Volume.ProtoReflect.Descriptor instead.
func (*Volume) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{85}
}

func (x *Volume) GetState() Volume_StateEnum {
	if x != nil {
		return x.State
	}
	return Volume_Unknown
}

func (x *Volume) GetProtectionState() ProtectionStateEnum {
	if x != nil {
		return x.ProtectionState
	}
	return ProtectionStateEnum_Unknown
}

func (x *Volume) GetReplicaCount() uint32 {
	if x != nil {
		return x.ReplicaCount
	}
	return 0
}

func (x *Volume) GetNodeList() []string {
	if x != nil {
		return x.NodeList
	}
	return nil
}

func (x *Volume) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *Volume) GetNsid() uint32 {
	if x != nil {
		return x.Nsid
	}
	return 0
}

func (x *Volume) GetAcl() *StringList {
	if x != nil {
		return x.Acl
	}
	return nil
}

func (x *Volume) GetCompression() string {
	if x != nil {
		return x.Compression
	}
	return ""
}

func (x *Volume) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *Volume) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Volume) GetRebuildProgress() string {
	if x != nil {
		return x.RebuildProgress
	}
	return ""
}

func (x *Volume) GetStatistics() *VolumeStatisticsApi {
	if x != nil {
		return x.Statistics
	}
	return nil
}

func (x *Volume) GetIPAcl() *StringList {
	if x != nil {
		return x.IPAcl
	}
	return nil
}

func (x *Volume) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *Volume) GetConnectedHosts() []string {
	if x != nil {
		return x.ConnectedHosts
	}
	return nil
}

func (x *Volume) GetSectorSize() uint32 {
	if x != nil {
		return x.SectorSize
	}
	return 0
}

func (x *Volume) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *Volume) GetSourceSnapshotUUID() string {
	if x != nil {
		return x.SourceSnapshotUUID
	}
	return ""
}

func (x *Volume) GetSourceSnapshotName() string {
	if x != nil {
		return x.SourceSnapshotName
	}
	return ""
}

func (x *Volume) GetPlacementRestrictions() []*LabelMatchExpression {
	if x != nil {
		return x.PlacementRestrictions
	}
	return nil
}

func (x *Volume) GetQosPolicyUUID() string {
	if x != nil {
		return x.QosPolicyUUID
	}
	return ""
}

func (x *Volume) GetQosPolicyName() string {
	if x != nil {
		return x.QosPolicyName
	}
	return ""
}

func (x *Volume) GetPrimaryNodeUUID() string {
	if x != nil {
		return x.PrimaryNodeUUID
	}
	return ""
}

func (x *Volume) GetCreationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationTime
	}
	return nil
}

func (x *Volume) GetLabels() []*Label {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Volume) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *Volume) GetPgUUID() string {
	if x != nil {
		return x.PgUUID
	}
	return ""
}

type ServerEvictionStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// status
	//
	// The status of the eviction operation.
	Status ServerEvictionStatus_StatusEnum `protobuf:"varint,1,opt,name=status,proto3,enum=lightbits.api.duros.v2.ServerEvictionStatus_StatusEnum" json:"status,omitempty"`
	// startTime
	//
	// Start time of eviction operation.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=startTime,proto3" json:"startTime,omitempty"`
	// endTime
	//
	// Completion time of eviction operation (either a successfully completed or ended due to failure).
	EndTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=endTime,proto3" json:"endTime,omitempty"`
	// errorMessage
	//
	// Error message from the last eviction operation.
	ErrorMessage string `protobuf:"bytes,4,opt,name=errorMessage,proto3" json:"errorMessage,omitempty"`
	// progress
	//
	// Current eviction progress given in units of percent.
	Progress      uint32 `protobuf:"varint,5,opt,name=progress,proto3" json:"progress,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerEvictionStatus) Reset() {
	*x = ServerEvictionStatus{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[86]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerEvictionStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerEvictionStatus) ProtoMessage() {}

func (x *ServerEvictionStatus) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[86]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerEvictionStatus.ProtoReflect.Descriptor instead.
func (*ServerEvictionStatus) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{86}
}

func (x *ServerEvictionStatus) GetStatus() ServerEvictionStatus_StatusEnum {
	if x != nil {
		return x.Status
	}
	return ServerEvictionStatus_None
}

func (x *ServerEvictionStatus) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ServerEvictionStatus) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *ServerEvictionStatus) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *ServerEvictionStatus) GetProgress() uint32 {
	if x != nil {
		return x.Progress
	}
	return 0
}

type ServerLastUpgrade struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Status
	//
	// The status of the upgrade operation.
	Status ServerLastUpgrade_UpgradeStatusEnum `protobuf:"varint,1,opt,name=Status,proto3,enum=lightbits.api.duros.v2.ServerLastUpgrade_UpgradeStatusEnum" json:"Status,omitempty"`
	// StartTime
	//
	// The time of the upgrade task start.
	StartTime *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=StartTime,proto3" json:"StartTime,omitempty"`
	// EndTime
	//
	// The time of closing the upgrade task (completed or failed).
	EndTime *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=EndTime,proto3" json:"EndTime,omitempty"`
	// TargetVersion
	//
	// The version that should be installed by the end of the process.
	TargetVersion string `protobuf:"bytes,4,opt,name=TargetVersion,proto3" json:"TargetVersion,omitempty"`
	// ErrorMessage
	//
	// Last error message. Free text formatted string describes the problem.
	ErrorMessage string `protobuf:"bytes,5,opt,name=ErrorMessage,proto3" json:"ErrorMessage,omitempty"`
	// ProgressStep
	//
	// Current upgrade step. You can use ProgressTotal to calculate the percentage as ProgressStep/ProgressTotal.
	ProgressStep uint32 `protobuf:"varint,6,opt,name=ProgressStep,proto3" json:"ProgressStep,omitempty"`
	// ProgressTotal
	//
	// Total possible upgrade progress steps.
	ProgressTotal uint32 `protobuf:"varint,7,opt,name=ProgressTotal,proto3" json:"ProgressTotal,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ServerLastUpgrade) Reset() {
	*x = ServerLastUpgrade{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[87]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ServerLastUpgrade) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ServerLastUpgrade) ProtoMessage() {}

func (x *ServerLastUpgrade) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[87]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ServerLastUpgrade.ProtoReflect.Descriptor instead.
func (*ServerLastUpgrade) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{87}
}

func (x *ServerLastUpgrade) GetStatus() ServerLastUpgrade_UpgradeStatusEnum {
	if x != nil {
		return x.Status
	}
	return ServerLastUpgrade_Unknown
}

func (x *ServerLastUpgrade) GetStartTime() *timestamppb.Timestamp {
	if x != nil {
		return x.StartTime
	}
	return nil
}

func (x *ServerLastUpgrade) GetEndTime() *timestamppb.Timestamp {
	if x != nil {
		return x.EndTime
	}
	return nil
}

func (x *ServerLastUpgrade) GetTargetVersion() string {
	if x != nil {
		return x.TargetVersion
	}
	return ""
}

func (x *ServerLastUpgrade) GetErrorMessage() string {
	if x != nil {
		return x.ErrorMessage
	}
	return ""
}

func (x *ServerLastUpgrade) GetProgressStep() uint32 {
	if x != nil {
		return x.ProgressStep
	}
	return 0
}

func (x *ServerLastUpgrade) GetProgressTotal() uint32 {
	if x != nil {
		return x.ProgressTotal
	}
	return 0
}

type Server struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	UUID  string                 `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Name  string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// risk of service loss state
	//
	// Indicates the ability to upgrade or disable a server without loss of service to cluster volumes.
	RiskOfServiceLossState Server_RiskOfServiceLossEnum `protobuf:"varint,4,opt,name=RiskOfServiceLossState,proto3,enum=lightbits.api.duros.v2.Server_RiskOfServiceLossEnum" json:"RiskOfServiceLossState,omitempty"`
	NodesUUIDs             []string                     `protobuf:"bytes,5,rep,name=NodesUUIDs,proto3" json:"NodesUUIDs,omitempty"`
	State                  Server_ServerStateEnum       `protobuf:"varint,6,opt,name=state,proto3,enum=lightbits.api.duros.v2.Server_ServerStateEnum" json:"state,omitempty"`
	ServerEndpoints        []string                     `protobuf:"bytes,7,rep,name=ServerEndpoints,proto3" json:"ServerEndpoints,omitempty"`
	// Etag
	//
	// Identifier for a specific version of a resource.
	ETag string `protobuf:"bytes,8,opt,name=ETag,proto3" json:"ETag,omitempty"`
	// LightOSVersion
	//
	// The current Lightbits version.
	LightOSVersion string `protobuf:"bytes,9,opt,name=LightOSVersion,proto3" json:"LightOSVersion,omitempty"`
	// UpgradeStatus
	//
	// Deprecated: This field indicates the status of the upgrade operation.
	UpgradeStatus Server_UpgradeStatusEnum `protobuf:"varint,10,opt,name=UpgradeStatus,proto3,enum=lightbits.api.duros.v2.Server_UpgradeStatusEnum" json:"UpgradeStatus,omitempty"`
	// ApiEndpoints
	//
	// The API endpoints
	ApiEndpoints []string `protobuf:"bytes,11,rep,name=ApiEndpoints,proto3" json:"ApiEndpoints,omitempty"`
	// LastUpgrade
	//
	// Parameters of the last (or active) server upgrade process
	LastUpgrade *ServerLastUpgrade `protobuf:"bytes,12,opt,name=LastUpgrade,proto3" json:"LastUpgrade,omitempty"`
	// IsWitness
	IsWitness bool `protobuf:"varint,13,opt,name=IsWitness,proto3" json:"IsWitness,omitempty"`
	// LastEviction
	//
	// Parameters of the last (or active) server eviction process
	LastEviction *ServerEvictionStatus `protobuf:"bytes,14,opt,name=LastEviction,proto3" json:"LastEviction,omitempty"`
	// Server Health
	//
	// Server health: OK- server healthy, Warning high utilization or failed disk under rebuild, Error - Inactive nodes or nodes nearing/in Read-only.
	Health ClusterHealth_State `protobuf:"varint,15,opt,name=health,proto3,enum=lightbits.api.duros.v2.ClusterHealth_State" json:"health,omitempty"`
	// Server Permanent failure configuration
	//
	// Permanent failure timeout at the server level. If set, overrides the cluster configuration. Value of "0" sets it to infinite.
	ServerPermanenetFailureTimeout *durationpb.Duration `protobuf:"bytes,16,opt,name=ServerPermanenetFailureTimeout,proto3" json:"ServerPermanenetFailureTimeout,omitempty"`
	// TPM 2.0 Support
	//
	// Trusted Platform Module 2.0 (TPM) support indication.
	// Note: If information about a server's TPM2 support is unavailable,
	// we consider it as not supported.
	Tpm2IsSupported bool `protobuf:"varint,17,opt,name=tpm2IsSupported,proto3" json:"tpm2IsSupported,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *Server) Reset() {
	*x = Server{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[88]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Server) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Server) ProtoMessage() {}

func (x *Server) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[88]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Server.ProtoReflect.Descriptor instead.
func (*Server) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{88}
}

func (x *Server) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *Server) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Server) GetRiskOfServiceLossState() Server_RiskOfServiceLossEnum {
	if x != nil {
		return x.RiskOfServiceLossState
	}
	return Server_UnknownRiskOfServiceLoss
}

func (x *Server) GetNodesUUIDs() []string {
	if x != nil {
		return x.NodesUUIDs
	}
	return nil
}

func (x *Server) GetState() Server_ServerStateEnum {
	if x != nil {
		return x.State
	}
	return Server_UnknownState
}

func (x *Server) GetServerEndpoints() []string {
	if x != nil {
		return x.ServerEndpoints
	}
	return nil
}

func (x *Server) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *Server) GetLightOSVersion() string {
	if x != nil {
		return x.LightOSVersion
	}
	return ""
}

func (x *Server) GetUpgradeStatus() Server_UpgradeStatusEnum {
	if x != nil {
		return x.UpgradeStatus
	}
	return Server_Unknown
}

func (x *Server) GetApiEndpoints() []string {
	if x != nil {
		return x.ApiEndpoints
	}
	return nil
}

func (x *Server) GetLastUpgrade() *ServerLastUpgrade {
	if x != nil {
		return x.LastUpgrade
	}
	return nil
}

func (x *Server) GetIsWitness() bool {
	if x != nil {
		return x.IsWitness
	}
	return false
}

func (x *Server) GetLastEviction() *ServerEvictionStatus {
	if x != nil {
		return x.LastEviction
	}
	return nil
}

func (x *Server) GetHealth() ClusterHealth_State {
	if x != nil {
		return x.Health
	}
	return ClusterHealth_None
}

func (x *Server) GetServerPermanenetFailureTimeout() *durationpb.Duration {
	if x != nil {
		return x.ServerPermanenetFailureTimeout
	}
	return nil
}

func (x *Server) GetTpm2IsSupported() bool {
	if x != nil {
		return x.Tpm2IsSupported
	}
	return false
}

type GetRoleRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the role to get.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// projectName
	//
	// The name of the project this role belongs to.
	ProjectName   string `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRoleRequest) Reset() {
	*x = GetRoleRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[89]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRoleRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRoleRequest) ProtoMessage() {}

func (x *GetRoleRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[89]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRoleRequest.ProtoReflect.Descriptor instead.
func (*GetRoleRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{89}
}

func (x *GetRoleRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetRoleRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type GetRoleResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Role          *Role                  `protobuf:"bytes,1,opt,name=role,proto3" json:"role,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetRoleResponse) Reset() {
	*x = GetRoleResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[90]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetRoleResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetRoleResponse) ProtoMessage() {}

func (x *GetRoleResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[90]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetRoleResponse.ProtoReflect.Descriptor instead.
func (*GetRoleResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{90}
}

func (x *GetRoleResponse) GetRole() *Role {
	if x != nil {
		return x.Role
	}
	return nil
}

type Role struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	Name        string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	ProjectName string                 `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// rulesJson
	//
	// A JSON representation of the role 'rules' array, e.g.:
	//
	//	[{"resources":["versions"],"actions":["get"]}]
	RulesJson     string `protobuf:"bytes,4,opt,name=rulesJson,proto3" json:"rulesJson,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Role) Reset() {
	*x = Role{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[91]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Role) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Role) ProtoMessage() {}

func (x *Role) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[91]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Role.ProtoReflect.Descriptor instead.
func (*Role) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{91}
}

func (x *Role) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Role) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *Role) GetRulesJson() string {
	if x != nil {
		return x.RulesJson
	}
	return ""
}

type ListRolesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// projectName
	//
	// The name of the project to list roles for.
	ProjectName   string `protobuf:"bytes,1,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRolesRequest) Reset() {
	*x = ListRolesRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[92]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRolesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRolesRequest) ProtoMessage() {}

func (x *ListRolesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[92]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRolesRequest.ProtoReflect.Descriptor instead.
func (*ListRolesRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{92}
}

func (x *ListRolesRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type ListRolesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Roles         []*Role                `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListRolesResponse) Reset() {
	*x = ListRolesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[93]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListRolesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListRolesResponse) ProtoMessage() {}

func (x *ListRolesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[93]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListRolesResponse.ProtoReflect.Descriptor instead.
func (*ListRolesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{93}
}

func (x *ListRolesResponse) GetRoles() []*Role {
	if x != nil {
		return x.Roles
	}
	return nil
}

type Snapshot struct {
	state            protoimpl.MessageState `protogen:"open.v1"`
	State            Snapshot_StateEnum     `protobuf:"varint,1,opt,name=state,proto3,enum=lightbits.api.duros.v2.Snapshot_StateEnum" json:"state,omitempty"`
	UUID             string                 `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Name             string                 `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	Description      string                 `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	CreationTime     *timestamppb.Timestamp `protobuf:"bytes,5,opt,name=creationTime,proto3" json:"creationTime,omitempty"`
	RetentionTime    *durationpb.Duration   `protobuf:"bytes,6,opt,name=retentionTime,proto3" json:"retentionTime,omitempty"`
	SourceVolumeUUID string                 `protobuf:"bytes,7,opt,name=sourceVolumeUUID,proto3" json:"sourceVolumeUUID,omitempty"`
	SourceVolumeName string                 `protobuf:"bytes,8,opt,name=sourceVolumeName,proto3" json:"sourceVolumeName,omitempty"`
	ReplicaCount     uint32                 `protobuf:"varint,9,opt,name=replicaCount,proto3" json:"replicaCount,omitempty"`
	NodeList         []string               `protobuf:"bytes,10,rep,name=nodeList,proto3" json:"nodeList,omitempty"`
	Nsid             uint32                 `protobuf:"varint,11,opt,name=nsid,proto3" json:"nsid,omitempty"`
	Acl              *StringList            `protobuf:"bytes,12,opt,name=acl,proto3" json:"acl,omitempty"`
	Compression      bool                   `protobuf:"varint,13,opt,name=compression,proto3" json:"compression,omitempty"`
	Size             uint64                 `protobuf:"varint,14,opt,name=size,proto3" json:"size,omitempty"`
	IPAcl            *StringList            `protobuf:"bytes,15,opt,name=IPAcl,proto3" json:"IPAcl,omitempty"`
	SectorSize       uint32                 `protobuf:"varint,16,opt,name=sectorSize,proto3" json:"sectorSize,omitempty"`
	Statistics       *SnapshotStatisticsApi `protobuf:"bytes,18,opt,name=statistics,proto3" json:"statistics,omitempty"`
	ETag             string                 `protobuf:"bytes,19,opt,name=ETag,proto3" json:"ETag,omitempty"`
	ProjectName      string                 `protobuf:"bytes,20,opt,name=projectName,proto3" json:"projectName,omitempty"`
	PrimaryNodeUUID  string                 `protobuf:"bytes,21,opt,name=primaryNodeUUID,proto3" json:"primaryNodeUUID,omitempty"`
	// labels
	//
	// Once a snapshot is taken, the volume's labels are copied to the snapshot. Once a clone is created, if the user does not pass new labels on clone creation, the cloned volume labels are copied from the source snapshot labels.
	Labels []*Label `protobuf:"bytes,22,rep,name=labels,proto3" json:"labels,omitempty"`
	// clusterId
	//
	// The ID of the cluster where the snapshot resides.
	ClusterId string `protobuf:"bytes,23,opt,name=clusterId,proto3" json:"clusterId,omitempty"`
	// PG UUID
	//
	// The Protection Group this snapshot is placed in.
	PgUUID        string `protobuf:"bytes,24,opt,name=pgUUID,proto3" json:"pgUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Snapshot) Reset() {
	*x = Snapshot{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[94]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Snapshot) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Snapshot) ProtoMessage() {}

func (x *Snapshot) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[94]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Snapshot.ProtoReflect.Descriptor instead.
func (*Snapshot) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{94}
}

func (x *Snapshot) GetState() Snapshot_StateEnum {
	if x != nil {
		return x.State
	}
	return Snapshot_Unknown
}

func (x *Snapshot) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *Snapshot) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Snapshot) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Snapshot) GetCreationTime() *timestamppb.Timestamp {
	if x != nil {
		return x.CreationTime
	}
	return nil
}

func (x *Snapshot) GetRetentionTime() *durationpb.Duration {
	if x != nil {
		return x.RetentionTime
	}
	return nil
}

func (x *Snapshot) GetSourceVolumeUUID() string {
	if x != nil {
		return x.SourceVolumeUUID
	}
	return ""
}

func (x *Snapshot) GetSourceVolumeName() string {
	if x != nil {
		return x.SourceVolumeName
	}
	return ""
}

func (x *Snapshot) GetReplicaCount() uint32 {
	if x != nil {
		return x.ReplicaCount
	}
	return 0
}

func (x *Snapshot) GetNodeList() []string {
	if x != nil {
		return x.NodeList
	}
	return nil
}

func (x *Snapshot) GetNsid() uint32 {
	if x != nil {
		return x.Nsid
	}
	return 0
}

func (x *Snapshot) GetAcl() *StringList {
	if x != nil {
		return x.Acl
	}
	return nil
}

func (x *Snapshot) GetCompression() bool {
	if x != nil {
		return x.Compression
	}
	return false
}

func (x *Snapshot) GetSize() uint64 {
	if x != nil {
		return x.Size
	}
	return 0
}

func (x *Snapshot) GetIPAcl() *StringList {
	if x != nil {
		return x.IPAcl
	}
	return nil
}

func (x *Snapshot) GetSectorSize() uint32 {
	if x != nil {
		return x.SectorSize
	}
	return 0
}

func (x *Snapshot) GetStatistics() *SnapshotStatisticsApi {
	if x != nil {
		return x.Statistics
	}
	return nil
}

func (x *Snapshot) GetETag() string {
	if x != nil {
		return x.ETag
	}
	return ""
}

func (x *Snapshot) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *Snapshot) GetPrimaryNodeUUID() string {
	if x != nil {
		return x.PrimaryNodeUUID
	}
	return ""
}

func (x *Snapshot) GetLabels() []*Label {
	if x != nil {
		return x.Labels
	}
	return nil
}

func (x *Snapshot) GetClusterId() string {
	if x != nil {
		return x.ClusterId
	}
	return ""
}

func (x *Snapshot) GetPgUUID() string {
	if x != nil {
		return x.PgUUID
	}
	return ""
}

type DeleteSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The UUID of the snapshot to delete (specify either UUID or Name).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// The name of the snapshot to delete (specify either UUID or Name).
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// projectName
	//
	// The name of the project this snapshot belongs to.
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteSnapshotRequest) Reset() {
	*x = DeleteSnapshotRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[95]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSnapshotRequest) ProtoMessage() {}

func (x *DeleteSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[95]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSnapshotRequest.ProtoReflect.Descriptor instead.
func (*DeleteSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{95}
}

func (x *DeleteSnapshotRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DeleteSnapshotRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *DeleteSnapshotRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type CreateSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the snapshot
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// sourceVolumeUUID
	//
	// The UUID of the volume to create the snapshot from.
	// You should specify either the UUID or the name.
	// If both UUID and name are specified, the UUID takes precedence.
	SourceVolumeUUID string `protobuf:"bytes,2,opt,name=sourceVolumeUUID,proto3" json:"sourceVolumeUUID,omitempty"`
	// sourceVolumeName
	//
	// The name of the volume to create the snapshot from.
	// You should specify either the UUID or the name.
	// If both UUID and name are specified, the UUID takes precedence.
	SourceVolumeName string `protobuf:"bytes,3,opt,name=sourceVolumeName,proto3" json:"sourceVolumeName,omitempty"`
	// retentionTime
	//
	// The length of time in seconds to retain this snapshot for.
	RetentionTime *durationpb.Duration `protobuf:"bytes,4,opt,name=retentionTime,proto3" json:"retentionTime,omitempty"`
	// description
	//
	// A short description (up to 256B) of the snapshot.
	Description string `protobuf:"bytes,5,opt,name=description,proto3" json:"description,omitempty"`
	// projectName
	//
	// The name of the project this snapshot belongs to
	ProjectName   string `protobuf:"bytes,6,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateSnapshotRequest) Reset() {
	*x = CreateSnapshotRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[96]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateSnapshotRequest) ProtoMessage() {}

func (x *CreateSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[96]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateSnapshotRequest.ProtoReflect.Descriptor instead.
func (*CreateSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{96}
}

func (x *CreateSnapshotRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateSnapshotRequest) GetSourceVolumeUUID() string {
	if x != nil {
		return x.SourceVolumeUUID
	}
	return ""
}

func (x *CreateSnapshotRequest) GetSourceVolumeName() string {
	if x != nil {
		return x.SourceVolumeName
	}
	return ""
}

func (x *CreateSnapshotRequest) GetRetentionTime() *durationpb.Duration {
	if x != nil {
		return x.RetentionTime
	}
	return nil
}

func (x *CreateSnapshotRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CreateSnapshotRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type ListSnapshotsRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Optionally filter a specific snapshot by UUID.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Name
	//
	// Optionally filter a specific snapshot by name.
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// projectName
	//
	// The name of the project this snapshot belongs to.
	ProjectName string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// offsetUUID
	//
	// Optional. When provided, returned list starts with next to offsetUUID snapshot.
	OffsetUUID string `protobuf:"bytes,4,opt,name=offsetUUID,proto3" json:"offsetUUID,omitempty"`
	// limit
	//
	// Optional. Limits the number of snapshots in the response (default/max is 1000 snapshots in a response).
	Limit int64 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
	// showAll
	//
	// Optional. Show also snapshots in Deleting state (the default is false).
	ShowAll       bool `protobuf:"varint,6,opt,name=showAll,proto3" json:"showAll,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSnapshotsRequest) Reset() {
	*x = ListSnapshotsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[97]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSnapshotsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSnapshotsRequest) ProtoMessage() {}

func (x *ListSnapshotsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[97]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSnapshotsRequest.ProtoReflect.Descriptor instead.
func (*ListSnapshotsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{97}
}

func (x *ListSnapshotsRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ListSnapshotsRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListSnapshotsRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *ListSnapshotsRequest) GetOffsetUUID() string {
	if x != nil {
		return x.OffsetUUID
	}
	return ""
}

func (x *ListSnapshotsRequest) GetLimit() int64 {
	if x != nil {
		return x.Limit
	}
	return 0
}

func (x *ListSnapshotsRequest) GetShowAll() bool {
	if x != nil {
		return x.ShowAll
	}
	return false
}

type GetSnapshotRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	//	The UUID of the snapshot to get (either UUID or Name must be specified).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Name
	//
	// The name of the snapshot to get (either UUID or Name must be specified).
	Name string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	// projectName
	//
	// The name of the project this snapshot belongs to.
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetSnapshotRequest) Reset() {
	*x = GetSnapshotRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[98]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetSnapshotRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetSnapshotRequest) ProtoMessage() {}

func (x *GetSnapshotRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[98]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetSnapshotRequest.ProtoReflect.Descriptor instead.
func (*GetSnapshotRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{98}
}

func (x *GetSnapshotRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *GetSnapshotRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetSnapshotRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type ListSnapshotsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Snapshots     []*Snapshot            `protobuf:"bytes,1,rep,name=snapshots,proto3" json:"snapshots,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListSnapshotsResponse) Reset() {
	*x = ListSnapshotsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[99]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListSnapshotsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListSnapshotsResponse) ProtoMessage() {}

func (x *ListSnapshotsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[99]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListSnapshotsResponse.ProtoReflect.Descriptor instead.
func (*ListSnapshotsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{99}
}

func (x *ListSnapshotsResponse) GetSnapshots() []*Snapshot {
	if x != nil {
		return x.Snapshots
	}
	return nil
}

type DeleteSnapshotResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteSnapshotResponse) Reset() {
	*x = DeleteSnapshotResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[100]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteSnapshotResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteSnapshotResponse) ProtoMessage() {}

func (x *DeleteSnapshotResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[100]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteSnapshotResponse.ProtoReflect.Descriptor instead.
func (*DeleteSnapshotResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{100}
}

type FeatureFlagStatus struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Name          string                 `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Enabled       bool                   `protobuf:"varint,2,opt,name=enabled,proto3" json:"enabled,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *FeatureFlagStatus) Reset() {
	*x = FeatureFlagStatus{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[101]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FeatureFlagStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FeatureFlagStatus) ProtoMessage() {}

func (x *FeatureFlagStatus) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[101]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FeatureFlagStatus.ProtoReflect.Descriptor instead.
func (*FeatureFlagStatus) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{101}
}

func (x *FeatureFlagStatus) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *FeatureFlagStatus) GetEnabled() bool {
	if x != nil {
		return x.Enabled
	}
	return false
}

type GetFeatureFlagRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the feature flag to get:  "event-log", "evict-data", "fail-in-place", "in-band-authentication", "proactive-rebalance".
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetFeatureFlagRequest) Reset() {
	*x = GetFeatureFlagRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[102]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFeatureFlagRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFeatureFlagRequest) ProtoMessage() {}

func (x *GetFeatureFlagRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[102]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFeatureFlagRequest.ProtoReflect.Descriptor instead.
func (*GetFeatureFlagRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{102}
}

func (x *GetFeatureFlagRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type EnableFeatureFlagRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the feature flag to enable:  "event-log", "evict-data", "fail-in-place", "in-band-authentication", "proactive-rebalance".
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnableFeatureFlagRequest) Reset() {
	*x = EnableFeatureFlagRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[103]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnableFeatureFlagRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnableFeatureFlagRequest) ProtoMessage() {}

func (x *EnableFeatureFlagRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[103]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnableFeatureFlagRequest.ProtoReflect.Descriptor instead.
func (*EnableFeatureFlagRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{103}
}

func (x *EnableFeatureFlagRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DisableFeatureFlagRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the feature flag to disable:  "event-log", "evict-data", "fail-in-place", "in-band-authentication", "proactive-rebalance".
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisableFeatureFlagRequest) Reset() {
	*x = DisableFeatureFlagRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[104]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisableFeatureFlagRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisableFeatureFlagRequest) ProtoMessage() {}

func (x *DisableFeatureFlagRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[104]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisableFeatureFlagRequest.ProtoReflect.Descriptor instead.
func (*DisableFeatureFlagRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{104}
}

func (x *DisableFeatureFlagRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type SetFeatureFlagResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *SetFeatureFlagResponse) Reset() {
	*x = SetFeatureFlagResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[105]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *SetFeatureFlagResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*SetFeatureFlagResponse) ProtoMessage() {}

func (x *SetFeatureFlagResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[105]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use SetFeatureFlagResponse.ProtoReflect.Descriptor instead.
func (*SetFeatureFlagResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{105}
}

type ListFeatureFlagsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFeatureFlagsRequest) Reset() {
	*x = ListFeatureFlagsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[106]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFeatureFlagsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFeatureFlagsRequest) ProtoMessage() {}

func (x *ListFeatureFlagsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[106]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFeatureFlagsRequest.ProtoReflect.Descriptor instead.
func (*ListFeatureFlagsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{106}
}

type ListFeatureFlagsResponse struct {
	state         protoimpl.MessageState        `protogen:"open.v1"`
	FeatureFlags  map[string]*FeatureFlagStatus `protobuf:"bytes,1,rep,name=featureFlags,proto3" json:"featureFlags,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListFeatureFlagsResponse) Reset() {
	*x = ListFeatureFlagsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[107]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListFeatureFlagsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListFeatureFlagsResponse) ProtoMessage() {}

func (x *ListFeatureFlagsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[107]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListFeatureFlagsResponse.ProtoReflect.Descriptor instead.
func (*ListFeatureFlagsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{107}
}

func (x *ListFeatureFlagsResponse) GetFeatureFlags() map[string]*FeatureFlagStatus {
	if x != nil {
		return x.FeatureFlags
	}
	return nil
}

type CreateResourcePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the resource policy.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// resourceUUID
	//
	// The resource UUID. If both name and UUID are provided, the name
	// is ignored and only the UUID is used.
	ResourceUUID string `protobuf:"bytes,2,opt,name=resourceUUID,proto3" json:"resourceUUID,omitempty"`
	// resourceName
	//
	// The resource name. If both name and UUID are provided, the name
	// is ignored and only the UUID is used.
	ResourceName string `protobuf:"bytes,3,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
	// projectName
	//
	// The project this resource policy belongs to.
	ProjectName string `protobuf:"bytes,4,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// schedulePolicy
	//
	// The schedule policy for this resource policy.
	SchedulePolicy *SchedulePolicy `protobuf:"bytes,5,opt,name=schedulePolicy,proto3" json:"schedulePolicy,omitempty"`
	// description
	//
	// A short (up to 256B) description for this resource.
	Description   string `protobuf:"bytes,6,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateResourcePolicyRequest) Reset() {
	*x = CreateResourcePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[108]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateResourcePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateResourcePolicyRequest) ProtoMessage() {}

func (x *CreateResourcePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[108]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateResourcePolicyRequest.ProtoReflect.Descriptor instead.
func (*CreateResourcePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{108}
}

func (x *CreateResourcePolicyRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateResourcePolicyRequest) GetResourceUUID() string {
	if x != nil {
		return x.ResourceUUID
	}
	return ""
}

func (x *CreateResourcePolicyRequest) GetResourceName() string {
	if x != nil {
		return x.ResourceName
	}
	return ""
}

func (x *CreateResourcePolicyRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *CreateResourcePolicyRequest) GetSchedulePolicy() *SchedulePolicy {
	if x != nil {
		return x.SchedulePolicy
	}
	return nil
}

func (x *CreateResourcePolicyRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type CreatePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Policy name
	//
	// Policy name
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Policy description
	//
	// Policy description, up to 256B in length
	Description string `protobuf:"bytes,2,opt,name=description,proto3" json:"description,omitempty"`
	// The policy
	//
	// # Details of the policy to create
	//
	// Types that are valid to be assigned to Policy:
	//
	//	*CreatePolicyRequest_QoSRateLimitPolicy
	Policy        isCreatePolicyRequest_Policy `protobuf_oneof:"policy"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreatePolicyRequest) Reset() {
	*x = CreatePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[109]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreatePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreatePolicyRequest) ProtoMessage() {}

func (x *CreatePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[109]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreatePolicyRequest.ProtoReflect.Descriptor instead.
func (*CreatePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{109}
}

func (x *CreatePolicyRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreatePolicyRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *CreatePolicyRequest) GetPolicy() isCreatePolicyRequest_Policy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *CreatePolicyRequest) GetQoSRateLimitPolicy() *QoSRateLimitPolicy {
	if x != nil {
		if x, ok := x.Policy.(*CreatePolicyRequest_QoSRateLimitPolicy); ok {
			return x.QoSRateLimitPolicy
		}
	}
	return nil
}

type isCreatePolicyRequest_Policy interface {
	isCreatePolicyRequest_Policy()
}

type CreatePolicyRequest_QoSRateLimitPolicy struct {
	QoSRateLimitPolicy *QoSRateLimitPolicy `protobuf:"bytes,3,opt,name=qoSRateLimitPolicy,proto3,oneof"` // in the future we will move here schedule policy as well as other policies.
}

func (*CreatePolicyRequest_QoSRateLimitPolicy) isCreatePolicyRequest_Policy() {}

type UpdatePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The UUID of the policy request to update. If both name and UUID are provided,
	// the name is ignored.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// The name of the policy request to update. If both name and UUID are provided,
	// the name is ignored.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// description
	//
	// A short (up to 256B) description for this resource.
	Description string `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	// policy
	//
	// # At the moment, this can only be the QoSRateLimitPolicy to be updated
	//
	// Types that are valid to be assigned to Policy:
	//
	//	*UpdatePolicyRequest_QoSRateLimitPolicy
	Policy        isUpdatePolicyRequest_Policy `protobuf_oneof:"policy"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdatePolicyRequest) Reset() {
	*x = UpdatePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[110]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdatePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdatePolicyRequest) ProtoMessage() {}

func (x *UpdatePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[110]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdatePolicyRequest.ProtoReflect.Descriptor instead.
func (*UpdatePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{110}
}

func (x *UpdatePolicyRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *UpdatePolicyRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdatePolicyRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *UpdatePolicyRequest) GetPolicy() isUpdatePolicyRequest_Policy {
	if x != nil {
		return x.Policy
	}
	return nil
}

func (x *UpdatePolicyRequest) GetQoSRateLimitPolicy() *QoSRateLimitPolicy {
	if x != nil {
		if x, ok := x.Policy.(*UpdatePolicyRequest_QoSRateLimitPolicy); ok {
			return x.QoSRateLimitPolicy
		}
	}
	return nil
}

type isUpdatePolicyRequest_Policy interface {
	isUpdatePolicyRequest_Policy()
}

type UpdatePolicyRequest_QoSRateLimitPolicy struct {
	QoSRateLimitPolicy *QoSRateLimitPolicy `protobuf:"bytes,4,opt,name=qoSRateLimitPolicy,proto3,oneof"` // in the future we will move here schedule policy as well as other policies.
}

func (*UpdatePolicyRequest_QoSRateLimitPolicy) isUpdatePolicyRequest_Policy() {}

type UpdatePolicyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdatePolicyResponse) Reset() {
	*x = UpdatePolicyResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[111]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdatePolicyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdatePolicyResponse) ProtoMessage() {}

func (x *UpdatePolicyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[111]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdatePolicyResponse.ProtoReflect.Descriptor instead.
func (*UpdatePolicyResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{111}
}

type ResourcePolicy struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	UUID           string                 `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Name           string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	ResourceUUID   string                 `protobuf:"bytes,3,opt,name=resourceUUID,proto3" json:"resourceUUID,omitempty"`
	ResourceName   string                 `protobuf:"bytes,4,opt,name=resourceName,proto3" json:"resourceName,omitempty"`
	ProjectName    string                 `protobuf:"bytes,5,opt,name=projectName,proto3" json:"projectName,omitempty"`
	SchedulePolicy *SchedulePolicy        `protobuf:"bytes,6,opt,name=schedulePolicy,proto3" json:"schedulePolicy,omitempty"`
	Description    string                 `protobuf:"bytes,7,opt,name=description,proto3" json:"description,omitempty"`
	State          ResourcePolicy_State   `protobuf:"varint,8,opt,name=state,proto3,enum=lightbits.api.duros.v2.ResourcePolicy_State" json:"state,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ResourcePolicy) Reset() {
	*x = ResourcePolicy{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[112]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ResourcePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ResourcePolicy) ProtoMessage() {}

func (x *ResourcePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[112]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ResourcePolicy.ProtoReflect.Descriptor instead.
func (*ResourcePolicy) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{112}
}

func (x *ResourcePolicy) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ResourcePolicy) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ResourcePolicy) GetResourceUUID() string {
	if x != nil {
		return x.ResourceUUID
	}
	return ""
}

func (x *ResourcePolicy) GetResourceName() string {
	if x != nil {
		return x.ResourceName
	}
	return ""
}

func (x *ResourcePolicy) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *ResourcePolicy) GetSchedulePolicy() *SchedulePolicy {
	if x != nil {
		return x.SchedulePolicy
	}
	return nil
}

func (x *ResourcePolicy) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *ResourcePolicy) GetState() ResourcePolicy_State {
	if x != nil {
		return x.State
	}
	return ResourcePolicy_UnknownState
}

type Policy struct {
	state       protoimpl.MessageState `protogen:"open.v1"`
	UUID        string                 `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	Name        string                 `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Description string                 `protobuf:"bytes,3,opt,name=description,proto3" json:"description,omitempty"`
	State       Policy_State           `protobuf:"varint,4,opt,name=state,proto3,enum=lightbits.api.duros.v2.Policy_State" json:"state,omitempty"`
	// Types that are valid to be assigned to Info:
	//
	//	*Policy_QoSRateLimitPolicy
	Info          isPolicy_Info `protobuf_oneof:"info"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Policy) Reset() {
	*x = Policy{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[113]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Policy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Policy) ProtoMessage() {}

func (x *Policy) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[113]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Policy.ProtoReflect.Descriptor instead.
func (*Policy) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{113}
}

func (x *Policy) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *Policy) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *Policy) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Policy) GetState() Policy_State {
	if x != nil {
		return x.State
	}
	return Policy_Unknown
}

func (x *Policy) GetInfo() isPolicy_Info {
	if x != nil {
		return x.Info
	}
	return nil
}

func (x *Policy) GetQoSRateLimitPolicy() *QoSRateLimitPolicy {
	if x != nil {
		if x, ok := x.Info.(*Policy_QoSRateLimitPolicy); ok {
			return x.QoSRateLimitPolicy
		}
	}
	return nil
}

type isPolicy_Info interface {
	isPolicy_Info()
}

type Policy_QoSRateLimitPolicy struct {
	QoSRateLimitPolicy *QoSRateLimitPolicy `protobuf:"bytes,5,opt,name=QoSRateLimitPolicy,proto3,oneof"`
}

func (*Policy_QoSRateLimitPolicy) isPolicy_Info() {}

type UpdateResourcePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The UUID of the resource policy request to update.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// projectName
	//
	// The name of the project this resource policy request belongs to.
	ProjectName string `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// schedulePolicy
	//
	// The updated schedule policy.
	SchedulePolicy *SchedulePolicy `protobuf:"bytes,3,opt,name=schedulePolicy,proto3" json:"schedulePolicy,omitempty"`
	// description
	//
	// An updated short (up to 256B) description.
	Description   string `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateResourcePolicyRequest) Reset() {
	*x = UpdateResourcePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[114]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateResourcePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateResourcePolicyRequest) ProtoMessage() {}

func (x *UpdateResourcePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[114]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateResourcePolicyRequest.ProtoReflect.Descriptor instead.
func (*UpdateResourcePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{114}
}

func (x *UpdateResourcePolicyRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *UpdateResourcePolicyRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *UpdateResourcePolicyRequest) GetSchedulePolicy() *SchedulePolicy {
	if x != nil {
		return x.SchedulePolicy
	}
	return nil
}

func (x *UpdateResourcePolicyRequest) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

type UpdateResourcePolicyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateResourcePolicyResponse) Reset() {
	*x = UpdateResourcePolicyResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[115]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateResourcePolicyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateResourcePolicyResponse) ProtoMessage() {}

func (x *UpdateResourcePolicyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[115]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateResourcePolicyResponse.ProtoReflect.Descriptor instead.
func (*UpdateResourcePolicyResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{115}
}

type ListPoliciesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Optionally filter specific policy by UUID.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// Optionally filter specific policy by name.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// projectName
	//
	// Optionally filter policies by project name.
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPoliciesRequest) Reset() {
	*x = ListPoliciesRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[116]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPoliciesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPoliciesRequest) ProtoMessage() {}

func (x *ListPoliciesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[116]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPoliciesRequest.ProtoReflect.Descriptor instead.
func (*ListPoliciesRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{116}
}

func (x *ListPoliciesRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ListPoliciesRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ListPoliciesRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type ListPoliciesResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Policies      []*Policy              `protobuf:"bytes,1,rep,name=policies,proto3" json:"policies,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListPoliciesResponse) Reset() {
	*x = ListPoliciesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[117]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListPoliciesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListPoliciesResponse) ProtoMessage() {}

func (x *ListPoliciesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[117]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListPoliciesResponse.ProtoReflect.Descriptor instead.
func (*ListPoliciesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{117}
}

func (x *ListPoliciesResponse) GetPolicies() []*Policy {
	if x != nil {
		return x.Policies
	}
	return nil
}

type ListResourcePoliciesRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Optionally filter specific policy by UUID.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// projectName
	//
	// Optionally filter policies by project name.
	ProjectName string `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// volumeUUID
	//
	// Optionally filter all policies of a specific volume.
	VolumeUUID    string `protobuf:"bytes,3,opt,name=volumeUUID,proto3" json:"volumeUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListResourcePoliciesRequest) Reset() {
	*x = ListResourcePoliciesRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[118]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListResourcePoliciesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListResourcePoliciesRequest) ProtoMessage() {}

func (x *ListResourcePoliciesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[118]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListResourcePoliciesRequest.ProtoReflect.Descriptor instead.
func (*ListResourcePoliciesRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{118}
}

func (x *ListResourcePoliciesRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *ListResourcePoliciesRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *ListResourcePoliciesRequest) GetVolumeUUID() string {
	if x != nil {
		return x.VolumeUUID
	}
	return ""
}

type ListResourcePoliciesResponse struct {
	state                   protoimpl.MessageState         `protogen:"open.v1"`
	ResourcePolicies        []*ResourcePolicy              `protobuf:"bytes,1,rep,name=resourcePolicies,proto3" json:"resourcePolicies,omitempty"`
	DefaultResourcePolicies []*DefaultGlobalResourcePolicy `protobuf:"bytes,2,rep,name=defaultResourcePolicies,proto3" json:"defaultResourcePolicies,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ListResourcePoliciesResponse) Reset() {
	*x = ListResourcePoliciesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[119]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListResourcePoliciesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListResourcePoliciesResponse) ProtoMessage() {}

func (x *ListResourcePoliciesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[119]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListResourcePoliciesResponse.ProtoReflect.Descriptor instead.
func (*ListResourcePoliciesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{119}
}

func (x *ListResourcePoliciesResponse) GetResourcePolicies() []*ResourcePolicy {
	if x != nil {
		return x.ResourcePolicies
	}
	return nil
}

func (x *ListResourcePoliciesResponse) GetDefaultResourcePolicies() []*DefaultGlobalResourcePolicy {
	if x != nil {
		return x.DefaultResourcePolicies
	}
	return nil
}

type GetPolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// UUID of the policy to get (specify either UUID or name)
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// name of the policy to get (specify either UUID or name)
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// projectName
	//
	// The name of the project this policy belongs to
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetPolicyRequest) Reset() {
	*x = GetPolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[120]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetPolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetPolicyRequest) ProtoMessage() {}

func (x *GetPolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[120]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetPolicyRequest.ProtoReflect.Descriptor instead.
func (*GetPolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{120}
}

func (x *GetPolicyRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *GetPolicyRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *GetPolicyRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type GetResourcePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The UUID of the resource policy to get.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// projectName
	//
	// The name of the project this resource policy belongs to.
	ProjectName   string `protobuf:"bytes,2,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetResourcePolicyRequest) Reset() {
	*x = GetResourcePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[121]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetResourcePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetResourcePolicyRequest) ProtoMessage() {}

func (x *GetResourcePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[121]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetResourcePolicyRequest.ProtoReflect.Descriptor instead.
func (*GetResourcePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{121}
}

func (x *GetResourcePolicyRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *GetResourcePolicyRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type DeleteResourcePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// The UUID of the resource policy to get.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// projectName
	//
	// The name of the project this resource policy belongs to.
	ProjectName   string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResourcePolicyRequest) Reset() {
	*x = DeleteResourcePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[122]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResourcePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResourcePolicyRequest) ProtoMessage() {}

func (x *DeleteResourcePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[122]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResourcePolicyRequest.ProtoReflect.Descriptor instead.
func (*DeleteResourcePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{122}
}

func (x *DeleteResourcePolicyRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DeleteResourcePolicyRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

type DeleteResourcePolicyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteResourcePolicyResponse) Reset() {
	*x = DeleteResourcePolicyResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[123]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteResourcePolicyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteResourcePolicyResponse) ProtoMessage() {}

func (x *DeleteResourcePolicyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[123]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteResourcePolicyResponse.ProtoReflect.Descriptor instead.
func (*DeleteResourcePolicyResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{123}
}

type DeletePolicyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// UUID of the policy to delete (specify either UUID or name).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// name
	//
	// name of the policy to delete (specify either UUID or name).
	Name          string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeletePolicyRequest) Reset() {
	*x = DeletePolicyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[124]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeletePolicyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeletePolicyRequest) ProtoMessage() {}

func (x *DeletePolicyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[124]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeletePolicyRequest.ProtoReflect.Descriptor instead.
func (*DeletePolicyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{124}
}

func (x *DeletePolicyRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *DeletePolicyRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DeletePolicyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeletePolicyResponse) Reset() {
	*x = DeletePolicyResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[125]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeletePolicyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeletePolicyResponse) ProtoMessage() {}

func (x *DeletePolicyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[125]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeletePolicyResponse.ProtoReflect.Descriptor instead.
func (*DeletePolicyResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{125}
}

type GetClusterConfigParamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// specify name of parameter to get: ClusterName/ ClockDriftIntervalForRaisingEvent/ DeviceHealthIntervalForRaisingEvent/
	// DurationToTurnIntoPermanentFailure/ VolumeDeletionFromNodeDelay/ DefaultQoSName/ AllowedNumRevives/ DisableVolumeStatisticsExport
	// EnableTrim/ EvictionNoProgressTimeout/ RevivesWindowDuration
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterConfigParamRequest) Reset() {
	*x = GetClusterConfigParamRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[126]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterConfigParamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterConfigParamRequest) ProtoMessage() {}

func (x *GetClusterConfigParamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[126]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterConfigParamRequest.ProtoReflect.Descriptor instead.
func (*GetClusterConfigParamRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{126}
}

func (x *GetClusterConfigParamRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ClusterConfigParam struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// ClusterConfigParam name
	//
	// Specify the name of the parameter to update: ClusterName [name]/ ClockDriftIntervalForRaisingEvent [time]/ DeviceHealthIntervalForRaisingEvent [time]/
	// DurationToTurnIntoPermanentFailure [time]/ VolumeDeletionFromNodeDelay [time]/ DefaultQoSName [string]/ AllowedNumRevives [int]
	// DisableVolumeStatisticsExport [bool]/ EnableTrim [bool]/ EvictionNoProgressTimeout [time]/ RevivesWindowDuration [time].
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// ClusterConfigParam value
	//
	// The value of the cluster config parameter, where the specific units are specific to the specified parameter.
	Value         string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterConfigParam) Reset() {
	*x = ClusterConfigParam{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[127]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterConfigParam) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterConfigParam) ProtoMessage() {}

func (x *ClusterConfigParam) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[127]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterConfigParam.ProtoReflect.Descriptor instead.
func (*ClusterConfigParam) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{127}
}

func (x *ClusterConfigParam) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *ClusterConfigParam) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type UpdateClusterConfigParamRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// configParam
	//
	// Cluster config parameter name and value to update.
	ConfigParam   *ClusterConfigParam `protobuf:"bytes,1,opt,name=configParam,proto3" json:"configParam,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateClusterConfigParamRequest) Reset() {
	*x = UpdateClusterConfigParamRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[128]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateClusterConfigParamRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateClusterConfigParamRequest) ProtoMessage() {}

func (x *UpdateClusterConfigParamRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[128]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateClusterConfigParamRequest.ProtoReflect.Descriptor instead.
func (*UpdateClusterConfigParamRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{128}
}

func (x *UpdateClusterConfigParamRequest) GetConfigParam() *ClusterConfigParam {
	if x != nil {
		return x.ConfigParam
	}
	return nil
}

type RollbackVolumeRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// UUID
	//
	// Volume UUID to rollback (specify either volume UUID or volume name).
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// srcSnapshotUUID
	//
	// Source snapshot UUID to rollback volume to (specify either snapshot UUID or volume name).
	SrcSnapshotUUID string `protobuf:"bytes,2,opt,name=srcSnapshotUUID,proto3" json:"srcSnapshotUUID,omitempty"`
	// projectName
	//
	// Project volume belongs to.
	ProjectName string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// Name
	//
	// Volume Name (specify either volume UUID or volume name).
	Name string `protobuf:"bytes,4,opt,name=Name,proto3" json:"Name,omitempty"`
	// srcSnapshotName
	//
	// Source snapshot name to rollback volume to (specify either snapshot UUID or volume name).
	SrcSnapshotName string `protobuf:"bytes,5,opt,name=srcSnapshotName,proto3" json:"srcSnapshotName,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *RollbackVolumeRequest) Reset() {
	*x = RollbackVolumeRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[129]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RollbackVolumeRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RollbackVolumeRequest) ProtoMessage() {}

func (x *RollbackVolumeRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[129]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RollbackVolumeRequest.ProtoReflect.Descriptor instead.
func (*RollbackVolumeRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{129}
}

func (x *RollbackVolumeRequest) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *RollbackVolumeRequest) GetSrcSnapshotUUID() string {
	if x != nil {
		return x.SrcSnapshotUUID
	}
	return ""
}

func (x *RollbackVolumeRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *RollbackVolumeRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *RollbackVolumeRequest) GetSrcSnapshotName() string {
	if x != nil {
		return x.SrcSnapshotName
	}
	return ""
}

type RollbackVolumeResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RollbackVolumeResponse) Reset() {
	*x = RollbackVolumeResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[130]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RollbackVolumeResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RollbackVolumeResponse) ProtoMessage() {}

func (x *RollbackVolumeResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[130]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RollbackVolumeResponse.ProtoReflect.Descriptor instead.
func (*RollbackVolumeResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{130}
}

type UpdateClusterConfigParamResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateClusterConfigParamResponse) Reset() {
	*x = UpdateClusterConfigParamResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[131]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateClusterConfigParamResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateClusterConfigParamResponse) ProtoMessage() {}

func (x *UpdateClusterConfigParamResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[131]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateClusterConfigParamResponse.ProtoReflect.Descriptor instead.
func (*UpdateClusterConfigParamResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{131}
}

type ListClusterConfigParamsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClusterConfigParamsRequest) Reset() {
	*x = ListClusterConfigParamsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[132]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClusterConfigParamsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClusterConfigParamsRequest) ProtoMessage() {}

func (x *ListClusterConfigParamsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[132]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClusterConfigParamsRequest.ProtoReflect.Descriptor instead.
func (*ListClusterConfigParamsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{132}
}

type ListClusterConfigParamsResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Values        []*ClusterConfigParam  `protobuf:"bytes,1,rep,name=values,proto3" json:"values,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListClusterConfigParamsResponse) Reset() {
	*x = ListClusterConfigParamsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[133]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListClusterConfigParamsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListClusterConfigParamsResponse) ProtoMessage() {}

func (x *ListClusterConfigParamsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[133]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListClusterConfigParamsResponse.ProtoReflect.Descriptor instead.
func (*ListClusterConfigParamsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{133}
}

func (x *ListClusterConfigParamsResponse) GetValues() []*ClusterConfigParam {
	if x != nil {
		return x.Values
	}
	return nil
}

type LabelValueKeyPair struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	Key           LabelValueKeyPair_Key  `protobuf:"varint,1,opt,name=key,proto3,enum=lightbits.api.duros.v2.LabelValueKeyPair_Key" json:"key,omitempty"`
	Value         string                 `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LabelValueKeyPair) Reset() {
	*x = LabelValueKeyPair{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[134]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LabelValueKeyPair) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LabelValueKeyPair) ProtoMessage() {}

func (x *LabelValueKeyPair) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[134]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LabelValueKeyPair.ProtoReflect.Descriptor instead.
func (*LabelValueKeyPair) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{134}
}

func (x *LabelValueKeyPair) GetKey() LabelValueKeyPair_Key {
	if x != nil {
		return x.Key
	}
	return LabelValueKeyPair_Unknown
}

func (x *LabelValueKeyPair) GetValue() string {
	if x != nil {
		return x.Value
	}
	return ""
}

type LabelMatchExpression struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Volume affinity operation
	//
	// Volume affinity operator. Specifies that placement logic will match nodes that have labels in labelValueKeyPairs list.
	Operator LabelMatchExpression_Operator `protobuf:"varint,1,opt,name=operator,proto3,enum=lightbits.api.duros.v2.LabelMatchExpression_Operator" json:"operator,omitempty"`
	// Volume affinity operation Key/Value pairs
	//
	// Volume affinity KeyPairs. Key currently must be one of:
	// fd (failure domain). Value should specify the failure domains we want to match.
	// PrimaryFd (primary failure domain). Value should specify the primary failure domain we want to match.
	// ClusterId (cluster ID - cluster federation only). Value should specify the cluster ID we want to match.
	LabelValueKeyPairs []*LabelValueKeyPair `protobuf:"bytes,2,rep,name=labelValueKeyPairs,proto3" json:"labelValueKeyPairs,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *LabelMatchExpression) Reset() {
	*x = LabelMatchExpression{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[135]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LabelMatchExpression) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LabelMatchExpression) ProtoMessage() {}

func (x *LabelMatchExpression) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[135]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LabelMatchExpression.ProtoReflect.Descriptor instead.
func (*LabelMatchExpression) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{135}
}

func (x *LabelMatchExpression) GetOperator() LabelMatchExpression_Operator {
	if x != nil {
		return x.Operator
	}
	return LabelMatchExpression_Unknown
}

func (x *LabelMatchExpression) GetLabelValueKeyPairs() []*LabelValueKeyPair {
	if x != nil {
		return x.LabelValueKeyPairs
	}
	return nil
}

// ID of the impacted component (UUID/IP/serial number)
type ComponentVolumeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// volume UUID
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// volume name
	Name          string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentVolumeInfo) Reset() {
	*x = ComponentVolumeInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[136]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentVolumeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentVolumeInfo) ProtoMessage() {}

func (x *ComponentVolumeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[136]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentVolumeInfo.ProtoReflect.Descriptor instead.
func (*ComponentVolumeInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{136}
}

func (x *ComponentVolumeInfo) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *ComponentVolumeInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type VolumeComponentInfoList struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	VolumeComponentInfoList []*ComponentVolumeInfo `protobuf:"bytes,1,rep,name=VolumeComponentInfoList,proto3" json:"VolumeComponentInfoList,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *VolumeComponentInfoList) Reset() {
	*x = VolumeComponentInfoList{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[137]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *VolumeComponentInfoList) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*VolumeComponentInfoList) ProtoMessage() {}

func (x *VolumeComponentInfoList) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[137]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use VolumeComponentInfoList.ProtoReflect.Descriptor instead.
func (*VolumeComponentInfoList) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{137}
}

func (x *VolumeComponentInfoList) GetVolumeComponentInfoList() []*ComponentVolumeInfo {
	if x != nil {
		return x.VolumeComponentInfoList
	}
	return nil
}

type ComponentVolumesInfo struct {
	state             protoimpl.MessageState              `protogen:"open.v1"`
	ProjectVolumesMap map[string]*VolumeComponentInfoList `protobuf:"bytes,1,rep,name=ProjectVolumesMap,proto3" json:"ProjectVolumesMap,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ComponentVolumesInfo) Reset() {
	*x = ComponentVolumesInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[138]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentVolumesInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentVolumesInfo) ProtoMessage() {}

func (x *ComponentVolumesInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[138]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentVolumesInfo.ProtoReflect.Descriptor instead.
func (*ComponentVolumesInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{138}
}

func (x *ComponentVolumesInfo) GetProjectVolumesMap() map[string]*VolumeComponentInfoList {
	if x != nil {
		return x.ProjectVolumesMap
	}
	return nil
}

type ComponentNodeInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Node UUID
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Node name
	Name          string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentNodeInfo) Reset() {
	*x = ComponentNodeInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[139]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentNodeInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentNodeInfo) ProtoMessage() {}

func (x *ComponentNodeInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[139]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentNodeInfo.ProtoReflect.Descriptor instead.
func (*ComponentNodeInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{139}
}

func (x *ComponentNodeInfo) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *ComponentNodeInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ComponentClusterInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// cluster UUID
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// cluster name
	Name          string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentClusterInfo) Reset() {
	*x = ComponentClusterInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[140]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentClusterInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentClusterInfo) ProtoMessage() {}

func (x *ComponentClusterInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[140]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentClusterInfo.ProtoReflect.Descriptor instead.
func (*ComponentClusterInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{140}
}

func (x *ComponentClusterInfo) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *ComponentClusterInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ComponentNVMeSSDInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// NVMe serial number
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// SSD name
	Name          string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentNVMeSSDInfo) Reset() {
	*x = ComponentNVMeSSDInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[141]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentNVMeSSDInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentNVMeSSDInfo) ProtoMessage() {}

func (x *ComponentNVMeSSDInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[141]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentNVMeSSDInfo.ProtoReflect.Descriptor instead.
func (*ComponentNVMeSSDInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{141}
}

func (x *ComponentNVMeSSDInfo) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *ComponentNVMeSSDInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ComponentServerInfo struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Server UUID
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Server name
	Name          string `protobuf:"bytes,2,opt,name=Name,proto3" json:"Name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentServerInfo) Reset() {
	*x = ComponentServerInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[142]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentServerInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentServerInfo) ProtoMessage() {}

func (x *ComponentServerInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[142]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentServerInfo.ProtoReflect.Descriptor instead.
func (*ComponentServerInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{142}
}

func (x *ComponentServerInfo) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *ComponentServerInfo) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ComponentDataIntegrityInfo struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	NodeUUID      string                 `protobuf:"bytes,1,opt,name=NodeUUID,proto3" json:"NodeUUID,omitempty"`
	ServerUUID    string                 `protobuf:"bytes,2,opt,name=ServerUUID,proto3" json:"ServerUUID,omitempty"`
	SSDs          []string               `protobuf:"bytes,3,rep,name=SSDs,proto3" json:"SSDs,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ComponentDataIntegrityInfo) Reset() {
	*x = ComponentDataIntegrityInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[143]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ComponentDataIntegrityInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ComponentDataIntegrityInfo) ProtoMessage() {}

func (x *ComponentDataIntegrityInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[143]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ComponentDataIntegrityInfo.ProtoReflect.Descriptor instead.
func (*ComponentDataIntegrityInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{143}
}

func (x *ComponentDataIntegrityInfo) GetNodeUUID() string {
	if x != nil {
		return x.NodeUUID
	}
	return ""
}

func (x *ComponentDataIntegrityInfo) GetServerUUID() string {
	if x != nil {
		return x.ServerUUID
	}
	return ""
}

func (x *ComponentDataIntegrityInfo) GetSSDs() []string {
	if x != nil {
		return x.SSDs
	}
	return nil
}

type LBARange struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	LbaStart      uint64                 `protobuf:"varint,1,opt,name=lbaStart,proto3" json:"lbaStart,omitempty"`
	LbaEnd        uint64                 `protobuf:"varint,2,opt,name=lbaEnd,proto3" json:"lbaEnd,omitempty"`
	DataBitMap    []byte                 `protobuf:"bytes,3,opt,name=dataBitMap,proto3" json:"dataBitMap,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *LBARange) Reset() {
	*x = LBARange{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[144]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *LBARange) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*LBARange) ProtoMessage() {}

func (x *LBARange) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[144]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use LBARange.ProtoReflect.Descriptor instead.
func (*LBARange) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{144}
}

func (x *LBARange) GetLbaStart() uint64 {
	if x != nil {
		return x.LbaStart
	}
	return 0
}

func (x *LBARange) GetLbaEnd() uint64 {
	if x != nil {
		return x.LbaEnd
	}
	return 0
}

func (x *LBARange) GetDataBitMap() []byte {
	if x != nil {
		return x.DataBitMap
	}
	return nil
}

type ListChangedBlocksRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// snapshotUUID
	//
	// Target snapshot UUID for comparison (specify either snapshotUUID or snapshotName).
	SnapshotUUID string `protobuf:"bytes,1,opt,name=snapshotUUID,proto3" json:"snapshotUUID,omitempty"`
	// baseSnapshotUUID
	//
	// Source snapshot UUID for comparison. Optional in case of full comparison
	// (specify either baseSnapshotUUID or baseSnapshotName).
	BaseSnapshotUUID string `protobuf:"bytes,2,opt,name=baseSnapshotUUID,proto3" json:"baseSnapshotUUID,omitempty"`
	// projectName
	//
	// Project name
	ProjectName string `protobuf:"bytes,3,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// offsetLBA
	//
	// The first offset from which the comparison shall start, aligned to 64 and rounded down.
	OffsetLBA uint64 `protobuf:"varint,4,opt,name=offsetLBA,proto3" json:"offsetLBA,omitempty"`
	// snapshotName
	//
	// Target snapshot name for comparison (specify either snapshotUUID or snapshotName).
	SnapshotName string `protobuf:"bytes,5,opt,name=snapshotName,proto3" json:"snapshotName,omitempty"`
	// baseSnapshotName
	//
	// Source snapshot name for comparison. Optional in case of full comparison
	// (specify either baseSnapshotUUID or baseSnapshotName).
	BaseSnapshotName string `protobuf:"bytes,6,opt,name=baseSnapshotName,proto3" json:"baseSnapshotName,omitempty"`
	unknownFields    protoimpl.UnknownFields
	sizeCache        protoimpl.SizeCache
}

func (x *ListChangedBlocksRequest) Reset() {
	*x = ListChangedBlocksRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[145]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListChangedBlocksRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListChangedBlocksRequest) ProtoMessage() {}

func (x *ListChangedBlocksRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[145]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListChangedBlocksRequest.ProtoReflect.Descriptor instead.
func (*ListChangedBlocksRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{145}
}

func (x *ListChangedBlocksRequest) GetSnapshotUUID() string {
	if x != nil {
		return x.SnapshotUUID
	}
	return ""
}

func (x *ListChangedBlocksRequest) GetBaseSnapshotUUID() string {
	if x != nil {
		return x.BaseSnapshotUUID
	}
	return ""
}

func (x *ListChangedBlocksRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *ListChangedBlocksRequest) GetOffsetLBA() uint64 {
	if x != nil {
		return x.OffsetLBA
	}
	return 0
}

func (x *ListChangedBlocksRequest) GetSnapshotName() string {
	if x != nil {
		return x.SnapshotName
	}
	return ""
}

func (x *ListChangedBlocksRequest) GetBaseSnapshotName() string {
	if x != nil {
		return x.BaseSnapshotName
	}
	return ""
}

type ListChangedBlocksResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// nextOffsetLBA
	//
	// LBA Offset for next call, zero at the last call (when end of LBA range has been reached).
	NextOffsetLBA uint64 `protobuf:"varint,1,opt,name=nextOffsetLBA,proto3" json:"nextOffsetLBA,omitempty"`
	// lbaRanges
	//
	// List of ranges of the target snapshot UUID that differs from the base snapshot UUID.
	LbaRanges     []*LBARange `protobuf:"bytes,2,rep,name=lbaRanges,proto3" json:"lbaRanges,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListChangedBlocksResponse) Reset() {
	*x = ListChangedBlocksResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[146]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListChangedBlocksResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListChangedBlocksResponse) ProtoMessage() {}

func (x *ListChangedBlocksResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[146]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListChangedBlocksResponse.ProtoReflect.Descriptor instead.
func (*ListChangedBlocksResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{146}
}

func (x *ListChangedBlocksResponse) GetNextOffsetLBA() uint64 {
	if x != nil {
		return x.NextOffsetLBA
	}
	return 0
}

func (x *ListChangedBlocksResponse) GetLbaRanges() []*LBARange {
	if x != nil {
		return x.LbaRanges
	}
	return nil
}

// Event that will be returned to user
type Event struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Event UUID
	ID string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	// Event start time
	Time *timestamppb.Timestamp `protobuf:"bytes,2,opt,name=Time,proto3" json:"Time,omitempty"`
	// The component type impacted by the event
	Type Event_EventType `protobuf:"varint,3,opt,name=Type,proto3,enum=lightbits.api.duros.v2.Event_EventType" json:"Type,omitempty"`
	// The severity of the event
	Severity Event_EventSeverity `protobuf:"varint,4,opt,name=Severity,proto3,enum=lightbits.api.duros.v2.Event_EventSeverity" json:"Severity,omitempty"`
	// The name of the event
	EventName string `protobuf:"bytes,5,opt,name=EventName,proto3" json:"EventName,omitempty"`
	// The code of the cause of the event
	EventCode uint32 `protobuf:"varint,6,opt,name=EventCode,proto3" json:"EventCode,omitempty"`
	// The server that logged the event (Cluster Manager, Node Manager, etc)
	ReportingService Event_EventReportingService `protobuf:"varint,7,opt,name=ReportingService,proto3,enum=lightbits.api.duros.v2.Event_EventReportingService" json:"ReportingService,omitempty"`
	// The event ID related to this event.
	AssociatedEventID string `protobuf:"bytes,8,opt,name=AssociatedEventID,proto3" json:"AssociatedEventID,omitempty"`
	// Current status of the component
	Status string `protobuf:"bytes,9,opt,name=Status,proto3" json:"Status,omitempty"`
	// The Cause of the event
	CauseCode uint32 `protobuf:"varint,10,opt,name=CauseCode,proto3" json:"CauseCode,omitempty"`
	// The Event Description
	Description string `protobuf:"bytes,11,opt,name=Description,proto3" json:"Description,omitempty"`
	// Component information (specific to type)
	//
	// Types that are valid to be assigned to ComponentInfo:
	//
	//	*Event_ComponentVolumesInfo
	//	*Event_ComponentNVMeSSDInfo
	//	*Event_ComponentNodeInfo
	//	*Event_ComponentServerInfo
	//	*Event_ComponentClusterInfo
	//	*Event_ComponentDataIntegrityInfo
	ComponentInfo isEvent_ComponentInfo `protobuf_oneof:"ComponentInfo"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *Event) Reset() {
	*x = Event{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[147]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *Event) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*Event) ProtoMessage() {}

func (x *Event) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[147]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use Event.ProtoReflect.Descriptor instead.
func (*Event) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{147}
}

func (x *Event) GetID() string {
	if x != nil {
		return x.ID
	}
	return ""
}

func (x *Event) GetTime() *timestamppb.Timestamp {
	if x != nil {
		return x.Time
	}
	return nil
}

func (x *Event) GetType() Event_EventType {
	if x != nil {
		return x.Type
	}
	return Event_UnknownType
}

func (x *Event) GetSeverity() Event_EventSeverity {
	if x != nil {
		return x.Severity
	}
	return Event_UnkownSeverity
}

func (x *Event) GetEventName() string {
	if x != nil {
		return x.EventName
	}
	return ""
}

func (x *Event) GetEventCode() uint32 {
	if x != nil {
		return x.EventCode
	}
	return 0
}

func (x *Event) GetReportingService() Event_EventReportingService {
	if x != nil {
		return x.ReportingService
	}
	return Event_UnkownReportingService
}

func (x *Event) GetAssociatedEventID() string {
	if x != nil {
		return x.AssociatedEventID
	}
	return ""
}

func (x *Event) GetStatus() string {
	if x != nil {
		return x.Status
	}
	return ""
}

func (x *Event) GetCauseCode() uint32 {
	if x != nil {
		return x.CauseCode
	}
	return 0
}

func (x *Event) GetDescription() string {
	if x != nil {
		return x.Description
	}
	return ""
}

func (x *Event) GetComponentInfo() isEvent_ComponentInfo {
	if x != nil {
		return x.ComponentInfo
	}
	return nil
}

func (x *Event) GetComponentVolumesInfo() *ComponentVolumesInfo {
	if x != nil {
		if x, ok := x.ComponentInfo.(*Event_ComponentVolumesInfo); ok {
			return x.ComponentVolumesInfo
		}
	}
	return nil
}

func (x *Event) GetComponentNVMeSSDInfo() *ComponentNVMeSSDInfo {
	if x != nil {
		if x, ok := x.ComponentInfo.(*Event_ComponentNVMeSSDInfo); ok {
			return x.ComponentNVMeSSDInfo
		}
	}
	return nil
}

func (x *Event) GetComponentNodeInfo() *ComponentNodeInfo {
	if x != nil {
		if x, ok := x.ComponentInfo.(*Event_ComponentNodeInfo); ok {
			return x.ComponentNodeInfo
		}
	}
	return nil
}

func (x *Event) GetComponentServerInfo() *ComponentServerInfo {
	if x != nil {
		if x, ok := x.ComponentInfo.(*Event_ComponentServerInfo); ok {
			return x.ComponentServerInfo
		}
	}
	return nil
}

func (x *Event) GetComponentClusterInfo() *ComponentClusterInfo {
	if x != nil {
		if x, ok := x.ComponentInfo.(*Event_ComponentClusterInfo); ok {
			return x.ComponentClusterInfo
		}
	}
	return nil
}

func (x *Event) GetComponentDataIntegrityInfo() *ComponentDataIntegrityInfo {
	if x != nil {
		if x, ok := x.ComponentInfo.(*Event_ComponentDataIntegrityInfo); ok {
			return x.ComponentDataIntegrityInfo
		}
	}
	return nil
}

type isEvent_ComponentInfo interface {
	isEvent_ComponentInfo()
}

type Event_ComponentVolumesInfo struct {
	ComponentVolumesInfo *ComponentVolumesInfo `protobuf:"bytes,201,opt,name=ComponentVolumesInfo,proto3,oneof"`
}

type Event_ComponentNVMeSSDInfo struct {
	ComponentNVMeSSDInfo *ComponentNVMeSSDInfo `protobuf:"bytes,202,opt,name=ComponentNVMeSSDInfo,proto3,oneof"`
}

type Event_ComponentNodeInfo struct {
	ComponentNodeInfo *ComponentNodeInfo `protobuf:"bytes,203,opt,name=ComponentNodeInfo,proto3,oneof"`
}

type Event_ComponentServerInfo struct {
	ComponentServerInfo *ComponentServerInfo `protobuf:"bytes,204,opt,name=ComponentServerInfo,proto3,oneof"`
}

type Event_ComponentClusterInfo struct {
	ComponentClusterInfo *ComponentClusterInfo `protobuf:"bytes,205,opt,name=ComponentClusterInfo,proto3,oneof"`
}

type Event_ComponentDataIntegrityInfo struct {
	ComponentDataIntegrityInfo *ComponentDataIntegrityInfo `protobuf:"bytes,206,opt,name=ComponentDataIntegrityInfo,proto3,oneof"`
}

func (*Event_ComponentVolumesInfo) isEvent_ComponentInfo() {}

func (*Event_ComponentNVMeSSDInfo) isEvent_ComponentInfo() {}

func (*Event_ComponentNodeInfo) isEvent_ComponentInfo() {}

func (*Event_ComponentServerInfo) isEvent_ComponentInfo() {}

func (*Event_ComponentClusterInfo) isEvent_ComponentInfo() {}

func (*Event_ComponentDataIntegrityInfo) isEvent_ComponentInfo() {}

type QoSRateLimitPolicy struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// projectsNamesScope
	//
	// Lists the projects that have access to this policy (relevant if policyVisibility=Scoped)
	ProjectsNamesScope []string `protobuf:"bytes,3,rep,name=projectsNamesScope,proto3" json:"projectsNamesScope,omitempty"`
	// Policy Visibility
	//
	// Policy Visibility, specifics who has access to this policy
	PolicyVisibility PolicyVisibility `protobuf:"varint,4,opt,name=policyVisibility,proto3,enum=lightbits.api.duros.v2.PolicyVisibility" json:"policyVisibility,omitempty"`
	// Types that are valid to be assigned to QoSLimit:
	//
	//	*QoSRateLimitPolicy_LimitIOPS
	//	*QoSRateLimitPolicy_LimitBw
	//	*QoSRateLimitPolicy_LimitIOPSPerGB
	QoSLimit      isQoSRateLimitPolicy_QoSLimit `protobuf_oneof:"QoSLimit"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QoSRateLimitPolicy) Reset() {
	*x = QoSRateLimitPolicy{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[148]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QoSRateLimitPolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QoSRateLimitPolicy) ProtoMessage() {}

func (x *QoSRateLimitPolicy) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[148]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QoSRateLimitPolicy.ProtoReflect.Descriptor instead.
func (*QoSRateLimitPolicy) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{148}
}

func (x *QoSRateLimitPolicy) GetProjectsNamesScope() []string {
	if x != nil {
		return x.ProjectsNamesScope
	}
	return nil
}

func (x *QoSRateLimitPolicy) GetPolicyVisibility() PolicyVisibility {
	if x != nil {
		return x.PolicyVisibility
	}
	return PolicyVisibility_Unavailable
}

func (x *QoSRateLimitPolicy) GetQoSLimit() isQoSRateLimitPolicy_QoSLimit {
	if x != nil {
		return x.QoSLimit
	}
	return nil
}

func (x *QoSRateLimitPolicy) GetLimitIOPS() *QoSRateLimitPolicy_QoSLimitIOPS {
	if x != nil {
		if x, ok := x.QoSLimit.(*QoSRateLimitPolicy_LimitIOPS); ok {
			return x.LimitIOPS
		}
	}
	return nil
}

func (x *QoSRateLimitPolicy) GetLimitBw() *QoSRateLimitPolicy_QoSLimitBW {
	if x != nil {
		if x, ok := x.QoSLimit.(*QoSRateLimitPolicy_LimitBw); ok {
			return x.LimitBw
		}
	}
	return nil
}

func (x *QoSRateLimitPolicy) GetLimitIOPSPerGB() *QoSRateLimitPolicy_QoSLimitIOPSPerGB {
	if x != nil {
		if x, ok := x.QoSLimit.(*QoSRateLimitPolicy_LimitIOPSPerGB); ok {
			return x.LimitIOPSPerGB
		}
	}
	return nil
}

type isQoSRateLimitPolicy_QoSLimit interface {
	isQoSRateLimitPolicy_QoSLimit()
}

type QoSRateLimitPolicy_LimitIOPS struct {
	LimitIOPS *QoSRateLimitPolicy_QoSLimitIOPS `protobuf:"bytes,6,opt,name=limitIOPS,proto3,oneof"`
}

type QoSRateLimitPolicy_LimitBw struct {
	LimitBw *QoSRateLimitPolicy_QoSLimitBW `protobuf:"bytes,7,opt,name=limitBw,proto3,oneof"`
}

type QoSRateLimitPolicy_LimitIOPSPerGB struct {
	LimitIOPSPerGB *QoSRateLimitPolicy_QoSLimitIOPSPerGB `protobuf:"bytes,8,opt,name=limitIOPSPerGB,proto3,oneof"`
}

func (*QoSRateLimitPolicy_LimitIOPS) isQoSRateLimitPolicy_QoSLimit() {}

func (*QoSRateLimitPolicy_LimitBw) isQoSRateLimitPolicy_QoSLimit() {}

func (*QoSRateLimitPolicy_LimitIOPSPerGB) isQoSRateLimitPolicy_QoSLimit() {}

type DefaultGlobalResourcePolicy struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	PolicyType    PolicyType             `protobuf:"varint,1,opt,name=policyType,proto3,enum=lightbits.api.duros.v2.PolicyType" json:"policyType,omitempty"`
	PolicyUUID    string                 `protobuf:"bytes,2,opt,name=policyUUID,proto3" json:"policyUUID,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DefaultGlobalResourcePolicy) Reset() {
	*x = DefaultGlobalResourcePolicy{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[149]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DefaultGlobalResourcePolicy) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DefaultGlobalResourcePolicy) ProtoMessage() {}

func (x *DefaultGlobalResourcePolicy) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[149]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DefaultGlobalResourcePolicy.ProtoReflect.Descriptor instead.
func (*DefaultGlobalResourcePolicy) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{149}
}

func (x *DefaultGlobalResourcePolicy) GetPolicyType() PolicyType {
	if x != nil {
		return x.PolicyType
	}
	return PolicyType_unknown
}

func (x *DefaultGlobalResourcePolicy) GetPolicyUUID() string {
	if x != nil {
		return x.PolicyUUID
	}
	return ""
}

type UpdateProjectRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// projectName
	//
	// The name of the project to update.
	ProjectName string `protobuf:"bytes,1,opt,name=projectName,proto3" json:"projectName,omitempty"`
	// defaultPolicies
	//
	// The updated default policies to apply to the project.
	DefaultPolicies []*DefaultPolicy `protobuf:"bytes,2,rep,name=defaultPolicies,proto3" json:"defaultPolicies,omitempty"`
	unknownFields   protoimpl.UnknownFields
	sizeCache       protoimpl.SizeCache
}

func (x *UpdateProjectRequest) Reset() {
	*x = UpdateProjectRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[150]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateProjectRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateProjectRequest) ProtoMessage() {}

func (x *UpdateProjectRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[150]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateProjectRequest.ProtoReflect.Descriptor instead.
func (*UpdateProjectRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{150}
}

func (x *UpdateProjectRequest) GetProjectName() string {
	if x != nil {
		return x.ProjectName
	}
	return ""
}

func (x *UpdateProjectRequest) GetDefaultPolicies() []*DefaultPolicy {
	if x != nil {
		return x.DefaultPolicies
	}
	return nil
}

type UpdateProjectResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateProjectResponse) Reset() {
	*x = UpdateProjectResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[151]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateProjectResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateProjectResponse) ProtoMessage() {}

func (x *UpdateProjectResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[151]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateProjectResponse.ProtoReflect.Descriptor instead.
func (*UpdateProjectResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{151}
}

type ClusterEncryptionStatus struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// encryptionState
	//
	// Indicates the encryption state of the cluster encryption status
	EncryptionState ClusterEncryptionStatus_State `protobuf:"varint,1,opt,name=encryptionState,proto3,enum=lightbits.api.duros.v2.ClusterEncryptionStatus_State" json:"encryptionState,omitempty"`
	// kekGeneration
	//
	// The current generation of the KEK
	KekGeneration uint64 `protobuf:"varint,2,opt,name=kekGeneration,proto3" json:"kekGeneration,omitempty"`
	// kekUpdateDate
	//
	// The date of the last KEK update
	KekUpdateDate *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=kekUpdateDate,proto3" json:"kekUpdateDate,omitempty"`
	// previousKekGenerations
	//
	// The previous generations of the KEK
	PreviousKekGenerations []uint64 `protobuf:"varint,4,rep,packed,name=previousKekGenerations,proto3" json:"previousKekGenerations,omitempty"`
	// rotationState
	//
	// Indicates the rotation state of the cluster encryption encryption status
	RotationState ClusterEncryptionStatus_RotationState `protobuf:"varint,5,opt,name=rotationState,proto3,enum=lightbits.api.duros.v2.ClusterEncryptionStatus_RotationState" json:"rotationState,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ClusterEncryptionStatus) Reset() {
	*x = ClusterEncryptionStatus{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[152]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ClusterEncryptionStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ClusterEncryptionStatus) ProtoMessage() {}

func (x *ClusterEncryptionStatus) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[152]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ClusterEncryptionStatus.ProtoReflect.Descriptor instead.
func (*ClusterEncryptionStatus) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{152}
}

func (x *ClusterEncryptionStatus) GetEncryptionState() ClusterEncryptionStatus_State {
	if x != nil {
		return x.EncryptionState
	}
	return ClusterEncryptionStatus_Disabled
}

func (x *ClusterEncryptionStatus) GetKekGeneration() uint64 {
	if x != nil {
		return x.KekGeneration
	}
	return 0
}

func (x *ClusterEncryptionStatus) GetKekUpdateDate() *timestamppb.Timestamp {
	if x != nil {
		return x.KekUpdateDate
	}
	return nil
}

func (x *ClusterEncryptionStatus) GetPreviousKekGenerations() []uint64 {
	if x != nil {
		return x.PreviousKekGenerations
	}
	return nil
}

func (x *ClusterEncryptionStatus) GetRotationState() ClusterEncryptionStatus_RotationState {
	if x != nil {
		return x.RotationState
	}
	return ClusterEncryptionStatus_NoRotation
}

type IdpHealthInfo struct {
	state              protoimpl.MessageState `protogen:"open.v1"`
	ServerName         string                 `protobuf:"bytes,1,opt,name=serverName,proto3" json:"serverName,omitempty"`
	IdpHealthStatus    IdpHealthStatus        `protobuf:"varint,2,opt,name=idpHealthStatus,proto3,enum=lightbits.api.duros.v2.IdpHealthStatus" json:"idpHealthStatus,omitempty"`
	Timestamp          *timestamppb.Timestamp `protobuf:"bytes,3,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	HealthErrorMessage string                 `protobuf:"bytes,4,opt,name=healthErrorMessage,proto3" json:"healthErrorMessage,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *IdpHealthInfo) Reset() {
	*x = IdpHealthInfo{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[153]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IdpHealthInfo) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IdpHealthInfo) ProtoMessage() {}

func (x *IdpHealthInfo) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[153]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IdpHealthInfo.ProtoReflect.Descriptor instead.
func (*IdpHealthInfo) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{153}
}

func (x *IdpHealthInfo) GetServerName() string {
	if x != nil {
		return x.ServerName
	}
	return ""
}

func (x *IdpHealthInfo) GetIdpHealthStatus() IdpHealthStatus {
	if x != nil {
		return x.IdpHealthStatus
	}
	return IdpHealthStatus_IdpHealthStatus_Healthy
}

func (x *IdpHealthInfo) GetTimestamp() *timestamppb.Timestamp {
	if x != nil {
		return x.Timestamp
	}
	return nil
}

func (x *IdpHealthInfo) GetHealthErrorMessage() string {
	if x != nil {
		return x.HealthErrorMessage
	}
	return ""
}

type FederatedAuthenticationStatus struct {
	state                          protoimpl.MessageState `protogen:"open.v1"`
	FederatedAuthenticationEnabled bool                   `protobuf:"varint,1,opt,name=federatedAuthenticationEnabled,proto3" json:"federatedAuthenticationEnabled,omitempty"`
	IdpHealthInfos                 []*IdpHealthInfo       `protobuf:"bytes,2,rep,name=idpHealthInfos,proto3" json:"idpHealthInfos,omitempty"`
	unknownFields                  protoimpl.UnknownFields
	sizeCache                      protoimpl.SizeCache
}

func (x *FederatedAuthenticationStatus) Reset() {
	*x = FederatedAuthenticationStatus{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[154]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *FederatedAuthenticationStatus) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*FederatedAuthenticationStatus) ProtoMessage() {}

func (x *FederatedAuthenticationStatus) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[154]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use FederatedAuthenticationStatus.ProtoReflect.Descriptor instead.
func (*FederatedAuthenticationStatus) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{154}
}

func (x *FederatedAuthenticationStatus) GetFederatedAuthenticationEnabled() bool {
	if x != nil {
		return x.FederatedAuthenticationEnabled
	}
	return false
}

func (x *FederatedAuthenticationStatus) GetIdpHealthInfos() []*IdpHealthInfo {
	if x != nil {
		return x.IdpHealthInfos
	}
	return nil
}

type RotateClusterRootKeyRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RotateClusterRootKeyRequest) Reset() {
	*x = RotateClusterRootKeyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[155]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RotateClusterRootKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RotateClusterRootKeyRequest) ProtoMessage() {}

func (x *RotateClusterRootKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[155]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RotateClusterRootKeyRequest.ProtoReflect.Descriptor instead.
func (*RotateClusterRootKeyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{155}
}

type RotateClusterRootKeyResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *RotateClusterRootKeyResponse) Reset() {
	*x = RotateClusterRootKeyResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[156]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *RotateClusterRootKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*RotateClusterRootKeyResponse) ProtoMessage() {}

func (x *RotateClusterRootKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[156]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use RotateClusterRootKeyResponse.ProtoReflect.Descriptor instead.
func (*RotateClusterRootKeyResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{156}
}

type GetClusterRootKeyRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// encryptingKeyGeneration
	//
	// The generation of the encryption key. if not specified, the latest key will be exported.
	EncryptingKeyGeneration uint64 `protobuf:"varint,1,opt,name=encryptingKeyGeneration,proto3" json:"encryptingKeyGeneration,omitempty"`
	// userPublicKey
	//
	// Public key to use in order to encrypt the exported KEK.
	UserPublicKey []byte `protobuf:"bytes,2,opt,name=userPublicKey,proto3" json:"userPublicKey,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterRootKeyRequest) Reset() {
	*x = GetClusterRootKeyRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[157]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterRootKeyRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterRootKeyRequest) ProtoMessage() {}

func (x *GetClusterRootKeyRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[157]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterRootKeyRequest.ProtoReflect.Descriptor instead.
func (*GetClusterRootKeyRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{157}
}

func (x *GetClusterRootKeyRequest) GetEncryptingKeyGeneration() uint64 {
	if x != nil {
		return x.EncryptingKeyGeneration
	}
	return 0
}

func (x *GetClusterRootKeyRequest) GetUserPublicKey() []byte {
	if x != nil {
		return x.UserPublicKey
	}
	return nil
}

type GetClusterRootKeyResponse struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// keys
	//
	// The object that includes each exported key and its generation.
	Key           *GetClusterRootKeyResponse_KeyObject `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetClusterRootKeyResponse) Reset() {
	*x = GetClusterRootKeyResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[158]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterRootKeyResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterRootKeyResponse) ProtoMessage() {}

func (x *GetClusterRootKeyResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[158]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterRootKeyResponse.ProtoReflect.Descriptor instead.
func (*GetClusterRootKeyResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{158}
}

func (x *GetClusterRootKeyResponse) GetKey() *GetClusterRootKeyResponse_KeyObject {
	if x != nil {
		return x.Key
	}
	return nil
}

// IDPConfiguration represents the configuration for the Identity Provider (IdP) in the Lightbits cluster.
type IDPConfiguration struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// Unique name identifying this IdP configuration.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// The URL of the Identity Provider (IdP) issuer.
	IdpIssuerURL string `protobuf:"bytes,2,opt,name=idpIssuerURL,proto3" json:"idpIssuerURL,omitempty"`
	// The current state of the IdP configuration.
	State IDPConfiguration_IDPConfigurationState `protobuf:"varint,3,opt,name=state,proto3,enum=lightbits.api.duros.v2.IDPConfiguration_IDPConfigurationState" json:"state,omitempty"`
	// Type of an IdP (Identity Provider). Currently only ADFS is supported.
	Type IDPType `protobuf:"varint,4,opt,name=type,proto3,enum=lightbits.api.duros.v2.IDPType" json:"type,omitempty"`
	// The UUID of this IdP configuration.
	UUID string `protobuf:"bytes,5,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Optional. Proxy server information for an IdP that is accessed via proxy.
	ProxyInfo     *ProxyInfo `protobuf:"bytes,6,opt,name=proxyInfo,proto3" json:"proxyInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IDPConfiguration) Reset() {
	*x = IDPConfiguration{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[159]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IDPConfiguration) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IDPConfiguration) ProtoMessage() {}

func (x *IDPConfiguration) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[159]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IDPConfiguration.ProtoReflect.Descriptor instead.
func (*IDPConfiguration) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{159}
}

func (x *IDPConfiguration) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IDPConfiguration) GetIdpIssuerURL() string {
	if x != nil {
		return x.IdpIssuerURL
	}
	return ""
}

func (x *IDPConfiguration) GetState() IDPConfiguration_IDPConfigurationState {
	if x != nil {
		return x.State
	}
	return IDPConfiguration_Unknown
}

func (x *IDPConfiguration) GetType() IDPType {
	if x != nil {
		return x.Type
	}
	return IDPType_unknownIdp
}

func (x *IDPConfiguration) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *IDPConfiguration) GetProxyInfo() *ProxyInfo {
	if x != nil {
		return x.ProxyInfo
	}
	return nil
}

type CreateIDPConfigurationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The unique name to assign to this IdP configuration.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// idpIssuerURL
	//
	// The URL of the Identity Provider (IdP) issuer.
	IdpIssuerURL string `protobuf:"bytes,2,opt,name=idpIssuerURL,proto3" json:"idpIssuerURL,omitempty"`
	// type
	//
	// Type of an IdP (Identity Provider). Currently only ADFS is supported.
	Type IDPType `protobuf:"varint,3,opt,name=type,proto3,enum=lightbits.api.duros.v2.IDPType" json:"type,omitempty"`
	// ProxyInfo
	//
	// Optional. Proxy server information for an IdP that is accessed via proxy.
	ProxyInfo     *ProxyInfo `protobuf:"bytes,4,opt,name=proxyInfo,proto3" json:"proxyInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateIDPConfigurationRequest) Reset() {
	*x = CreateIDPConfigurationRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[160]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateIDPConfigurationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIDPConfigurationRequest) ProtoMessage() {}

func (x *CreateIDPConfigurationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[160]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIDPConfigurationRequest.ProtoReflect.Descriptor instead.
func (*CreateIDPConfigurationRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{160}
}

func (x *CreateIDPConfigurationRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateIDPConfigurationRequest) GetIdpIssuerURL() string {
	if x != nil {
		return x.IdpIssuerURL
	}
	return ""
}

func (x *CreateIDPConfigurationRequest) GetType() IDPType {
	if x != nil {
		return x.Type
	}
	return IDPType_unknownIdp
}

func (x *CreateIDPConfigurationRequest) GetProxyInfo() *ProxyInfo {
	if x != nil {
		return x.ProxyInfo
	}
	return nil
}

type UpdateIDPConfigurationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// Specify name of the IdP configuration to update.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// idpIssuerURL
	//
	// The URL of the Identity Provider (IdP) issuer.
	IdpIssuerURL string `protobuf:"bytes,2,opt,name=idpIssuerURL,proto3" json:"idpIssuerURL,omitempty"`
	// type
	//
	// The type of an IdP (Identity Provider). Currently only ADFS is supported.
	Type IDPType `protobuf:"varint,3,opt,name=type,proto3,enum=lightbits.api.duros.v2.IDPType" json:"type,omitempty"`
	// proxyInfo
	//
	// Proxy server information for an IdP that is accessed via proxy.
	ProxyInfo     *ProxyInfo `protobuf:"bytes,4,opt,name=proxyInfo,proto3" json:"proxyInfo,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateIDPConfigurationRequest) Reset() {
	*x = UpdateIDPConfigurationRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[161]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateIDPConfigurationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateIDPConfigurationRequest) ProtoMessage() {}

func (x *UpdateIDPConfigurationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[161]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateIDPConfigurationRequest.ProtoReflect.Descriptor instead.
func (*UpdateIDPConfigurationRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{161}
}

func (x *UpdateIDPConfigurationRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateIDPConfigurationRequest) GetIdpIssuerURL() string {
	if x != nil {
		return x.IdpIssuerURL
	}
	return ""
}

func (x *UpdateIDPConfigurationRequest) GetType() IDPType {
	if x != nil {
		return x.Type
	}
	return IDPType_unknownIdp
}

func (x *UpdateIDPConfigurationRequest) GetProxyInfo() *ProxyInfo {
	if x != nil {
		return x.ProxyInfo
	}
	return nil
}

type ListIDPConfigurationsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIDPConfigurationsRequest) Reset() {
	*x = ListIDPConfigurationsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[162]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIDPConfigurationsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIDPConfigurationsRequest) ProtoMessage() {}

func (x *ListIDPConfigurationsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[162]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIDPConfigurationsRequest.ProtoReflect.Descriptor instead.
func (*ListIDPConfigurationsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{162}
}

type ListIDPConfigurationsResponse struct {
	state             protoimpl.MessageState `protogen:"open.v1"`
	IdpConfigurations []*IDPConfiguration    `protobuf:"bytes,1,rep,name=idpConfigurations,proto3" json:"idpConfigurations,omitempty"`
	unknownFields     protoimpl.UnknownFields
	sizeCache         protoimpl.SizeCache
}

func (x *ListIDPConfigurationsResponse) Reset() {
	*x = ListIDPConfigurationsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[163]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIDPConfigurationsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIDPConfigurationsResponse) ProtoMessage() {}

func (x *ListIDPConfigurationsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[163]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIDPConfigurationsResponse.ProtoReflect.Descriptor instead.
func (*ListIDPConfigurationsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{163}
}

func (x *ListIDPConfigurationsResponse) GetIdpConfigurations() []*IDPConfiguration {
	if x != nil {
		return x.IdpConfigurations
	}
	return nil
}

type GetIDPConfigurationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the IdP configuration to get.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIDPConfigurationRequest) Reset() {
	*x = GetIDPConfigurationRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[164]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIDPConfigurationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIDPConfigurationRequest) ProtoMessage() {}

func (x *GetIDPConfigurationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[164]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIDPConfigurationRequest.ProtoReflect.Descriptor instead.
func (*GetIDPConfigurationRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{164}
}

func (x *GetIDPConfigurationRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DeleteIDPConfigurationRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the IdP configuration to delete.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteIDPConfigurationRequest) Reset() {
	*x = DeleteIDPConfigurationRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[165]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteIDPConfigurationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteIDPConfigurationRequest) ProtoMessage() {}

func (x *DeleteIDPConfigurationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[165]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteIDPConfigurationRequest.ProtoReflect.Descriptor instead.
func (*DeleteIDPConfigurationRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{165}
}

func (x *DeleteIDPConfigurationRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DeleteIDPConfigurationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteIDPConfigurationResponse) Reset() {
	*x = DeleteIDPConfigurationResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[166]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteIDPConfigurationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteIDPConfigurationResponse) ProtoMessage() {}

func (x *DeleteIDPConfigurationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[166]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteIDPConfigurationResponse.ProtoReflect.Descriptor instead.
func (*DeleteIDPConfigurationResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{166}
}

// idp-client-configuration represents a configuration of a client-specific IdP entry in the Lightbits cluster.
// The Lightbits cluster supports IdP client configurations with three types of authorization modes:
// App, User, and Converge.
// App authorization mode should be used when Lightbits should map a specific client to a scope and role.
// User authorization mode should be used when Lightbits should map according to both the client ID and a specific claim in the JWT.
// Converge mode is used when Lightbits should map only according to the claim in the JWT. In this mode the client ID is ignored.
// Only a single such entry can be created for each IdP configuration. Lightbits API service will first attempt to check for a
// dedicated IdP client configuration using this client ID, falling back to to an optional converge entry only if no direct client specific
// entry is found.
type IdpClientConf struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// The UUID of the idp-client-config entry.
	UUID string `protobuf:"bytes,1,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// A unique name of the idp-client-conf.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// clientId
	//
	// A unique client ID identifier registered in the IdP to identify a
	//
	//	specific application (or a client) that wants to access resources
	//	from a Lightbits cluster.
	//	When using converge authorization mode, this field must be configured to:
	//	NOT_APPLICABLE.
	ClientId string `protobuf:"bytes,3,opt,name=clientId,proto3" json:"clientId,omitempty"`
	// A reference to the IdP configuration that will use this client
	//
	//	configuration.
	IdpConfigurationName string `protobuf:"bytes,4,opt,name=idpConfigurationName,proto3" json:"idpConfigurationName,omitempty"`
	// When working in user authorization/converge mode, the claim name specifies
	//
	//	the name of the field in JWT claim from which to extract the identifier
	//	value from.
	//	Note that this field is only required when authzMode is user or converge.
	ClaimName string `protobuf:"bytes,5,opt,name=claimName,proto3" json:"claimName,omitempty"`
	// authzMode
	//
	// The authorization mode will determine what information from access JWT
	//
	//	will be mapped to a matching scope/role in the Lightbits cluster.
	//	The authorization mode can be one of the following:
	//	user, app, converge.
	AuthzMode     AuthorizationMode `protobuf:"varint,6,opt,name=authzMode,proto3,enum=lightbits.api.duros.v2.AuthorizationMode" json:"authzMode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *IdpClientConf) Reset() {
	*x = IdpClientConf{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[167]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *IdpClientConf) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*IdpClientConf) ProtoMessage() {}

func (x *IdpClientConf) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[167]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use IdpClientConf.ProtoReflect.Descriptor instead.
func (*IdpClientConf) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{167}
}

func (x *IdpClientConf) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *IdpClientConf) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *IdpClientConf) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *IdpClientConf) GetIdpConfigurationName() string {
	if x != nil {
		return x.IdpConfigurationName
	}
	return ""
}

func (x *IdpClientConf) GetClaimName() string {
	if x != nil {
		return x.ClaimName
	}
	return ""
}

func (x *IdpClientConf) GetAuthzMode() AuthorizationMode {
	if x != nil {
		return x.AuthzMode
	}
	return AuthorizationMode_UnknownAuthzMode
}

type CreateIdpClientConfRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// A unique name of the idp-client-conf.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// clientId
	//
	// A unique client ID identifier registered in the IdP to identify a
	//
	//	specific application (or a client) that wants to access resources
	//	from a Lightbits cluster.
	//	When using converge authorization mode, this field must be configured to:
	//	NOT_APPLICABLE.
	ClientId string `protobuf:"bytes,2,opt,name=clientId,proto3" json:"clientId,omitempty"`
	// idpConfigurationName
	//
	// A reference to the IdP configuration that will use this client
	//
	//	configuration.
	IdpConfigurationName string `protobuf:"bytes,3,opt,name=idpConfigurationName,proto3" json:"idpConfigurationName,omitempty"`
	// claimName
	//
	// When working in user authorization/converge mode, the claim name specifies
	//
	//	the name of the field in the JWT claim from which to extract the identifier
	//	value from.
	//	Note that this field is only required when authzMode is user or converge.
	ClaimName string `protobuf:"bytes,4,opt,name=claimName,proto3" json:"claimName,omitempty"`
	// The authorization mode will determine what information from access JWT
	//
	//	will be mapped to a matching scope/role in the Lightbits cluster.
	//	The authorization mode can be one of the following:
	//	user, app, converge.
	AuthzMode     AuthorizationMode `protobuf:"varint,5,opt,name=authzMode,proto3,enum=lightbits.api.duros.v2.AuthorizationMode" json:"authzMode,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *CreateIdpClientConfRequest) Reset() {
	*x = CreateIdpClientConfRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[168]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateIdpClientConfRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateIdpClientConfRequest) ProtoMessage() {}

func (x *CreateIdpClientConfRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[168]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateIdpClientConfRequest.ProtoReflect.Descriptor instead.
func (*CreateIdpClientConfRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{168}
}

func (x *CreateIdpClientConfRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateIdpClientConfRequest) GetClientId() string {
	if x != nil {
		return x.ClientId
	}
	return ""
}

func (x *CreateIdpClientConfRequest) GetIdpConfigurationName() string {
	if x != nil {
		return x.IdpConfigurationName
	}
	return ""
}

func (x *CreateIdpClientConfRequest) GetClaimName() string {
	if x != nil {
		return x.ClaimName
	}
	return ""
}

func (x *CreateIdpClientConfRequest) GetAuthzMode() AuthorizationMode {
	if x != nil {
		return x.AuthzMode
	}
	return AuthorizationMode_UnknownAuthzMode
}

type UpdateIdpClientConfRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the idp-client-conf to update.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// claimName
	//
	// When working in user authorization/converge mode, the claim name specifies
	//
	//	the name of the field in the JWT claim from which to extract the identifier
	//	value from.
	//	Note that this field is only required when authzMode is user or converge.
	ClaimName     string `protobuf:"bytes,2,opt,name=claimName,proto3" json:"claimName,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *UpdateIdpClientConfRequest) Reset() {
	*x = UpdateIdpClientConfRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[169]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateIdpClientConfRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateIdpClientConfRequest) ProtoMessage() {}

func (x *UpdateIdpClientConfRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[169]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateIdpClientConfRequest.ProtoReflect.Descriptor instead.
func (*UpdateIdpClientConfRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{169}
}

func (x *UpdateIdpClientConfRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateIdpClientConfRequest) GetClaimName() string {
	if x != nil {
		return x.ClaimName
	}
	return ""
}

type GetIdpClientConfRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the idp-client-conf to get.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetIdpClientConfRequest) Reset() {
	*x = GetIdpClientConfRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[170]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetIdpClientConfRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetIdpClientConfRequest) ProtoMessage() {}

func (x *GetIdpClientConfRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[170]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetIdpClientConfRequest.ProtoReflect.Descriptor instead.
func (*GetIdpClientConfRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{170}
}

func (x *GetIdpClientConfRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DeleteIdpClientConfRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// The name of the idp-client-conf to delete.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteIdpClientConfRequest) Reset() {
	*x = DeleteIdpClientConfRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[171]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteIdpClientConfRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteIdpClientConfRequest) ProtoMessage() {}

func (x *DeleteIdpClientConfRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[171]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteIdpClientConfRequest.ProtoReflect.Descriptor instead.
func (*DeleteIdpClientConfRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{171}
}

func (x *DeleteIdpClientConfRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type DeleteIdpClientConfResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteIdpClientConfResponse) Reset() {
	*x = DeleteIdpClientConfResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[172]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteIdpClientConfResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteIdpClientConfResponse) ProtoMessage() {}

func (x *DeleteIdpClientConfResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[172]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteIdpClientConfResponse.ProtoReflect.Descriptor instead.
func (*DeleteIdpClientConfResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{172}
}

type ListIdpClientConfsRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListIdpClientConfsRequest) Reset() {
	*x = ListIdpClientConfsRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[173]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIdpClientConfsRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIdpClientConfsRequest) ProtoMessage() {}

func (x *ListIdpClientConfsRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[173]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIdpClientConfsRequest.ProtoReflect.Descriptor instead.
func (*ListIdpClientConfsRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{173}
}

type ListIdpClientConfsResponse struct {
	state                   protoimpl.MessageState `protogen:"open.v1"`
	IdpClientConfigurations []*IdpClientConf       `protobuf:"bytes,1,rep,name=idpClientConfigurations,proto3" json:"idpClientConfigurations,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *ListIdpClientConfsResponse) Reset() {
	*x = ListIdpClientConfsResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[174]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListIdpClientConfsResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListIdpClientConfsResponse) ProtoMessage() {}

func (x *ListIdpClientConfsResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[174]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListIdpClientConfsResponse.ProtoReflect.Descriptor instead.
func (*ListIdpClientConfsResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{174}
}

func (x *ListIdpClientConfsResponse) GetIdpClientConfigurations() []*IdpClientConf {
	if x != nil {
		return x.IdpClientConfigurations
	}
	return nil
}

type AuthMapEntry struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// AuthMapEntry UUID
	UUID string `protobuf:"bytes,2,opt,name=UUID,proto3" json:"UUID,omitempty"`
	// Name of specific authorization mapping entry.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// Identifier to map application or clientID/claim/group to Lightbits scope/role.
	//
	//	This should either have the clientID of the relevant application (app mode), or
	//	an identifier of a specific claim/group extracted from the field specified by claimName
	//	(user or converge modes).
	Identifier string `protobuf:"bytes,4,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// Represents the scope assigned to this client/claim/group in the Lightbits cluster.
	Scope string `protobuf:"bytes,5,opt,name=scope,proto3" json:"scope,omitempty"`
	// Represents the role assigned to this client/claim/group in the Lightbits cluster.
	Role string `protobuf:"bytes,6,opt,name=role,proto3" json:"role,omitempty"`
	// IdP configuration that is associated with this authorization map entry.
	IdpConfigurationName string `protobuf:"bytes,7,opt,name=idpConfigurationName,proto3" json:"idpConfigurationName,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *AuthMapEntry) Reset() {
	*x = AuthMapEntry{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[175]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *AuthMapEntry) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*AuthMapEntry) ProtoMessage() {}

func (x *AuthMapEntry) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[175]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use AuthMapEntry.ProtoReflect.Descriptor instead.
func (*AuthMapEntry) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{175}
}

func (x *AuthMapEntry) GetUUID() string {
	if x != nil {
		return x.UUID
	}
	return ""
}

func (x *AuthMapEntry) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *AuthMapEntry) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *AuthMapEntry) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

func (x *AuthMapEntry) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *AuthMapEntry) GetIdpConfigurationName() string {
	if x != nil {
		return x.IdpConfigurationName
	}
	return ""
}

type CreateAuthMapEntryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// Name of a specific authorization mapping entry.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// identifier
	//
	// Identifier to map application or clientID/claim/group to Lightbits scope/role.
	//
	//	This should either have the clientID of the relevant application (app mode) or
	//	an identifier of a specific claim/group extracted from the field specified by claimName
	//	(user or converge modes).
	Identifier string `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// scope
	//
	// Represents the scope assigned to this client/claim/group in the Lightbits cluster.
	Scope string `protobuf:"bytes,3,opt,name=scope,proto3" json:"scope,omitempty"`
	// Role
	//
	// Represents the role assigned to this client/claim/group in the Lightbits cluster.
	Role string `protobuf:"bytes,4,opt,name=role,proto3" json:"role,omitempty"`
	// idpConfigurationName
	//
	// Idp configuration that is associated with this authorization map entry.
	IdpConfigurationName string `protobuf:"bytes,5,opt,name=idpConfigurationName,proto3" json:"idpConfigurationName,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *CreateAuthMapEntryRequest) Reset() {
	*x = CreateAuthMapEntryRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[176]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *CreateAuthMapEntryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*CreateAuthMapEntryRequest) ProtoMessage() {}

func (x *CreateAuthMapEntryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[176]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use CreateAuthMapEntryRequest.ProtoReflect.Descriptor instead.
func (*CreateAuthMapEntryRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{176}
}

func (x *CreateAuthMapEntryRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *CreateAuthMapEntryRequest) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *CreateAuthMapEntryRequest) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

func (x *CreateAuthMapEntryRequest) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *CreateAuthMapEntryRequest) GetIdpConfigurationName() string {
	if x != nil {
		return x.IdpConfigurationName
	}
	return ""
}

type UpdateAuthMapEntryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// Name of a specific authorization mapping entry.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// scope
	//
	// The scope assigned to this client/claim/group in the Lightbits cluster.
	Scope string `protobuf:"bytes,2,opt,name=scope,proto3" json:"scope,omitempty"`
	// role
	//
	// The role assigned to this client/claim/group in the Lightbits cluster.
	Role string `protobuf:"bytes,3,opt,name=role,proto3" json:"role,omitempty"`
	// identifier
	//
	// Identifier to map application or claim/group to a Lightbits scope/role.
	//
	//	This should either have the clientID of the relevant application (app mode) or
	//	an identifier of a specific claim/group extracted from the field specified by claimName
	//	(user or converge modes).
	Identifier string `protobuf:"bytes,4,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// idpConfigurationName
	//
	// IdP configuration that is associated with this authorization map entry.
	IdpConfigurationName string `protobuf:"bytes,5,opt,name=idpConfigurationName,proto3" json:"idpConfigurationName,omitempty"`
	unknownFields        protoimpl.UnknownFields
	sizeCache            protoimpl.SizeCache
}

func (x *UpdateAuthMapEntryRequest) Reset() {
	*x = UpdateAuthMapEntryRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[177]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *UpdateAuthMapEntryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*UpdateAuthMapEntryRequest) ProtoMessage() {}

func (x *UpdateAuthMapEntryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[177]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use UpdateAuthMapEntryRequest.ProtoReflect.Descriptor instead.
func (*UpdateAuthMapEntryRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{177}
}

func (x *UpdateAuthMapEntryRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

func (x *UpdateAuthMapEntryRequest) GetScope() string {
	if x != nil {
		return x.Scope
	}
	return ""
}

func (x *UpdateAuthMapEntryRequest) GetRole() string {
	if x != nil {
		return x.Role
	}
	return ""
}

func (x *UpdateAuthMapEntryRequest) GetIdentifier() string {
	if x != nil {
		return x.Identifier
	}
	return ""
}

func (x *UpdateAuthMapEntryRequest) GetIdpConfigurationName() string {
	if x != nil {
		return x.IdpConfigurationName
	}
	return ""
}

type DeleteAuthMapEntryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// Name of a specific authorization mapping entry.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAuthMapEntryRequest) Reset() {
	*x = DeleteAuthMapEntryRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[178]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAuthMapEntryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAuthMapEntryRequest) ProtoMessage() {}

func (x *DeleteAuthMapEntryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[178]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAuthMapEntryRequest.ProtoReflect.Descriptor instead.
func (*DeleteAuthMapEntryRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{178}
}

func (x *DeleteAuthMapEntryRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type GetAuthMapEntryRequest struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// name
	//
	// Name of a specific authorization mapping entry.
	Name          string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *GetAuthMapEntryRequest) Reset() {
	*x = GetAuthMapEntryRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[179]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetAuthMapEntryRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetAuthMapEntryRequest) ProtoMessage() {}

func (x *GetAuthMapEntryRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[179]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetAuthMapEntryRequest.ProtoReflect.Descriptor instead.
func (*GetAuthMapEntryRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{179}
}

func (x *GetAuthMapEntryRequest) GetName() string {
	if x != nil {
		return x.Name
	}
	return ""
}

type ListAuthMapEntriesRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *ListAuthMapEntriesRequest) Reset() {
	*x = ListAuthMapEntriesRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[180]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAuthMapEntriesRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAuthMapEntriesRequest) ProtoMessage() {}

func (x *ListAuthMapEntriesRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[180]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAuthMapEntriesRequest.ProtoReflect.Descriptor instead.
func (*ListAuthMapEntriesRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{180}
}

type DeleteAuthMapEntryResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DeleteAuthMapEntryResponse) Reset() {
	*x = DeleteAuthMapEntryResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[181]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DeleteAuthMapEntryResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DeleteAuthMapEntryResponse) ProtoMessage() {}

func (x *DeleteAuthMapEntryResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[181]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DeleteAuthMapEntryResponse.ProtoReflect.Descriptor instead.
func (*DeleteAuthMapEntryResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{181}
}

type ListAuthMapEntriesResponse struct {
	state          protoimpl.MessageState `protogen:"open.v1"`
	AuthMapEntries []*AuthMapEntry        `protobuf:"bytes,1,rep,name=authMapEntries,proto3" json:"authMapEntries,omitempty"`
	unknownFields  protoimpl.UnknownFields
	sizeCache      protoimpl.SizeCache
}

func (x *ListAuthMapEntriesResponse) Reset() {
	*x = ListAuthMapEntriesResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[182]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *ListAuthMapEntriesResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*ListAuthMapEntriesResponse) ProtoMessage() {}

func (x *ListAuthMapEntriesResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[182]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use ListAuthMapEntriesResponse.ProtoReflect.Descriptor instead.
func (*ListAuthMapEntriesResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{182}
}

func (x *ListAuthMapEntriesResponse) GetAuthMapEntries() []*AuthMapEntry {
	if x != nil {
		return x.AuthMapEntries
	}
	return nil
}

type EnableFederatedAuthenticationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnableFederatedAuthenticationRequest) Reset() {
	*x = EnableFederatedAuthenticationRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[183]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnableFederatedAuthenticationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnableFederatedAuthenticationRequest) ProtoMessage() {}

func (x *EnableFederatedAuthenticationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[183]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnableFederatedAuthenticationRequest.ProtoReflect.Descriptor instead.
func (*EnableFederatedAuthenticationRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{183}
}

type EnableFederatedAuthenticationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *EnableFederatedAuthenticationResponse) Reset() {
	*x = EnableFederatedAuthenticationResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[184]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *EnableFederatedAuthenticationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*EnableFederatedAuthenticationResponse) ProtoMessage() {}

func (x *EnableFederatedAuthenticationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[184]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use EnableFederatedAuthenticationResponse.ProtoReflect.Descriptor instead.
func (*EnableFederatedAuthenticationResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{184}
}

type DisableFederatedAuthenticationRequest struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisableFederatedAuthenticationRequest) Reset() {
	*x = DisableFederatedAuthenticationRequest{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[185]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisableFederatedAuthenticationRequest) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisableFederatedAuthenticationRequest) ProtoMessage() {}

func (x *DisableFederatedAuthenticationRequest) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[185]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisableFederatedAuthenticationRequest.ProtoReflect.Descriptor instead.
func (*DisableFederatedAuthenticationRequest) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{185}
}

type DisableFederatedAuthenticationResponse struct {
	state         protoimpl.MessageState `protogen:"open.v1"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *DisableFederatedAuthenticationResponse) Reset() {
	*x = DisableFederatedAuthenticationResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[186]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *DisableFederatedAuthenticationResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*DisableFederatedAuthenticationResponse) ProtoMessage() {}

func (x *DisableFederatedAuthenticationResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[186]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use DisableFederatedAuthenticationResponse.ProtoReflect.Descriptor instead.
func (*DisableFederatedAuthenticationResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{186}
}

type GetFederatedAuthenticationStatusResponse struct {
	state                        protoimpl.MessageState `protogen:"open.v1"`
	FederatedAuthenticationState FedAuthState           `protobuf:"varint,1,opt,name=federatedAuthenticationState,proto3,enum=lightbits.api.duros.v2.FedAuthState" json:"federatedAuthenticationState,omitempty"`
	unknownFields                protoimpl.UnknownFields
	sizeCache                    protoimpl.SizeCache
}

func (x *GetFederatedAuthenticationStatusResponse) Reset() {
	*x = GetFederatedAuthenticationStatusResponse{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[187]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetFederatedAuthenticationStatusResponse) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetFederatedAuthenticationStatusResponse) ProtoMessage() {}

func (x *GetFederatedAuthenticationStatusResponse) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[187]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetFederatedAuthenticationStatusResponse.ProtoReflect.Descriptor instead.
func (*GetFederatedAuthenticationStatusResponse) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{187}
}

func (x *GetFederatedAuthenticationStatusResponse) GetFederatedAuthenticationState() FedAuthState {
	if x != nil {
		return x.FederatedAuthenticationState
	}
	return FedAuthState_FederatedAuthenticationDisabled
}

// A limit of 0 means no rate limit.
// Bandwidth limit is in units of MB/s.
type QoSRateLimitPolicy_QoSLimitIOPS struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// writeIOPSLimit
	//
	// Volume write bandwidth limits, specified in units of IOPs. The granularity increases by 256 IOPs each time. 0 means unlimited.
	WriteIOPSLimit uint32 `protobuf:"varint,1,opt,name=writeIOPSLimit,proto3" json:"writeIOPSLimit,omitempty"`
	// readIOPSLimit
	//
	// Volume read bandwidth limits, specified in units of IOPs. The granularity increases by 256 IOPs each time. 0 means unlimited.
	ReadIOPSLimit uint32 `protobuf:"varint,2,opt,name=readIOPSLimit,proto3" json:"readIOPSLimit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QoSRateLimitPolicy_QoSLimitIOPS) Reset() {
	*x = QoSRateLimitPolicy_QoSLimitIOPS{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[190]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QoSRateLimitPolicy_QoSLimitIOPS) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QoSRateLimitPolicy_QoSLimitIOPS) ProtoMessage() {}

func (x *QoSRateLimitPolicy_QoSLimitIOPS) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[190]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QoSRateLimitPolicy_QoSLimitIOPS.ProtoReflect.Descriptor instead.
func (*QoSRateLimitPolicy_QoSLimitIOPS) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{148, 0}
}

func (x *QoSRateLimitPolicy_QoSLimitIOPS) GetWriteIOPSLimit() uint32 {
	if x != nil {
		return x.WriteIOPSLimit
	}
	return 0
}

func (x *QoSRateLimitPolicy_QoSLimitIOPS) GetReadIOPSLimit() uint32 {
	if x != nil {
		return x.ReadIOPSLimit
	}
	return 0
}

type QoSRateLimitPolicy_QoSLimitBW struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// writeBWLimit
	//
	// Volume write bandwidth limits, specified in units of MB/s. The granularity must be in full MB/s. 0 means unlimited.
	WriteBWLimit uint32 `protobuf:"varint,1,opt,name=writeBWLimit,proto3" json:"writeBWLimit,omitempty"`
	// readBWLimit
	//
	// Volume read bandwidth limits, specified in units of MB/s. The granularity must be in full MB/s. 0 means unlimited.
	ReadBWLimit   uint32 `protobuf:"varint,2,opt,name=readBWLimit,proto3" json:"readBWLimit,omitempty"`
	unknownFields protoimpl.UnknownFields
	sizeCache     protoimpl.SizeCache
}

func (x *QoSRateLimitPolicy_QoSLimitBW) Reset() {
	*x = QoSRateLimitPolicy_QoSLimitBW{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[191]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QoSRateLimitPolicy_QoSLimitBW) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QoSRateLimitPolicy_QoSLimitBW) ProtoMessage() {}

func (x *QoSRateLimitPolicy_QoSLimitBW) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[191]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QoSRateLimitPolicy_QoSLimitBW.ProtoReflect.Descriptor instead.
func (*QoSRateLimitPolicy_QoSLimitBW) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{148, 1}
}

func (x *QoSRateLimitPolicy_QoSLimitBW) GetWriteBWLimit() uint32 {
	if x != nil {
		return x.WriteBWLimit
	}
	return 0
}

func (x *QoSRateLimitPolicy_QoSLimitBW) GetReadBWLimit() uint32 {
	if x != nil {
		return x.ReadBWLimit
	}
	return 0
}

type QoSRateLimitPolicy_QoSLimitIOPSPerGB struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// writeIOPSPerGBLimit
	//
	// Volume write bandwidth limits, specified in units of IOPs per GB of volume size. 0 means unlimited.
	WriteIOPSPerGBLimit uint32 `protobuf:"varint,1,opt,name=writeIOPSPerGBLimit,proto3" json:"writeIOPSPerGBLimit,omitempty"`
	// readIOPSPerGBLimit
	//
	// Volume read bandwidth limits, specified in units of IOPs per GB of volume size. 0 means unlimited.
	ReadIOPSPerGBLimit uint32 `protobuf:"varint,2,opt,name=readIOPSPerGBLimit,proto3" json:"readIOPSPerGBLimit,omitempty"`
	unknownFields      protoimpl.UnknownFields
	sizeCache          protoimpl.SizeCache
}

func (x *QoSRateLimitPolicy_QoSLimitIOPSPerGB) Reset() {
	*x = QoSRateLimitPolicy_QoSLimitIOPSPerGB{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[192]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *QoSRateLimitPolicy_QoSLimitIOPSPerGB) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*QoSRateLimitPolicy_QoSLimitIOPSPerGB) ProtoMessage() {}

func (x *QoSRateLimitPolicy_QoSLimitIOPSPerGB) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[192]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use QoSRateLimitPolicy_QoSLimitIOPSPerGB.ProtoReflect.Descriptor instead.
func (*QoSRateLimitPolicy_QoSLimitIOPSPerGB) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{148, 2}
}

func (x *QoSRateLimitPolicy_QoSLimitIOPSPerGB) GetWriteIOPSPerGBLimit() uint32 {
	if x != nil {
		return x.WriteIOPSPerGBLimit
	}
	return 0
}

func (x *QoSRateLimitPolicy_QoSLimitIOPSPerGB) GetReadIOPSPerGBLimit() uint32 {
	if x != nil {
		return x.ReadIOPSPerGBLimit
	}
	return 0
}

type GetClusterRootKeyResponse_KeyObject struct {
	state protoimpl.MessageState `protogen:"open.v1"`
	// encryptedKey
	//
	// Cluster Encryption key encrypted with the given public key.
	EncryptedKey []byte `protobuf:"bytes,1,opt,name=encryptedKey,proto3" json:"encryptedKey,omitempty"`
	// encryptingKeyGeneration
	//
	// The Generation of the exported key.
	EncryptingKeyGeneration uint64 `protobuf:"varint,2,opt,name=encryptingKeyGeneration,proto3" json:"encryptingKeyGeneration,omitempty"`
	unknownFields           protoimpl.UnknownFields
	sizeCache               protoimpl.SizeCache
}

func (x *GetClusterRootKeyResponse_KeyObject) Reset() {
	*x = GetClusterRootKeyResponse_KeyObject{}
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[193]
	ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
	ms.StoreMessageInfo(mi)
}

func (x *GetClusterRootKeyResponse_KeyObject) String() string {
	return protoimpl.X.MessageStringOf(x)
}

func (*GetClusterRootKeyResponse_KeyObject) ProtoMessage() {}

func (x *GetClusterRootKeyResponse_KeyObject) ProtoReflect() protoreflect.Message {
	mi := &file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[193]
	if x != nil {
		ms := protoimpl.X.MessageStateOf(protoimpl.Pointer(x))
		if ms.LoadMessageInfo() == nil {
			ms.StoreMessageInfo(mi)
		}
		return ms
	}
	return mi.MessageOf(x)
}

// Deprecated: Use GetClusterRootKeyResponse_KeyObject.ProtoReflect.Descriptor instead.
func (*GetClusterRootKeyResponse_KeyObject) Descriptor() ([]byte, []int) {
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP(), []int{158, 0}
}

func (x *GetClusterRootKeyResponse_KeyObject) GetEncryptedKey() []byte {
	if x != nil {
		return x.EncryptedKey
	}
	return nil
}

func (x *GetClusterRootKeyResponse_KeyObject) GetEncryptingKeyGeneration() uint64 {
	if x != nil {
		return x.EncryptingKeyGeneration
	}
	return 0
}

var File_lightbits_api_duros_v2_durosapiv2_proto protoreflect.FileDescriptor

const file_lightbits_api_duros_v2_durosapiv2_proto_rawDesc = "" +
	"\n" +
	"'lightbits/api/duros/v2/durosapiv2.proto\x12\x16lightbits.api.duros.v2\x1a\x1fgoogle/protobuf/timestamp.proto\x1a\x1egoogle/protobuf/duration.proto\x1a\x1cgoogle/api/annotations.proto\x1a\x19google/api/httpbody.proto\x1a9grpc/gateway/protoc_gen_swagger/options/annotations.proto\x1a,lightbits/api/duros/v2/statisticsapiv2.proto\x1a,lightbits/api/duros/v2/schedule_policy.proto\x1a%lightbits/api/duros/v2/security.proto\x1a#lightbits/api/duros/v2/labels.proto\x1a'lightbits/api/duros/v2/authz_mode.proto\x1a'lightbits/api/duros/v2/proxy_info.proto\x1a\x1flightbits/api/duros/v2/cf.proto\"\x9e\x04\n" +
	"\n" +
	"LogRequest\x12&\n" +
	"\x0eSkipStatistics\x18\x01 \x01(\bR\x0eSkipStatistics\x122\n" +
	"\x14CaptureCpuAndTcpDump\x18\x02 \x01(\bR\x14CaptureCpuAndTcpDump\x126\n" +
	"\x16NumOfDaysToCollectLogs\x18\x03 \x01(\rR\x16NumOfDaysToCollectLogs\x12:\n" +
	"\x18CollectServicesLbcliEtcd\x18\x04 \x01(\bR\x18CollectServicesLbcliEtcd\x12@\n" +
	"\x1bIntervalBetweenBEReadCycles\x18\x05 \x01(\rR\x1bIntervalBetweenBEReadCycles\x12(\n" +
	"\x0fDontCollectlogs\x18\x06 \x01(\bR\x0fDontCollectlogs\x12 \n" +
	"\vLogFilename\x18\a \x01(\tR\vLogFilename\x12:\n" +
	"\x18NumOfstatisticsToCapture\x18\b \x01(\rR\x18NumOfstatisticsToCapture\x12.\n" +
	"\x12DontCompressOutput\x18\t \x01(\bR\x12DontCompressOutput\x12\x16\n" +
	"\x06IoNice\x18\n" +
	" \x01(\bR\x06IoNice\x12.\n" +
	"\x12UseHighCompression\x18\v \x01(\bR\x12UseHighCompression\"I\n" +
	"\rAdminEndpoint\x12\x12\n" +
	"\x04port\x18\x01 \x01(\rR\x04port\x12\x10\n" +
	"\x03ips\x18\x02 \x03(\tR\x03ips\x12\x12\n" +
	"\x04ETag\x18\x03 \x01(\tR\x04ETag\";\n" +
	"\x17GetAdminEndpointRequest\x12\x12\n" +
	"\x04port\x18\x01 \x01(\rR\x04port:\f\x92A\t\n" +
	"\a\xd2\x01\x04port\"k\n" +
	"\x1aListAdminEndpointsResponse\x12M\n" +
	"\x0eadminEndpoints\x18\x01 \x03(\v2%.lightbits.api.duros.v2.AdminEndpointR\x0eadminEndpoints\"/\n" +
	"\x19ListAdminEndpointsRequest\x12\x12\n" +
	"\x04port\x18\x01 \x01(\rR\x04port\"V\n" +
	"\x1aCreateAdminEndpointRequest\x12\x12\n" +
	"\x04port\x18\x01 \x01(\rR\x04port\x12\x10\n" +
	"\x03ips\x18\x02 \x03(\tR\x03ips:\x12\x92A\x0f\n" +
	"\r\xd2\x01\x04port\xd2\x01\x03ips\"V\n" +
	"\x1aUpdateAdminEndpointRequest\x12\x12\n" +
	"\x04port\x18\x01 \x01(\rR\x04port\x12\x10\n" +
	"\x03ips\x18\x02 \x03(\tR\x03ips:\x12\x92A\x0f\n" +
	"\r\xd2\x01\x04port\xd2\x01\x03ips\">\n" +
	"\x1aDeleteAdminEndpointRequest\x12\x12\n" +
	"\x04port\x18\x01 \x01(\rR\x04port:\f\x92A\t\n" +
	"\a\xd2\x01\x04port\"\x1d\n" +
	"\x1bDeleteAdminEndpointResponse\"\xc7\x01\n" +
	"\x17CreateCredentialRequest\x12 \n" +
	"\vprojectName\x18\x01 \x01(\tR\vprojectName\x12\x0e\n" +
	"\x02ID\x18\x02 \x01(\tR\x02ID\x125\n" +
	"\x04type\x18\x03 \x01(\x0e2!.lightbits.api.duros.v2.CredsTypeR\x04type\x12\x18\n" +
	"\apayload\x18\x04 \x01(\fR\apayload:)\x92A&\n" +
	"$\xd2\x01\vprojectName\xd2\x01\x02ID\xd2\x01\x04type\xd2\x01\apayload\"\xc6\x01\n" +
	"\n" +
	"Credential\x12 \n" +
	"\vprojectName\x18\x01 \x01(\tR\vprojectName\x12\x0e\n" +
	"\x02ID\x18\x02 \x01(\tR\x02ID\x125\n" +
	"\x04type\x18\x03 \x01(\x0e2!.lightbits.api.duros.v2.CredsTypeR\x04type\x12\x18\n" +
	"\apayload\x18\x04 \x01(\fR\apayload\x125\n" +
	"\x04kind\x18\x05 \x01(\x0e2!.lightbits.api.duros.v2.CredsKindR\x04kind\"e\n" +
	"\x17DeleteCredentialRequest\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName:\x18\x92A\x15\n" +
	"\x13\xd2\x01\x02ID\xd2\x01\vprojectName\"\x1a\n" +
	"\x18DeleteCredentialResponse\"O\n" +
	"\x16ListCredentialsRequest\x12 \n" +
	"\vprojectName\x18\x01 \x01(\tR\vprojectName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"_\n" +
	"\x17ListCredentialsResponse\x12D\n" +
	"\vcredentials\x18\x01 \x03(\v2\".lightbits.api.duros.v2.CredentialR\vcredentials\"b\n" +
	"\x14GetCredentialRequest\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName:\x18\x92A\x15\n" +
	"\x13\xd2\x01\x02ID\xd2\x01\vprojectName\"s\n" +
	"\rDefaultPolicy\x12B\n" +
	"\n" +
	"policyType\x18\x01 \x01(\x0e2\".lightbits.api.duros.v2.PolicyTypeR\n" +
	"policyType\x12\x1e\n" +
	"\n" +
	"policyUUID\x18\x02 \x01(\tR\n" +
	"policyUUID\"\xab\x01\n" +
	"\x14CreateProjectRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12O\n" +
	"\x0fdefaultPolicies\x18\x03 \x03(\v2%.lightbits.api.duros.v2.DefaultPolicyR\x0fdefaultPolicies:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"\xa4\x01\n" +
	"\aProject\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12O\n" +
	"\x0fdefaultPolicies\x18\x04 \x03(\v2%.lightbits.api.duros.v2.DefaultPolicyR\x0fdefaultPolicies\"8\n" +
	"\x14DeleteProjectRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"\x17\n" +
	"\x15DeleteProjectResponse\"\x15\n" +
	"\x13ListProjectsRequest\"S\n" +
	"\x14ListProjectsResponse\x12;\n" +
	"\bprojects\x18\x01 \x03(\v2\x1f.lightbits.api.duros.v2.ProjectR\bprojects\"5\n" +
	"\x11GetProjectRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"$\n" +
	"\n" +
	"StringList\x12\x16\n" +
	"\x06values\x18\x01 \x03(\tR\x06values\"\x13\n" +
	"\x11GetVersionRequest\"\x99\a\n" +
	"\x13CreateVolumeRequest\x122\n" +
	"\x04name\x18\x01 \x01(\tB\x1e\x92A\x1b\x8a\x01\x18^[a-zA-Z0-9-_\\.]{1,253}$R\x04name\x12\x12\n" +
	"\x04size\x18\x02 \x01(\tR\x04size\x124\n" +
	"\x03acl\x18\x03 \x01(\v2\".lightbits.api.duros.v2.StringListR\x03acl\x12 \n" +
	"\vcompression\x18\x04 \x01(\tR\vcompression\x12\"\n" +
	"\freplicaCount\x18\x05 \x01(\rR\freplicaCount\x128\n" +
	"\x05IPAcl\x18\x06 \x01(\v2\".lightbits.api.duros.v2.StringListR\x05IPAcl\x12 \n" +
	"\vminReplicas\x18\a \x01(\rR\vminReplicas\x12Z\n" +
	"\n" +
	"sectorSize\x18\b \x01(\x0e2:.lightbits.api.duros.v2.CreateVolumeRequest.SectorSizeEnumR\n" +
	"sectorSize\x12 \n" +
	"\vprojectName\x18\t \x01(\tR\vprojectName\x12.\n" +
	"\x12sourceSnapshotUUID\x18\n" +
	" \x01(\tR\x12sourceSnapshotUUID\x12.\n" +
	"\x12sourceSnapshotName\x18\v \x01(\tR\x12sourceSnapshotName\x12b\n" +
	"\x15placementRestrictions\x18\f \x03(\v2,.lightbits.api.duros.v2.LabelMatchExpressionR\x15placementRestrictions\x12&\n" +
	"\rqosPolicyUUID\x18\r \x01(\tH\x00R\rqosPolicyUUID\x12&\n" +
	"\rqosPolicyName\x18\x0e \x01(\tH\x00R\rqosPolicyName\x125\n" +
	"\x06labels\x18\x0f \x03(\v2\x1d.lightbits.api.duros.v2.LabelR\x06labels\"R\n" +
	"\x0eSectorSizeEnum\x12\x16\n" +
	"\x12sectorSize_Default\x10\x00\x12\x14\n" +
	"\x0fsectorSize_512B\x10\x80\x04\x12\x12\n" +
	"\rsectorSize_4K\x10\x80 :6\x92A3\n" +
	"1\xd2\x01\x04name\xd2\x01\x04size\xd2\x01\x03acl\xd2\x01\freplicaCount\xd2\x01\vprojectNameB\r\n" +
	"\vqosPolicyID\"t\n" +
	"\x13DeleteVolumeRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"\x16\n" +
	"\x14DeleteVolumeResponse\"=\n" +
	"\x13EnableServerRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\xd5\x01\n" +
	"\x14DisableServerRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\"\n" +
	"\fForceDisable\x18\x02 \x01(\bR\fForceDisable\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x1c\n" +
	"\tevictData\x18\x04 \x01(\bR\tevictData\x12S\n" +
	"\x17permanentFailureTimeout\x18\x05 \x01(\v2\x19.google.protobuf.DurationR\x17permanentFailureTimeout\"_\n" +
	"\x13DeleteServerRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vforceDelete\x18\x03 \x01(\bR\vforceDelete\"\xb4\x01\n" +
	"\x12ReplaceNodeRequest\x12 \n" +
	"\vSrcNodeUUID\x18\x01 \x01(\tR\vSrcNodeUUID\x12&\n" +
	"\x0eTargetNodeUUID\x18\x02 \x01(\tR\x0eTargetNodeUUID\x12.\n" +
	"\x12ReplaceWhileActive\x18\x03 \x01(\bR\x12ReplaceWhileActive:$\x92A!\n" +
	"\x1f\xd2\x01\vSrcNodeUUID\xd2\x01\x0eTargetNodeUUID\"\xc5\x01\n" +
	"\x13CreateServerRequest\x12(\n" +
	"\x0fserverEndpoints\x18\x01 \x03(\tR\x0fserverEndpoints\x12\x1e\n" +
	"\n" +
	"serverUUID\x18\x02 \x01(\tR\n" +
	"serverUUID\x12\x18\n" +
	"\areuseIP\x18\x03 \x01(\bR\areuseIP\x12$\n" +
	"\rextendCluster\x18\x04 \x01(\bR\rextendCluster:$\x92A!\n" +
	"\x1f\xd2\x01\x0fserverEndpoints\xd2\x01\n" +
	"serverUUID\"\xe0\x03\n" +
	"\x13UpdateVolumeRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x124\n" +
	"\x03acl\x18\x02 \x01(\v2\".lightbits.api.duros.v2.StringListR\x03acl\x128\n" +
	"\x05IPAcl\x18\x03 \x01(\v2\".lightbits.api.duros.v2.StringListR\x05IPAcl\x12\x12\n" +
	"\x04size\x18\x04 \x01(\tR\x04size\x12 \n" +
	"\vcompression\x18\x05 \x01(\tR\vcompression\x12 \n" +
	"\vprojectName\x18\x06 \x01(\tR\vprojectName\x12&\n" +
	"\rqosPolicyUUID\x18\a \x01(\tH\x00R\rqosPolicyUUID\x12&\n" +
	"\rqosPolicyName\x18\b \x01(\tH\x00R\rqosPolicyName\x12\x14\n" +
	"\x05Force\x18\t \x01(\bR\x05Force\x12\x12\n" +
	"\x04name\x18\n" +
	" \x01(\tR\x04name\x125\n" +
	"\x06labels\x18\v \x03(\v2\x1d.lightbits.api.duros.v2.LabelR\x06labels\x12\x18\n" +
	"\anewName\x18\f \x01(\tR\anewName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectNameB\r\n" +
	"\vqosPolicyID\"\xd3\x01\n" +
	"\x14UpgradeServerRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12$\n" +
	"\rInstallPkgUri\x18\x02 \x01(\tR\rInstallPkgUri\x12\"\n" +
	"\fForceUpgrade\x18\x03 \x01(\bR\fForceUpgrade\x12?\n" +
	"\tProxyInfo\x18\x04 \x01(\v2!.lightbits.api.duros.v2.ProxyInfoR\tProxyInfo:\x1c\x92A\x19\n" +
	"\x17\xd2\x01\x04UUID\xd2\x01\rInstallPkgUri\"\xab\x01\n" +
	"\x15UpgradeClusterRequest\x12$\n" +
	"\rInstallPkgUri\x18\x01 \x01(\tR\rInstallPkgUri\x12\x14\n" +
	"\x05UUIDs\x18\x02 \x03(\tR\x05UUIDs\x12?\n" +
	"\tProxyInfo\x18\x03 \x01(\v2!.lightbits.api.duros.v2.ProxyInfoR\tProxyInfo:\x15\x92A\x12\n" +
	"\x10\xd2\x01\rInstallPkgUri\"\x9c\x01\n" +
	"\x1eEnableClusterEncryptionRequest\x12[\n" +
	"\bkeyStore\x18\x01 \x01(\x0e2?.lightbits.api.duros.v2.EnableClusterEncryptionRequest.KeyStoreR\bkeyStore\"\x1d\n" +
	"\bKeyStore\x12\b\n" +
	"\x04file\x10\x00\x12\a\n" +
	"\x03tpm\x10\x01\"\x13\n" +
	"\x11GetClusterRequest\"\xad\x01\n" +
	"\x17UpdateNvmeDeviceRequest\x12\x1e\n" +
	"\n" +
	"serverUUID\x18\x01 \x01(\tR\n" +
	"serverUUID\x12\"\n" +
	"\fserialNumber\x18\x02 \x01(\tR\fserialNumber\x12\x1e\n" +
	"\n" +
	"ledPattern\x18\x03 \x01(\tR\n" +
	"ledPattern:.\x92A+\n" +
	")\xd2\x01\n" +
	"serverUUID\xd2\x01\fserialNumber\xd2\x01\n" +
	"ledPattern\"w\n" +
	"\x14AddNvmeDeviceRequest\x12\"\n" +
	"\fserialNumber\x18\x01 \x01(\tR\fserialNumber\x12\x1a\n" +
	"\bnodeUUID\x18\x02 \x01(\tR\bnodeUUID:\x1f\x92A\x1c\n" +
	"\x1a\xd2\x01\fserialNumber\xd2\x01\bnodeUUID\";\n" +
	"\x0eGetHostRequest\x12\x18\n" +
	"\ahostNQN\x18\x01 \x01(\tR\ahostNQN:\x0f\x92A\f\n" +
	"\n" +
	"\xd2\x01\ahostNQN\"L\n" +
	"\x10ListHostsRequest\x12\x18\n" +
	"\ahostNQN\x18\x01 \x01(\tR\ahostNQN\x12\x1e\n" +
	"\n" +
	"volumeUUID\x18\x02 \x01(\tR\n" +
	"volumeUUID\"b\n" +
	"\x11ListHostsResponse\x12M\n" +
	"\x0econnectedHosts\x18\x01 \x03(\v2%.lightbits.api.duros.v2.ConnectedHostR\x0econnectedHosts\"_\n" +
	"\x0fListNodeRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04UUID\x18\x02 \x01(\tR\x04UUID\x12$\n" +
	"\rfailureDomain\x18\x03 \x01(\tR\rfailureDomain\"\xd7\x01\n" +
	"\x11ListEventsRequest\x12 \n" +
	"\vprojectName\x18\x01 \x01(\tR\vprojectName\x12\x1c\n" +
	"\tnextToken\x18\x02 \x01(\tR\tnextToken\x12\x14\n" +
	"\x05since\x18\x03 \x01(\tR\x05since\x12\x14\n" +
	"\x05until\x18\x04 \x01(\tR\x05until\x12\x14\n" +
	"\x05limit\x18\x06 \x01(\x03R\x05limit\x12\x1a\n" +
	"\bseverity\x18\a \x03(\tR\bseverity\x12$\n" +
	"\rcomponentType\x18\b \x01(\tR\rcomponentType\"i\n" +
	"\x12ListEventsResponse\x125\n" +
	"\x06events\x18\x01 \x03(\v2\x1d.lightbits.api.duros.v2.EventR\x06events\x12\x1c\n" +
	"\tnextToken\x18\x02 \x01(\tR\tnextToken\"q\n" +
	"\x10GetVolumeRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"2\n" +
	"\x0eGetNodeRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID:\f\x92A\t\n" +
	"\a\xd2\x01\x04UUID\"\xf7\x01\n" +
	"\x11ListVolumeRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12$\n" +
	"\rfailureDomain\x18\x03 \x01(\tR\rfailureDomain\x12\x1e\n" +
	"\n" +
	"offsetUUID\x18\x04 \x01(\tR\n" +
	"offsetUUID\x12\x14\n" +
	"\x05limit\x18\x05 \x01(\x03R\x05limit\x12 \n" +
	"\vprojectName\x18\x06 \x01(\tR\vprojectName\x12\"\n" +
	"\fsnapshotUUID\x18\a \x01(\tR\fsnapshotUUID\x12\x18\n" +
	"\ashowAll\x18\b \x01(\bR\ashowAll\"\xb9\x01\n" +
	"\x16ListNvmeDevicesRequest\x12\x1a\n" +
	"\bnodeUUID\x18\x01 \x01(\tR\bnodeUUID\x12\x1e\n" +
	"\n" +
	"serverUUID\x18\x02 \x01(\tR\n" +
	"serverUUID\x12c\n" +
	"\fdeviceUsages\x18\x03 \x03(\x0e2?.lightbits.api.duros.v2.UserNvmeDevicesResponse.DeviceUsageEnumR\fdeviceUsages\">\n" +
	"\x14GetNvmeDeviceRequest\x12\x16\n" +
	"\x06Serial\x18\x01 \x01(\tR\x06Serial:\x0e\x92A\v\n" +
	"\t\xd2\x01\x06Serial\"l\n" +
	"\x17ListNvmeDevicesResponse\x12Q\n" +
	"\vNvmeDevices\x18\x01 \x03(\v2/.lightbits.api.duros.v2.UserNvmeDevicesResponseR\vNvmeDevices\"\x85\x01\n" +
	"\rConnectedHost\x12\x18\n" +
	"\ahostNQN\x18\x01 \x01(\tR\ahostNQN\x12\x1c\n" +
	"\tiPAddress\x18\x02 \x01(\tR\tiPAddress\x12\x1a\n" +
	"\bhostname\x18\x03 \x01(\tR\bhostname\x12 \n" +
	"\vvolumeUUIDs\x18\x04 \x03(\tR\vvolumeUUIDs\"\x8e\x06\n" +
	"\x17UserNvmeDevicesResponse\x12\x12\n" +
	"\x04size\x18\x01 \x01(\x04R\x04size\x12\x1e\n" +
	"\n" +
	"numaNodeID\x18\x02 \x01(\x04R\n" +
	"numaNodeID\x12\x14\n" +
	"\x05model\x18\x03 \x01(\tR\x05model\x12\x16\n" +
	"\x06serial\x18\x04 \x01(\tR\x06serial\x12\x1e\n" +
	"\n" +
	"serverUUID\x18\x05 \x01(\tR\n" +
	"serverUUID\x12O\n" +
	"\x05state\x18\x06 \x01(\x0e29.lightbits.api.duros.v2.UserNvmeDevicesResponse.StateEnumR\x05state\x12<\n" +
	"\vfailureTime\x18\a \x01(\v2\x1a.google.protobuf.TimestampR\vfailureTime\x12P\n" +
	"\x15rebuildCompletionTime\x18\b \x01(\v2\x1a.google.protobuf.TimestampR\x15rebuildCompletionTime\x12\x12\n" +
	"\x04name\x18\t \x01(\tR\x04name\x12\x1a\n" +
	"\bnodeUUID\x18\f \x01(\tR\bnodeUUID\x12\x12\n" +
	"\x04ETag\x18\r \x01(\tR\x04ETag\x12O\n" +
	"\n" +
	"statistics\x18\x0e \x01(\v2/.lightbits.api.duros.v2.NvmeDeviceStatisticsApiR\n" +
	"statistics\x12a\n" +
	"\vdeviceUsage\x18\x0f \x01(\x0e2?.lightbits.api.duros.v2.UserNvmeDevicesResponse.DeviceUsageEnumR\vdeviceUsage\"J\n" +
	"\tStateEnum\x12\b\n" +
	"\x04None\x10\x00\x12\v\n" +
	"\aHealthy\x10\x01\x12\n" +
	"\n" +
	"\x06Adding\x10\x02\x12\x0e\n" +
	"\n" +
	"Rebuilding\x10\x03\x12\n" +
	"\n" +
	"\x06Failed\x10\x04\"L\n" +
	"\x0fDeviceUsageEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\b\n" +
	"\x04Data\x10\x01\x12\v\n" +
	"\aJournal\x10\x02\x12\x06\n" +
	"\x02OS\x10\x03\x12\r\n" +
	"\tUnManaged\x10\x04\"\xd1\t\n" +
	"\rDurosNodeInfo\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x12\n" +
	"\x04UUID\x18\x02 \x01(\tR\x04UUID\x12A\n" +
	"\x05state\x18\x03 \x01(\x0e2+.lightbits.api.duros.v2.DurosNodeInfo.StateR\x05state\x12H\n" +
	"\x06status\x18\x04 \x01(\x0e20.lightbits.api.duros.v2.DurosNodeInfo.StatusEnumR\x06status\x12\"\n" +
	"\fnvmeEndpoint\x18\x05 \x01(\tR\fnvmeEndpoint\x12&\n" +
	"\x0efailureDomains\x18\x06 \x03(\tR\x0efailureDomains\x12 \n" +
	"\vfailureInfo\x18\a \x01(\tR\vfailureInfo\x12\x1a\n" +
	"\bhostname\x18\t \x01(\tR\bhostname\x12&\n" +
	"\x0einLocalRebuild\x18\n" +
	" \x01(\bR\x0einLocalRebuild\x122\n" +
	"\x14localRebuildProgress\x18\v \x01(\rR\x14localRebuildProgress\x12,\n" +
	"\x11numManagedDevices\x18\f \x01(\x05R\x11numManagedDevices\x12&\n" +
	"\x0emaxNvmeDevices\x18\r \x01(\rR\x0emaxNvmeDevices\x12\x0e\n" +
	"\x02ec\x18\x0e \x01(\bR\x02ec\x12I\n" +
	"\n" +
	"statistics\x18\x0f \x01(\v2).lightbits.api.duros.v2.NodeStatisticsApiR\n" +
	"statistics\x12\x1e\n" +
	"\n" +
	"serverUUID\x18\x10 \x01(\tR\n" +
	"serverUUID\x12\x12\n" +
	"\x04ETag\x18\x11 \x01(\tR\x04ETag\x12\x1a\n" +
	"\breadOnly\x18\x12 \x01(\bR\breadOnly\x12(\n" +
	"\x0fpowerupProgress\x18\x13 \x01(\rR\x0fpowerupProgress\x12*\n" +
	"\x10permanentFailure\x18\x14 \x01(\bR\x10permanentFailure\x126\n" +
	"\x15journalDeviceNotFound\x18\x15 \x01(\tH\x00R\x15journalDeviceNotFound\x12Y\n" +
	"\x11journalNvmeDevice\x18\x16 \x01(\v2).lightbits.api.duros.v2.JournalNvmeDeviceH\x00R\x11journalNvmeDevice\x12Y\n" +
	"\x11journalRaidDevice\x18\x17 \x01(\v2).lightbits.api.duros.v2.JournalRaidDeviceH\x00R\x11journalRaidDevice\"l\n" +
	"\x05State\x12\v\n" +
	"\aUnknown\x10\x00\x12\n" +
	"\n" +
	"\x06Active\x10\x01\x12\x0e\n" +
	"\n" +
	"Activating\x10\x02\x12\f\n" +
	"\bInactive\x10\x03\x12\x0e\n" +
	"\n" +
	"Unattached\x10\x04\x12\r\n" +
	"\tAttaching\x10\x06\x12\r\n" +
	"\tDetaching\x10\a\"]\n" +
	"\n" +
	"StatusEnum\x12\f\n" +
	"\bNoStatus\x10\x00\x12\x12\n" +
	"\x0eConnectivityOK\x10\x01\x12\x17\n" +
	"\x13ConnectivityProblem\x10\x02\x12\x14\n" +
	"\x10IssuedDeletePeer\x10\x03B\x13\n" +
	"\x11JournalDeviceInfo\"e\n" +
	"\x11JournalRaidDevice\x12\x1e\n" +
	"\n" +
	"deviceUUID\x18\x01 \x01(\tR\n" +
	"deviceUUID\x120\n" +
	"\x13memberDeviceSerials\x18\x02 \x03(\tR\x13memberDeviceSerials\"7\n" +
	"\x11JournalNvmeDevice\x12\"\n" +
	"\fdeviceSerial\x18\x01 \x01(\tR\fdeviceSerial\"P\n" +
	"\x11ListNodesResponse\x12;\n" +
	"\x05nodes\x18\x01 \x03(\v2%.lightbits.api.duros.v2.DurosNodeInfoR\x05nodes\"O\n" +
	"\x13ListVolumesResponse\x128\n" +
	"\avolumes\x18\x01 \x03(\v2\x1e.lightbits.api.duros.v2.VolumeR\avolumes\"\x1a\n" +
	"\x18UpdateNvmeDeviceResponse\"\x17\n" +
	"\x15AddNvmeDeviceResponse\"\x16\n" +
	"\x14UpdateVolumeResponse\"\x17\n" +
	"\x15UpgradeServerResponse\"\x18\n" +
	"\x16UpgradeClusterResponse\"!\n" +
	"\x1fEnableClusterEncryptionResponse\"\x15\n" +
	"\x13ReplaceNodeResponse\"\x16\n" +
	"\x14DeleteServerResponse\"\x17\n" +
	"\x15DisableServerResponse\"6\n" +
	"\x18StartNodeInstanceRequest\x12\x1a\n" +
	"\bnodeUUID\x18\x01 \x01(\tR\bnodeUUID\"\x1b\n" +
	"\x19StartNodeInstanceResponse\"K\n" +
	"\x17StopNodeInstanceRequest\x12\x1a\n" +
	"\bnodeUUID\x18\x01 \x01(\tR\bnodeUUID\x12\x14\n" +
	"\x05force\x18\x02 \x01(\bR\x05force\"\x1a\n" +
	"\x18StopNodeInstanceResponse\"x\n" +
	"\x1aRestartNodeInstanceRequest\x12\x1a\n" +
	"\bnodeUUID\x18\x01 \x01(\tR\bnodeUUID\x12(\n" +
	"\x0fconsiderBackend\x18\x02 \x01(\bR\x0fconsiderBackend\x12\x14\n" +
	"\x05force\x18\x03 \x01(\bR\x05force\"\x1d\n" +
	"\x1bRestartNodeInstanceResponse\"\xa0\x01\n" +
	"\x12ListServersRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\x12b\n" +
	"\x11RiskOfServiceLoss\x18\x03 \x01(\x0e24.lightbits.api.duros.v2.Server.RiskOfServiceLossEnumR\x11RiskOfServiceLoss\"4\n" +
	"\x10GetServerRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID:\f\x92A\t\n" +
	"\a\xd2\x01\x04UUID\"O\n" +
	"\x13ListServersResponse\x128\n" +
	"\aservers\x18\x01 \x03(\v2\x1e.lightbits.api.duros.v2.ServerR\aservers\"]\n" +
	"\x1cClusterUpgradeStatusResponse\x12=\n" +
	"\acluster\x18\x01 \x01(\v2#.lightbits.api.duros.v2.ClusterInfoR\acluster\"U\n" +
	"\x19ListUpgradeStatusResponse\x128\n" +
	"\aservers\x18\x01 \x03(\v2\x1e.lightbits.api.duros.v2.ServerR\aservers\")\n" +
	"\aVersion\x12\x1e\n" +
	"\n" +
	"apiVersion\x18\x04 \x01(\tR\n" +
	"apiVersion\"\xbc\x03\n" +
	"\x12ClusterLastUpgrade\x12T\n" +
	"\x06Status\x18\x01 \x01(\x0e2<.lightbits.api.duros.v2.ClusterLastUpgrade.UpgradeStatusEnumR\x06Status\x128\n" +
	"\tStartTime\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tStartTime\x124\n" +
	"\aEndTime\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\aEndTime\x12$\n" +
	"\rTargetVersion\x18\x04 \x01(\tR\rTargetVersion\x12\"\n" +
	"\fErrorMessage\x18\x05 \x01(\tR\fErrorMessage\x12\"\n" +
	"\fProgressStep\x18\x06 \x01(\rR\fProgressStep\x12$\n" +
	"\rProgressTotal\x18\a \x01(\rR\rProgressTotal\"L\n" +
	"\x11UpgradeStatusEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\b\n" +
	"\x04None\x10\x01\x12\x11\n" +
	"\rUpgradeFailed\x10\x02\x12\r\n" +
	"\tUpgrading\x10\x03\"\x94\b\n" +
	"\vClusterInfo\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\"\n" +
	"\fsubsystemNQN\x18\x02 \x01(\tR\fsubsystemNQN\x12.\n" +
	"\x12currentMaxReplicas\x18\x03 \x01(\rR\x12currentMaxReplicas\x122\n" +
	"\x14supportedMaxReplicas\x18\x04 \x01(\rR\x14supportedMaxReplicas\x12L\n" +
	"\n" +
	"statistics\x18\x05 \x01(\v2,.lightbits.api.duros.v2.ClusterStatisticsApiR\n" +
	"statistics\x12\x12\n" +
	"\x04ETag\x18\x06 \x01(\tR\x04ETag\x12=\n" +
	"\x06health\x18\a \x01(\v2%.lightbits.api.duros.v2.ClusterHealthR\x06health\x120\n" +
	"\x13MinVersionInCluster\x18\b \x01(\tR\x13MinVersionInCluster\x12,\n" +
	"\x11MinAllowedVersion\x18\t \x01(\tR\x11MinAllowedVersion\x12,\n" +
	"\x11MaxAllowedVersion\x18\n" +
	" \x01(\tR\x11MaxAllowedVersion\x12\"\n" +
	"\fapiEndpoints\x18\v \x03(\tR\fapiEndpoints\x12.\n" +
	"\x12discoveryEndpoints\x18\f \x03(\tR\x12discoveryEndpoints\x12 \n" +
	"\vclusterName\x18\r \x01(\tR\vclusterName\x12L\n" +
	"\vlastUpgrade\x18\x0e \x01(\v2*.lightbits.api.duros.v2.ClusterLastUpgradeR\vlastUpgrade\x12^\n" +
	"\x0einBandAuthMode\x18\x0f \x01(\x0e26.lightbits.api.duros.v2.ClusterInfo.AuthenticationModeR\x0einBandAuthMode\x12[\n" +
	"\x10encryptionStatus\x18\x10 \x01(\v2/.lightbits.api.duros.v2.ClusterEncryptionStatusR\x10encryptionStatus\x12{\n" +
	"\x1dfederatedAuthenticationStatus\x18\x11 \x01(\v25.lightbits.api.duros.v2.FederatedAuthenticationStatusR\x1dfederatedAuthenticationStatus\"<\n" +
	"\x12AuthenticationMode\x12\v\n" +
	"\aUnKnown\x10\x00\x12\v\n" +
	"\aEnabled\x10\x02\x12\f\n" +
	"\bDisabled\x10\x03\"\xe6\x04\n" +
	"\rClusterInfoV2\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\"\n" +
	"\fsubsystemNQN\x18\x02 \x01(\tR\fsubsystemNQN\x12.\n" +
	"\x12currentMaxReplicas\x18\x03 \x01(\rR\x12currentMaxReplicas\x122\n" +
	"\x14supportedMaxReplicas\x18\x04 \x01(\rR\x14supportedMaxReplicas\x12\x12\n" +
	"\x04ETag\x18\x06 \x01(\tR\x04ETag\x12\"\n" +
	"\fapiEndpoints\x18\v \x03(\tR\fapiEndpoints\x12.\n" +
	"\x12discoveryEndpoints\x18\f \x03(\tR\x12discoveryEndpoints\x12$\n" +
	"\rnvmeEndpoints\x18\r \x03(\tR\rnvmeEndpoints\x12 \n" +
	"\vclusterName\x18\x0e \x01(\tR\vclusterName\x12L\n" +
	"\vlastUpgrade\x18\x0f \x01(\v2*.lightbits.api.duros.v2.ClusterLastUpgradeR\vlastUpgrade\x12[\n" +
	"\x10encryptionStatus\x18\x10 \x01(\v2/.lightbits.api.duros.v2.ClusterEncryptionStatusR\x10encryptionStatus\x12^\n" +
	"\x0einBandAuthMode\x18\x11 \x01(\x0e26.lightbits.api.duros.v2.ClusterInfo.AuthenticationModeR\x0einBandAuthMode\"\xf7\x02\n" +
	"\rClusterHealth\x12A\n" +
	"\x05state\x18\x01 \x01(\x0e2+.lightbits.api.duros.v2.ClusterHealth.StateR\x05state\x12.\n" +
	"\x12numDegradedVolumes\x18\x02 \x01(\rR\x12numDegradedVolumes\x12.\n" +
	"\x12numReadOnlyVolumes\x18\x03 \x01(\rR\x12numReadOnlyVolumes\x126\n" +
	"\x16numNotAvailableVolumes\x18\x04 \x01(\rR\x16numNotAvailableVolumes\x12*\n" +
	"\x10numInactiveNodes\x18\x05 \x01(\rR\x10numInactiveNodes\x12,\n" +
	"\x11numHealthyVolumes\x18\x06 \x01(\rR\x11numHealthyVolumes\"1\n" +
	"\x05State\x12\b\n" +
	"\x04None\x10\x00\x12\x06\n" +
	"\x02OK\x10\x01\x12\v\n" +
	"\aWarning\x10\x02\x12\t\n" +
	"\x05Error\x10\x03\"\xc8\n" +
	"\n" +
	"\x06Volume\x12>\n" +
	"\x05state\x18\x01 \x01(\x0e2(.lightbits.api.duros.v2.Volume.StateEnumR\x05state\x12U\n" +
	"\x0fprotectionState\x18\x02 \x01(\x0e2+.lightbits.api.duros.v2.ProtectionStateEnumR\x0fprotectionState\x12\"\n" +
	"\freplicaCount\x18\x03 \x01(\rR\freplicaCount\x12\x1a\n" +
	"\bnodeList\x18\x04 \x03(\tR\bnodeList\x12\x12\n" +
	"\x04UUID\x18\x05 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04nsid\x18\x06 \x01(\rR\x04nsid\x124\n" +
	"\x03acl\x18\a \x01(\v2\".lightbits.api.duros.v2.StringListR\x03acl\x12 \n" +
	"\vcompression\x18\b \x01(\tR\vcompression\x12\x12\n" +
	"\x04size\x18\t \x01(\x04R\x04size\x12\x12\n" +
	"\x04name\x18\n" +
	" \x01(\tR\x04name\x12(\n" +
	"\x0frebuildProgress\x18\v \x01(\tR\x0frebuildProgress\x12K\n" +
	"\n" +
	"statistics\x18\f \x01(\v2+.lightbits.api.duros.v2.VolumeStatisticsApiR\n" +
	"statistics\x128\n" +
	"\x05IPAcl\x18\r \x01(\v2\".lightbits.api.duros.v2.StringListR\x05IPAcl\x12\x12\n" +
	"\x04ETag\x18\x0e \x01(\tR\x04ETag\x12&\n" +
	"\x0econnectedHosts\x18\x0f \x03(\tR\x0econnectedHosts\x12\x1e\n" +
	"\n" +
	"sectorSize\x18\x10 \x01(\rR\n" +
	"sectorSize\x12 \n" +
	"\vprojectName\x18\x11 \x01(\tR\vprojectName\x12.\n" +
	"\x12sourceSnapshotUUID\x18\x12 \x01(\tR\x12sourceSnapshotUUID\x12.\n" +
	"\x12sourceSnapshotName\x18\x13 \x01(\tR\x12sourceSnapshotName\x12b\n" +
	"\x15placementRestrictions\x18\x14 \x03(\v2,.lightbits.api.duros.v2.LabelMatchExpressionR\x15placementRestrictions\x12$\n" +
	"\rqosPolicyUUID\x18\x15 \x01(\tR\rqosPolicyUUID\x12$\n" +
	"\rqosPolicyName\x18\x16 \x01(\tR\rqosPolicyName\x12(\n" +
	"\x0fprimaryNodeUUID\x18\x17 \x01(\tR\x0fprimaryNodeUUID\x12>\n" +
	"\fcreationTime\x18\x18 \x01(\v2\x1a.google.protobuf.TimestampR\fcreationTime\x125\n" +
	"\x06labels\x18\x19 \x03(\v2\x1d.lightbits.api.duros.v2.LabelR\x06labels\x12\x1c\n" +
	"\tclusterId\x18\x1a \x01(\tR\tclusterId\x12\x16\n" +
	"\x06pgUUID\x18\x1b \x01(\tR\x06pgUUID\"\x87\x01\n" +
	"\tStateEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\f\n" +
	"\bCreating\x10\x01\x12\r\n" +
	"\tAvailable\x10\x02\x12\f\n" +
	"\bDeleting\x10\x03\x12\v\n" +
	"\aDeleted\x10\x04\x12\n" +
	"\n" +
	"\x06Failed\x10\a\x12\f\n" +
	"\bUpdating\x10\b\x12\f\n" +
	"\bRollback\x10\t\x12\r\n" +
	"\tMigrating\x10\n" +
	"\"\x1f\n" +
	"\fProtocolEnum\x12\x0f\n" +
	"\vProtocolTCP\x10\x00\"\xf3\x02\n" +
	"\x14ServerEvictionStatus\x12O\n" +
	"\x06status\x18\x01 \x01(\x0e27.lightbits.api.duros.v2.ServerEvictionStatus.StatusEnumR\x06status\x128\n" +
	"\tstartTime\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tstartTime\x124\n" +
	"\aendTime\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\aendTime\x12\"\n" +
	"\ferrorMessage\x18\x04 \x01(\tR\ferrorMessage\x12\x1a\n" +
	"\bprogress\x18\x05 \x01(\rR\bprogress\"Z\n" +
	"\n" +
	"StatusEnum\x12\b\n" +
	"\x04None\x10\x00\x12\n" +
	"\n" +
	"\x06Failed\x10\x01\x12\f\n" +
	"\bEvicting\x10\x02\x12\f\n" +
	"\bAborting\x10\x03\x12\r\n" +
	"\tCompleted\x10\x04\x12\v\n" +
	"\aAborted\x10\x05\"\xd9\x03\n" +
	"\x11ServerLastUpgrade\x12S\n" +
	"\x06Status\x18\x01 \x01(\x0e2;.lightbits.api.duros.v2.ServerLastUpgrade.UpgradeStatusEnumR\x06Status\x128\n" +
	"\tStartTime\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\tStartTime\x124\n" +
	"\aEndTime\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\aEndTime\x12$\n" +
	"\rTargetVersion\x18\x04 \x01(\tR\rTargetVersion\x12\"\n" +
	"\fErrorMessage\x18\x05 \x01(\tR\fErrorMessage\x12\"\n" +
	"\fProgressStep\x18\x06 \x01(\rR\fProgressStep\x12$\n" +
	"\rProgressTotal\x18\a \x01(\rR\rProgressTotal\"k\n" +
	"\x11UpgradeStatusEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\b\n" +
	"\x04None\x10\x01\x12\x11\n" +
	"\rUpgradeFailed\x10\x02\x12\r\n" +
	"\tUpgrading\x10\x03\x12\r\n" +
	"\tRebooting\x10\x04\x12\x0e\n" +
	"\n" +
	"Recovering\x10\x05\"\xf1\t\n" +
	"\x06Server\x12\x12\n" +
	"\x04UUID\x18\x02 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12l\n" +
	"\x16RiskOfServiceLossState\x18\x04 \x01(\x0e24.lightbits.api.duros.v2.Server.RiskOfServiceLossEnumR\x16RiskOfServiceLossState\x12\x1e\n" +
	"\n" +
	"NodesUUIDs\x18\x05 \x03(\tR\n" +
	"NodesUUIDs\x12D\n" +
	"\x05state\x18\x06 \x01(\x0e2..lightbits.api.duros.v2.Server.ServerStateEnumR\x05state\x12(\n" +
	"\x0fServerEndpoints\x18\a \x03(\tR\x0fServerEndpoints\x12\x12\n" +
	"\x04ETag\x18\b \x01(\tR\x04ETag\x12&\n" +
	"\x0eLightOSVersion\x18\t \x01(\tR\x0eLightOSVersion\x12V\n" +
	"\rUpgradeStatus\x18\n" +
	" \x01(\x0e20.lightbits.api.duros.v2.Server.UpgradeStatusEnumR\rUpgradeStatus\x12\"\n" +
	"\fApiEndpoints\x18\v \x03(\tR\fApiEndpoints\x12K\n" +
	"\vLastUpgrade\x18\f \x01(\v2).lightbits.api.duros.v2.ServerLastUpgradeR\vLastUpgrade\x12\x1c\n" +
	"\tIsWitness\x18\r \x01(\bR\tIsWitness\x12P\n" +
	"\fLastEviction\x18\x0e \x01(\v2,.lightbits.api.duros.v2.ServerEvictionStatusR\fLastEviction\x12C\n" +
	"\x06health\x18\x0f \x01(\x0e2+.lightbits.api.duros.v2.ClusterHealth.StateR\x06health\x12a\n" +
	"\x1eServerPermanenetFailureTimeout\x18\x10 \x01(\v2\x19.google.protobuf.DurationR\x1eServerPermanenetFailureTimeout\x12(\n" +
	"\x0ftpm2IsSupported\x18\x11 \x01(\bR\x0ftpm2IsSupported\"k\n" +
	"\x11UpgradeStatusEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\b\n" +
	"\x04None\x10\x01\x12\x11\n" +
	"\rUpgradeFailed\x10\x02\x12\r\n" +
	"\tUpgrading\x10\x03\x12\r\n" +
	"\tRebooting\x10\x04\x12\x0e\n" +
	"\n" +
	"Recovering\x10\x05\"\x86\x01\n" +
	"\x15RiskOfServiceLossEnum\x12\x1c\n" +
	"\x18UnknownRiskOfServiceLoss\x10\x00\x12\x17\n" +
	"\x13NoRiskOfServiceLoss\x10\x01\x12\x17\n" +
	"\x13InRiskOfServiceLoss\x10\x02\x12\x1d\n" +
	"\x19SourceOfRiskOfServiceLoss\x10\x03\"\x83\x01\n" +
	"\x0fServerStateEnum\x12\x10\n" +
	"\fUnknownState\x10\x00\x12\f\n" +
	"\bCreating\x10\x01\x12\v\n" +
	"\aEnabled\x10\x02\x12\f\n" +
	"\bDeleting\x10\x03\x12\n" +
	"\n" +
	"\x06Failed\x10\x04\x12\f\n" +
	"\bDisabled\x10\x05\x12\f\n" +
	"\bEnabling\x10\x06\x12\r\n" +
	"\tDisabling\x10\a\"b\n" +
	"\x0eGetRoleRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName:\x1a\x92A\x17\n" +
	"\x15\xd2\x01\x04name\xd2\x01\vprojectName\"C\n" +
	"\x0fGetRoleResponse\x120\n" +
	"\x04role\x18\x01 \x01(\v2\x1c.lightbits.api.duros.v2.RoleR\x04role\"Z\n" +
	"\x04Role\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName\x12\x1c\n" +
	"\trulesJson\x18\x04 \x01(\tR\trulesJson\"I\n" +
	"\x10ListRolesRequest\x12 \n" +
	"\vprojectName\x18\x01 \x01(\tR\vprojectName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"G\n" +
	"\x11ListRolesResponse\x122\n" +
	"\x05roles\x18\x01 \x03(\v2\x1c.lightbits.api.duros.v2.RoleR\x05roles\"\x83\b\n" +
	"\bSnapshot\x12@\n" +
	"\x05state\x18\x01 \x01(\x0e2*.lightbits.api.duros.v2.Snapshot.StateEnumR\x05state\x12\x12\n" +
	"\x04UUID\x18\x02 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription\x12>\n" +
	"\fcreationTime\x18\x05 \x01(\v2\x1a.google.protobuf.TimestampR\fcreationTime\x12?\n" +
	"\rretentionTime\x18\x06 \x01(\v2\x19.google.protobuf.DurationR\rretentionTime\x12*\n" +
	"\x10sourceVolumeUUID\x18\a \x01(\tR\x10sourceVolumeUUID\x12*\n" +
	"\x10sourceVolumeName\x18\b \x01(\tR\x10sourceVolumeName\x12\"\n" +
	"\freplicaCount\x18\t \x01(\rR\freplicaCount\x12\x1a\n" +
	"\bnodeList\x18\n" +
	" \x03(\tR\bnodeList\x12\x12\n" +
	"\x04nsid\x18\v \x01(\rR\x04nsid\x124\n" +
	"\x03acl\x18\f \x01(\v2\".lightbits.api.duros.v2.StringListR\x03acl\x12 \n" +
	"\vcompression\x18\r \x01(\bR\vcompression\x12\x12\n" +
	"\x04size\x18\x0e \x01(\x04R\x04size\x128\n" +
	"\x05IPAcl\x18\x0f \x01(\v2\".lightbits.api.duros.v2.StringListR\x05IPAcl\x12\x1e\n" +
	"\n" +
	"sectorSize\x18\x10 \x01(\rR\n" +
	"sectorSize\x12M\n" +
	"\n" +
	"statistics\x18\x12 \x01(\v2-.lightbits.api.duros.v2.SnapshotStatisticsApiR\n" +
	"statistics\x12\x12\n" +
	"\x04ETag\x18\x13 \x01(\tR\x04ETag\x12 \n" +
	"\vprojectName\x18\x14 \x01(\tR\vprojectName\x12(\n" +
	"\x0fprimaryNodeUUID\x18\x15 \x01(\tR\x0fprimaryNodeUUID\x125\n" +
	"\x06labels\x18\x16 \x03(\v2\x1d.lightbits.api.duros.v2.LabelR\x06labels\x12\x1c\n" +
	"\tclusterId\x18\x17 \x01(\tR\tclusterId\x12\x16\n" +
	"\x06pgUUID\x18\x18 \x01(\tR\x06pgUUID\"\\\n" +
	"\tStateEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\f\n" +
	"\bCreating\x10\x01\x12\r\n" +
	"\tAvailable\x10\x02\x12\f\n" +
	"\bDeleting\x10\x03\x12\v\n" +
	"\aDeleted\x10\x04\x12\n" +
	"\n" +
	"\x06Failed\x10\a\"v\n" +
	"\x15DeleteSnapshotRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"\xa4\x02\n" +
	"\x15CreateSnapshotRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12*\n" +
	"\x10sourceVolumeUUID\x18\x02 \x01(\tR\x10sourceVolumeUUID\x12*\n" +
	"\x10sourceVolumeName\x18\x03 \x01(\tR\x10sourceVolumeName\x12?\n" +
	"\rretentionTime\x18\x04 \x01(\v2\x19.google.protobuf.DurationR\rretentionTime\x12 \n" +
	"\vdescription\x18\x05 \x01(\tR\vdescription\x12 \n" +
	"\vprojectName\x18\x06 \x01(\tR\vprojectName:\x1a\x92A\x17\n" +
	"\x15\xd2\x01\x04name\xd2\x01\vprojectName\"\xc5\x01\n" +
	"\x14ListSnapshotsRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName\x12\x1e\n" +
	"\n" +
	"offsetUUID\x18\x04 \x01(\tR\n" +
	"offsetUUID\x12\x14\n" +
	"\x05limit\x18\x05 \x01(\x03R\x05limit\x12\x18\n" +
	"\ashowAll\x18\x06 \x01(\bR\ashowAll:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"s\n" +
	"\x12GetSnapshotRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"W\n" +
	"\x15ListSnapshotsResponse\x12>\n" +
	"\tsnapshots\x18\x01 \x03(\v2 .lightbits.api.duros.v2.SnapshotR\tsnapshots\"\x18\n" +
	"\x16DeleteSnapshotResponse\"A\n" +
	"\x11FeatureFlagStatus\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x18\n" +
	"\aenabled\x18\x02 \x01(\bR\aenabled\"9\n" +
	"\x15GetFeatureFlagRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"<\n" +
	"\x18EnableFeatureFlagRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"=\n" +
	"\x19DisableFeatureFlagRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"\x18\n" +
	"\x16SetFeatureFlagResponse\"\x19\n" +
	"\x17ListFeatureFlagsRequest\"\xee\x01\n" +
	"\x18ListFeatureFlagsResponse\x12f\n" +
	"\ffeatureFlags\x18\x01 \x03(\v2B.lightbits.api.duros.v2.ListFeatureFlagsResponse.FeatureFlagsEntryR\ffeatureFlags\x1aj\n" +
	"\x11FeatureFlagsEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12?\n" +
	"\x05value\x18\x02 \x01(\v2).lightbits.api.duros.v2.FeatureFlagStatusR\x05value:\x028\x01\"\xac\x02\n" +
	"\x1bCreateResourcePolicyRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\fresourceUUID\x18\x02 \x01(\tR\fresourceUUID\x12\"\n" +
	"\fresourceName\x18\x03 \x01(\tR\fresourceName\x12 \n" +
	"\vprojectName\x18\x04 \x01(\tR\vprojectName\x12N\n" +
	"\x0eschedulePolicy\x18\x05 \x01(\v2&.lightbits.api.duros.v2.SchedulePolicyR\x0eschedulePolicy\x12 \n" +
	"\vdescription\x18\x06 \x01(\tR\vdescription:\x1d\x92A\x1a\n" +
	"\x18\xd2\x01\x04name\xd2\x01\x0eschedulePolicy\"\xc1\x01\n" +
	"\x13CreatePolicyRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x02 \x01(\tR\vdescription\x12\\\n" +
	"\x12qoSRateLimitPolicy\x18\x03 \x01(\v2*.lightbits.api.duros.v2.QoSRateLimitPolicyH\x00R\x12qoSRateLimitPolicy:\f\x92A\t\n" +
	"\a\xd2\x01\x04nameB\b\n" +
	"\x06policy\"\xc7\x01\n" +
	"\x13UpdatePolicyRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12\\\n" +
	"\x12qoSRateLimitPolicy\x18\x04 \x01(\v2*.lightbits.api.duros.v2.QoSRateLimitPolicyH\x00R\x12qoSRateLimitPolicyB\b\n" +
	"\x06policy\"\x16\n" +
	"\x14UpdatePolicyResponse\"\xa7\x03\n" +
	"\x0eResourcePolicy\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\"\n" +
	"\fresourceUUID\x18\x03 \x01(\tR\fresourceUUID\x12\"\n" +
	"\fresourceName\x18\x04 \x01(\tR\fresourceName\x12 \n" +
	"\vprojectName\x18\x05 \x01(\tR\vprojectName\x12N\n" +
	"\x0eschedulePolicy\x18\x06 \x01(\v2&.lightbits.api.duros.v2.SchedulePolicyR\x0eschedulePolicy\x12 \n" +
	"\vdescription\x18\a \x01(\tR\vdescription\x12B\n" +
	"\x05state\x18\b \x01(\x0e2,.lightbits.api.duros.v2.ResourcePolicy.StateR\x05state\"M\n" +
	"\x05State\x12\x10\n" +
	"\fUnknownState\x10\x00\x12\f\n" +
	"\bCreating\x10\x01\x12\n" +
	"\n" +
	"\x06Active\x10\x02\x12\f\n" +
	"\bDeleting\x10\x03\x12\n" +
	"\n" +
	"\x06Failed\x10\x04\"\xce\x02\n" +
	"\x06Policy\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vdescription\x18\x03 \x01(\tR\vdescription\x12:\n" +
	"\x05state\x18\x04 \x01(\x0e2$.lightbits.api.duros.v2.Policy.StateR\x05state\x12\\\n" +
	"\x12QoSRateLimitPolicy\x18\x05 \x01(\v2*.lightbits.api.duros.v2.QoSRateLimitPolicyH\x00R\x12QoSRateLimitPolicy\"X\n" +
	"\x05State\x12\v\n" +
	"\aUnknown\x10\x00\x12\f\n" +
	"\bCreating\x10\x01\x12\n" +
	"\n" +
	"\x06Active\x10\x02\x12\f\n" +
	"\bUpdating\x10\x03\x12\x0e\n" +
	"\n" +
	"Deprecated\x10\x04\x12\n" +
	"\n" +
	"\x06Failed\x10\x05B\x06\n" +
	"\x04info\"\xe4\x01\n" +
	"\x1bUpdateResourcePolicyRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName\x12N\n" +
	"\x0eschedulePolicy\x18\x03 \x01(\v2&.lightbits.api.duros.v2.SchedulePolicyR\x0eschedulePolicy\x12 \n" +
	"\vdescription\x18\x04 \x01(\tR\vdescription:\x1d\x92A\x1a\n" +
	"\x18\xd2\x01\x04UUID\xd2\x01\x0eschedulePolicy\"\x1e\n" +
	"\x1cUpdateResourcePolicyResponse\"_\n" +
	"\x13ListPoliciesRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName\"R\n" +
	"\x14ListPoliciesResponse\x12:\n" +
	"\bpolicies\x18\x01 \x03(\v2\x1e.lightbits.api.duros.v2.PolicyR\bpolicies\"s\n" +
	"\x1bListResourcePoliciesRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName\x12\x1e\n" +
	"\n" +
	"volumeUUID\x18\x03 \x01(\tR\n" +
	"volumeUUID\"\xe1\x01\n" +
	"\x1cListResourcePoliciesResponse\x12R\n" +
	"\x10resourcePolicies\x18\x01 \x03(\v2&.lightbits.api.duros.v2.ResourcePolicyR\x10resourcePolicies\x12m\n" +
	"\x17defaultResourcePolicies\x18\x02 \x03(\v23.lightbits.api.duros.v2.DefaultGlobalResourcePolicyR\x17defaultResourcePolicies\"\\\n" +
	"\x10GetPolicyRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName\"^\n" +
	"\x18GetResourcePolicyRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12 \n" +
	"\vprojectName\x18\x02 \x01(\tR\vprojectName:\f\x92A\t\n" +
	"\a\xd2\x01\x04UUID\"a\n" +
	"\x1bDeleteResourcePolicyRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName:\f\x92A\t\n" +
	"\a\xd2\x01\x04UUID\"\x1e\n" +
	"\x1cDeleteResourcePolicyResponse\"=\n" +
	"\x13DeletePolicyRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\"\x16\n" +
	"\x14DeletePolicyResponse\"@\n" +
	"\x1cGetClusterConfigParamRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\">\n" +
	"\x12ClusterConfigParam\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"\x84\x01\n" +
	"\x1fUpdateClusterConfigParamRequest\x12L\n" +
	"\vconfigParam\x18\x01 \x01(\v2*.lightbits.api.duros.v2.ClusterConfigParamR\vconfigParam:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vconfigParam\"\xca\x01\n" +
	"\x15RollbackVolumeRequest\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12(\n" +
	"\x0fsrcSnapshotUUID\x18\x02 \x01(\tR\x0fsrcSnapshotUUID\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName\x12\x12\n" +
	"\x04Name\x18\x04 \x01(\tR\x04Name\x12(\n" +
	"\x0fsrcSnapshotName\x18\x05 \x01(\tR\x0fsrcSnapshotName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"\x18\n" +
	"\x16RollbackVolumeResponse\"\"\n" +
	" UpdateClusterConfigParamResponse\" \n" +
	"\x1eListClusterConfigParamsRequest\"e\n" +
	"\x1fListClusterConfigParamsResponse\x12B\n" +
	"\x06values\x18\x01 \x03(\v2*.lightbits.api.duros.v2.ClusterConfigParamR\x06values\"\xa4\x01\n" +
	"\x11LabelValueKeyPair\x12?\n" +
	"\x03key\x18\x01 \x01(\x0e2-.lightbits.api.duros.v2.LabelValueKeyPair.KeyR\x03key\x12\x14\n" +
	"\x05value\x18\x02 \x01(\tR\x05value\"8\n" +
	"\x03Key\x12\v\n" +
	"\aUnknown\x10\x00\x12\x06\n" +
	"\x02FD\x10\x01\x12\r\n" +
	"\tPrimaryFD\x10\x02\x12\r\n" +
	"\tClusterID\x10\x03\"\xe5\x01\n" +
	"\x14LabelMatchExpression\x12Q\n" +
	"\boperator\x18\x01 \x01(\x0e25.lightbits.api.duros.v2.LabelMatchExpression.OperatorR\boperator\x12Y\n" +
	"\x12labelValueKeyPairs\x18\x02 \x03(\v2).lightbits.api.duros.v2.LabelValueKeyPairR\x12labelValueKeyPairs\"\x1f\n" +
	"\bOperator\x12\v\n" +
	"\aUnknown\x10\x00\x12\x06\n" +
	"\x02In\x10\x01\"9\n" +
	"\x13ComponentVolumeInfo\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\"\x80\x01\n" +
	"\x17VolumeComponentInfoList\x12e\n" +
	"\x17VolumeComponentInfoList\x18\x01 \x03(\v2+.lightbits.api.duros.v2.ComponentVolumeInfoR\x17VolumeComponentInfoList\"\x80\x02\n" +
	"\x14ComponentVolumesInfo\x12q\n" +
	"\x11ProjectVolumesMap\x18\x01 \x03(\v2C.lightbits.api.duros.v2.ComponentVolumesInfo.ProjectVolumesMapEntryR\x11ProjectVolumesMap\x1au\n" +
	"\x16ProjectVolumesMapEntry\x12\x10\n" +
	"\x03key\x18\x01 \x01(\tR\x03key\x12E\n" +
	"\x05value\x18\x02 \x01(\v2/.lightbits.api.duros.v2.VolumeComponentInfoListR\x05value:\x028\x01\"7\n" +
	"\x11ComponentNodeInfo\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\":\n" +
	"\x14ComponentClusterInfo\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\":\n" +
	"\x14ComponentNVMeSSDInfo\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\"9\n" +
	"\x13ComponentServerInfo\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12\x12\n" +
	"\x04Name\x18\x02 \x01(\tR\x04Name\"l\n" +
	"\x1aComponentDataIntegrityInfo\x12\x1a\n" +
	"\bNodeUUID\x18\x01 \x01(\tR\bNodeUUID\x12\x1e\n" +
	"\n" +
	"ServerUUID\x18\x02 \x01(\tR\n" +
	"ServerUUID\x12\x12\n" +
	"\x04SSDs\x18\x03 \x03(\tR\x04SSDs\"^\n" +
	"\bLBARange\x12\x1a\n" +
	"\blbaStart\x18\x01 \x01(\x04R\blbaStart\x12\x16\n" +
	"\x06lbaEnd\x18\x02 \x01(\x04R\x06lbaEnd\x12\x1e\n" +
	"\n" +
	"dataBitMap\x18\x03 \x01(\fR\n" +
	"dataBitMap\"\x8f\x02\n" +
	"\x18ListChangedBlocksRequest\x12\"\n" +
	"\fsnapshotUUID\x18\x01 \x01(\tR\fsnapshotUUID\x12*\n" +
	"\x10baseSnapshotUUID\x18\x02 \x01(\tR\x10baseSnapshotUUID\x12 \n" +
	"\vprojectName\x18\x03 \x01(\tR\vprojectName\x12\x1c\n" +
	"\toffsetLBA\x18\x04 \x01(\x04R\toffsetLBA\x12\"\n" +
	"\fsnapshotName\x18\x05 \x01(\tR\fsnapshotName\x12*\n" +
	"\x10baseSnapshotName\x18\x06 \x01(\tR\x10baseSnapshotName:\x13\x92A\x10\n" +
	"\x0e\xd2\x01\vprojectName\"\x81\x01\n" +
	"\x19ListChangedBlocksResponse\x12$\n" +
	"\rnextOffsetLBA\x18\x01 \x01(\x04R\rnextOffsetLBA\x12>\n" +
	"\tlbaRanges\x18\x02 \x03(\v2 .lightbits.api.duros.v2.LBARangeR\tlbaRanges\"\x9c\v\n" +
	"\x05Event\x12\x0e\n" +
	"\x02ID\x18\x01 \x01(\tR\x02ID\x12.\n" +
	"\x04Time\x18\x02 \x01(\v2\x1a.google.protobuf.TimestampR\x04Time\x12;\n" +
	"\x04Type\x18\x03 \x01(\x0e2'.lightbits.api.duros.v2.Event.EventTypeR\x04Type\x12G\n" +
	"\bSeverity\x18\x04 \x01(\x0e2+.lightbits.api.duros.v2.Event.EventSeverityR\bSeverity\x12\x1c\n" +
	"\tEventName\x18\x05 \x01(\tR\tEventName\x12\x1c\n" +
	"\tEventCode\x18\x06 \x01(\rR\tEventCode\x12_\n" +
	"\x10ReportingService\x18\a \x01(\x0e23.lightbits.api.duros.v2.Event.EventReportingServiceR\x10ReportingService\x12,\n" +
	"\x11AssociatedEventID\x18\b \x01(\tR\x11AssociatedEventID\x12\x16\n" +
	"\x06Status\x18\t \x01(\tR\x06Status\x12\x1c\n" +
	"\tCauseCode\x18\n" +
	" \x01(\rR\tCauseCode\x12 \n" +
	"\vDescription\x18\v \x01(\tR\vDescription\x12c\n" +
	"\x14ComponentVolumesInfo\x18\xc9\x01 \x01(\v2,.lightbits.api.duros.v2.ComponentVolumesInfoH\x00R\x14ComponentVolumesInfo\x12c\n" +
	"\x14ComponentNVMeSSDInfo\x18\xca\x01 \x01(\v2,.lightbits.api.duros.v2.ComponentNVMeSSDInfoH\x00R\x14ComponentNVMeSSDInfo\x12Z\n" +
	"\x11ComponentNodeInfo\x18\xcb\x01 \x01(\v2).lightbits.api.duros.v2.ComponentNodeInfoH\x00R\x11ComponentNodeInfo\x12`\n" +
	"\x13ComponentServerInfo\x18\xcc\x01 \x01(\v2+.lightbits.api.duros.v2.ComponentServerInfoH\x00R\x13ComponentServerInfo\x12c\n" +
	"\x14ComponentClusterInfo\x18\xcd\x01 \x01(\v2,.lightbits.api.duros.v2.ComponentClusterInfoH\x00R\x14ComponentClusterInfo\x12u\n" +
	"\x1aComponentDataIntegrityInfo\x18\xce\x01 \x01(\v22.lightbits.api.duros.v2.ComponentDataIntegrityInfoH\x00R\x1aComponentDataIntegrityInfo\"\x82\x01\n" +
	"\tEventType\x12\x0f\n" +
	"\vUnknownType\x10\x00\x12\v\n" +
	"\aCluster\x10\x01\x12\b\n" +
	"\x04Node\x10\x02\x12\n" +
	"\n" +
	"\x06Volume\x10\x03\x12\v\n" +
	"\aNVMeSSD\x10\x04\x12\n" +
	"\n" +
	"\x06Server\x10\x05\x12\x11\n" +
	"\rDataIntegrity\x10\x06\x12\x15\n" +
	"\x11ClusterEncryption\x10\a\"T\n" +
	"\x15EventReportingService\x12\x1a\n" +
	"\x16UnkownReportingService\x10\x00\x12\x06\n" +
	"\x02CM\x10\x01\x12\x06\n" +
	"\x02NM\x10\x02\x12\a\n" +
	"\x03API\x10\x03\x12\x06\n" +
	"\x02UM\x10\x04\"Z\n" +
	"\rEventSeverity\x12\x12\n" +
	"\x0eUnkownSeverity\x10\x00\x12\b\n" +
	"\x04Info\x10\x01\x12\a\n" +
	"\x03Low\x10\x02\x12\n" +
	"\n" +
	"\x06Medium\x10\x03\x12\b\n" +
	"\x04High\x10\x04\x12\f\n" +
	"\bCritical\x10\x05B\x0f\n" +
	"\rComponentInfo\"\xe3\x05\n" +
	"\x12QoSRateLimitPolicy\x12.\n" +
	"\x12projectsNamesScope\x18\x03 \x03(\tR\x12projectsNamesScope\x12T\n" +
	"\x10policyVisibility\x18\x04 \x01(\x0e2(.lightbits.api.duros.v2.PolicyVisibilityR\x10policyVisibility\x12W\n" +
	"\tlimitIOPS\x18\x06 \x01(\v27.lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitIOPSH\x00R\tlimitIOPS\x12Q\n" +
	"\alimitBw\x18\a \x01(\v25.lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitBWH\x00R\alimitBw\x12f\n" +
	"\x0elimitIOPSPerGB\x18\b \x01(\v2<.lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitIOPSPerGBH\x00R\x0elimitIOPSPerGB\x1a\\\n" +
	"\fQoSLimitIOPS\x12&\n" +
	"\x0ewriteIOPSLimit\x18\x01 \x01(\rR\x0ewriteIOPSLimit\x12$\n" +
	"\rreadIOPSLimit\x18\x02 \x01(\rR\rreadIOPSLimit\x1aR\n" +
	"\n" +
	"QoSLimitBW\x12\"\n" +
	"\fwriteBWLimit\x18\x01 \x01(\rR\fwriteBWLimit\x12 \n" +
	"\vreadBWLimit\x18\x02 \x01(\rR\vreadBWLimit\x1au\n" +
	"\x11QoSLimitIOPSPerGB\x120\n" +
	"\x13writeIOPSPerGBLimit\x18\x01 \x01(\rR\x13writeIOPSPerGBLimit\x12.\n" +
	"\x12readIOPSPerGBLimit\x18\x02 \x01(\rR\x12readIOPSPerGBLimitB\n" +
	"\n" +
	"\bQoSLimit\"\x81\x01\n" +
	"\x1bDefaultGlobalResourcePolicy\x12B\n" +
	"\n" +
	"policyType\x18\x01 \x01(\x0e2\".lightbits.api.duros.v2.PolicyTypeR\n" +
	"policyType\x12\x1e\n" +
	"\n" +
	"policyUUID\x18\x02 \x01(\tR\n" +
	"policyUUID\"\xb0\x01\n" +
	"\x14UpdateProjectRequest\x12 \n" +
	"\vprojectName\x18\x01 \x01(\tR\vprojectName\x12O\n" +
	"\x0fdefaultPolicies\x18\x02 \x03(\v2%.lightbits.api.duros.v2.DefaultPolicyR\x0fdefaultPolicies:%\x92A\"\n" +
	" \xd2\x01\vprojectName\xd2\x01\x0fdefaultPolicies\"\x17\n" +
	"\x15UpdateProjectResponse\"\xa1\x04\n" +
	"\x17ClusterEncryptionStatus\x12_\n" +
	"\x0fencryptionState\x18\x01 \x01(\x0e25.lightbits.api.duros.v2.ClusterEncryptionStatus.StateR\x0fencryptionState\x12$\n" +
	"\rkekGeneration\x18\x02 \x01(\x04R\rkekGeneration\x12@\n" +
	"\rkekUpdateDate\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\rkekUpdateDate\x126\n" +
	"\x16previousKekGenerations\x18\x04 \x03(\x04R\x16previousKekGenerations\x12c\n" +
	"\rrotationState\x18\x05 \x01(\x0e2=.lightbits.api.duros.v2.ClusterEncryptionStatus.RotationStateR\rrotationState\"=\n" +
	"\x05State\x12\f\n" +
	"\bDisabled\x10\x00\x12\f\n" +
	"\bEnabling\x10\x01\x12\v\n" +
	"\aEnabled\x10\x02\x12\v\n" +
	"\aUnknown\x10\x03\"a\n" +
	"\rRotationState\x12\x0e\n" +
	"\n" +
	"NoRotation\x10\x00\x12\x13\n" +
	"\x0fDistributingKEK\x10\x01\x12\x12\n" +
	"\x0eEncryptingDEKs\x10\x02\x12\x13\n" +
	"\x0fEncryptyingDEKs\x10\x02\x1a\x02\x10\x01\"\xec\x01\n" +
	"\rIdpHealthInfo\x12\x1e\n" +
	"\n" +
	"serverName\x18\x01 \x01(\tR\n" +
	"serverName\x12Q\n" +
	"\x0fidpHealthStatus\x18\x02 \x01(\x0e2'.lightbits.api.duros.v2.IdpHealthStatusR\x0fidpHealthStatus\x128\n" +
	"\ttimestamp\x18\x03 \x01(\v2\x1a.google.protobuf.TimestampR\ttimestamp\x12.\n" +
	"\x12healthErrorMessage\x18\x04 \x01(\tR\x12healthErrorMessage\"\xb6\x01\n" +
	"\x1dFederatedAuthenticationStatus\x12F\n" +
	"\x1efederatedAuthenticationEnabled\x18\x01 \x01(\bR\x1efederatedAuthenticationEnabled\x12M\n" +
	"\x0eidpHealthInfos\x18\x02 \x03(\v2%.lightbits.api.duros.v2.IdpHealthInfoR\x0eidpHealthInfos\"\x1d\n" +
	"\x1bRotateClusterRootKeyRequest\"\x1e\n" +
	"\x1cRotateClusterRootKeyResponse\"\x91\x01\n" +
	"\x18GetClusterRootKeyRequest\x128\n" +
	"\x17encryptingKeyGeneration\x18\x01 \x01(\x04R\x17encryptingKeyGeneration\x12$\n" +
	"\ruserPublicKey\x18\x02 \x01(\fR\ruserPublicKey:\x15\x92A\x12\n" +
	"\x10\xd2\x01\ruserPublicKey\"\xd5\x01\n" +
	"\x19GetClusterRootKeyResponse\x12M\n" +
	"\x03key\x18\x01 \x01(\v2;.lightbits.api.duros.v2.GetClusterRootKeyResponse.KeyObjectR\x03key\x1ai\n" +
	"\tKeyObject\x12\"\n" +
	"\fencryptedKey\x18\x01 \x01(\fR\fencryptedKey\x128\n" +
	"\x17encryptingKeyGeneration\x18\x02 \x01(\x04R\x17encryptingKeyGeneration\"\x84\x03\n" +
	"\x10IDPConfiguration\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\fidpIssuerURL\x18\x02 \x01(\tR\fidpIssuerURL\x12T\n" +
	"\x05state\x18\x03 \x01(\x0e2>.lightbits.api.duros.v2.IDPConfiguration.IDPConfigurationStateR\x05state\x123\n" +
	"\x04type\x18\x04 \x01(\x0e2\x1f.lightbits.api.duros.v2.IDPTypeR\x04type\x12\x12\n" +
	"\x04UUID\x18\x05 \x01(\tR\x04UUID\x12?\n" +
	"\tproxyInfo\x18\x06 \x01(\v2!.lightbits.api.duros.v2.ProxyInfoR\tproxyInfo\"X\n" +
	"\x15IDPConfigurationState\x12\v\n" +
	"\aUnknown\x10\x00\x12\f\n" +
	"\bCreating\x10\x01\x12\n" +
	"\n" +
	"\x06Active\x10\x02\x12\f\n" +
	"\bUpdating\x10\x03\x12\n" +
	"\n" +
	"\x06Failed\x10\x04\"\xf1\x01\n" +
	"\x1dCreateIDPConfigurationRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\fidpIssuerURL\x18\x02 \x01(\tR\fidpIssuerURL\x123\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1f.lightbits.api.duros.v2.IDPTypeR\x04type\x12?\n" +
	"\tproxyInfo\x18\x04 \x01(\v2!.lightbits.api.duros.v2.ProxyInfoR\tproxyInfo:\"\x92A\x1f\n" +
	"\x1d\xd2\x01\x04name\xd2\x01\fidpIssuerURL\xd2\x01\x04type\"\xdb\x01\n" +
	"\x1dUpdateIDPConfigurationRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\"\n" +
	"\fidpIssuerURL\x18\x02 \x01(\tR\fidpIssuerURL\x123\n" +
	"\x04type\x18\x03 \x01(\x0e2\x1f.lightbits.api.duros.v2.IDPTypeR\x04type\x12?\n" +
	"\tproxyInfo\x18\x04 \x01(\v2!.lightbits.api.duros.v2.ProxyInfoR\tproxyInfo:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"\x1e\n" +
	"\x1cListIDPConfigurationsRequest\"w\n" +
	"\x1dListIDPConfigurationsResponse\x12V\n" +
	"\x11idpConfigurations\x18\x01 \x03(\v2(.lightbits.api.duros.v2.IDPConfigurationR\x11idpConfigurations\">\n" +
	"\x1aGetIDPConfigurationRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"A\n" +
	"\x1dDeleteIDPConfigurationRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\" \n" +
	"\x1eDeleteIDPConfigurationResponse\"\xee\x01\n" +
	"\rIdpClientConf\x12\x12\n" +
	"\x04UUID\x18\x01 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x02 \x01(\tR\x04name\x12\x1a\n" +
	"\bclientId\x18\x03 \x01(\tR\bclientId\x122\n" +
	"\x14idpConfigurationName\x18\x04 \x01(\tR\x14idpConfigurationName\x12\x1c\n" +
	"\tclaimName\x18\x05 \x01(\tR\tclaimName\x12G\n" +
	"\tauthzMode\x18\x06 \x01(\x0e2).lightbits.api.duros.v2.AuthorizationModeR\tauthzMode\"\xa3\x02\n" +
	"\x1aCreateIdpClientConfRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1a\n" +
	"\bclientId\x18\x02 \x01(\tR\bclientId\x122\n" +
	"\x14idpConfigurationName\x18\x03 \x01(\tR\x14idpConfigurationName\x12\x1c\n" +
	"\tclaimName\x18\x04 \x01(\tR\tclaimName\x12G\n" +
	"\tauthzMode\x18\x05 \x01(\x0e2).lightbits.api.duros.v2.AuthorizationModeR\tauthzMode::\x92A7\n" +
	"5\xd2\x01\x04name\xd2\x01\bclientId\xd2\x01\x14idpConfigurationName\xd2\x01\tauthzMode\"h\n" +
	"\x1aUpdateIdpClientConfRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1c\n" +
	"\tclaimName\x18\x02 \x01(\tR\tclaimName:\x18\x92A\x15\n" +
	"\x13\xd2\x01\x04name\xd2\x01\tclaimName\";\n" +
	"\x17GetIdpClientConfRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\">\n" +
	"\x1aDeleteIdpClientConfRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"\x1d\n" +
	"\x1bDeleteIdpClientConfResponse\"\x1b\n" +
	"\x19ListIdpClientConfsRequest\"}\n" +
	"\x1aListIdpClientConfsResponse\x12_\n" +
	"\x17idpClientConfigurations\x18\x01 \x03(\v2%.lightbits.api.duros.v2.IdpClientConfR\x17idpClientConfigurations\"\xc1\x01\n" +
	"\fAuthMapEntry\x12\x12\n" +
	"\x04UUID\x18\x02 \x01(\tR\x04UUID\x12\x12\n" +
	"\x04name\x18\x03 \x01(\tR\x04name\x12\x1e\n" +
	"\n" +
	"identifier\x18\x04 \x01(\tR\n" +
	"identifier\x12\x14\n" +
	"\x05scope\x18\x05 \x01(\tR\x05scope\x12\x12\n" +
	"\x04role\x18\x06 \x01(\tR\x04role\x122\n" +
	"\x14idpConfigurationName\x18\a \x01(\tR\x14idpConfigurationNameJ\x04\b\x01\x10\x02R\x05state\"\xee\x01\n" +
	"\x19CreateAuthMapEntryRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x1e\n" +
	"\n" +
	"identifier\x18\x02 \x01(\tR\n" +
	"identifier\x12\x14\n" +
	"\x05scope\x18\x03 \x01(\tR\x05scope\x12\x12\n" +
	"\x04role\x18\x04 \x01(\tR\x04role\x122\n" +
	"\x14idpConfigurationName\x18\x05 \x01(\tR\x14idpConfigurationName:?\x92A<\n" +
	":\xd2\x01\x04name\xd2\x01\n" +
	"identifier\xd2\x01\x05scope\xd2\x01\x04role\xd2\x01\x14idpConfigurationName\"\xee\x01\n" +
	"\x19UpdateAuthMapEntryRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name\x12\x14\n" +
	"\x05scope\x18\x02 \x01(\tR\x05scope\x12\x12\n" +
	"\x04role\x18\x03 \x01(\tR\x04role\x12\x1e\n" +
	"\n" +
	"identifier\x18\x04 \x01(\tR\n" +
	"identifier\x122\n" +
	"\x14idpConfigurationName\x18\x05 \x01(\tR\x14idpConfigurationName:?\x92A<\n" +
	":\xd2\x01\x04name\xd2\x01\n" +
	"identifier\xd2\x01\x05scope\xd2\x01\x04role\xd2\x01\x14idpConfigurationName\"=\n" +
	"\x19DeleteAuthMapEntryRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\":\n" +
	"\x16GetAuthMapEntryRequest\x12\x12\n" +
	"\x04name\x18\x01 \x01(\tR\x04name:\f\x92A\t\n" +
	"\a\xd2\x01\x04name\"\x1b\n" +
	"\x19ListAuthMapEntriesRequest\"\x1c\n" +
	"\x1aDeleteAuthMapEntryResponse\"j\n" +
	"\x1aListAuthMapEntriesResponse\x12L\n" +
	"\x0eauthMapEntries\x18\x01 \x03(\v2$.lightbits.api.duros.v2.AuthMapEntryR\x0eauthMapEntries\"&\n" +
	"$EnableFederatedAuthenticationRequest\"'\n" +
	"%EnableFederatedAuthenticationResponse\"'\n" +
	"%DisableFederatedAuthenticationRequest\"(\n" +
	"&DisableFederatedAuthenticationResponse\"\x94\x01\n" +
	"(GetFederatedAuthenticationStatusResponse\x12h\n" +
	"\x1cfederatedAuthenticationState\x18\x01 \x01(\x0e2$.lightbits.api.duros.v2.fedAuthStateR\x1cfederatedAuthenticationState*U\n" +
	"\tCredsType\x12\x0f\n" +
	"\vUnknownType\x10\x00\x12\x0f\n" +
	"\vRS256PubKey\x10\x01\x12\x13\n" +
	"\x0fTlsCertChainPem\x10\x02\x12\x11\n" +
	"\rTlsPrivKeyPem\x10\x03*<\n" +
	"\tCredsKind\x12\r\n" +
	"\tUserCreds\x10\x00\x12\x0f\n" +
	"\vBeaconCreds\x10\x02\x12\x0f\n" +
	"\vUnknownKind\x10\x7f*d\n" +
	"\x13ProtectionStateEnum\x12\v\n" +
	"\aUnknown\x10\x00\x12\x12\n" +
	"\x0eFullyProtected\x10\x01\x12\f\n" +
	"\bDegraded\x10\x02\x12\f\n" +
	"\bReadOnly\x10\x03\x12\x10\n" +
	"\fNotAvailable\x10\x04*;\n" +
	"\x10PolicyVisibility\x12\x0f\n" +
	"\vUnavailable\x10\x00\x12\n" +
	"\n" +
	"\x06Scoped\x10\x01\x12\n" +
	"\n" +
	"\x06Global\x10\x02*9\n" +
	"\n" +
	"PolicyType\x12\v\n" +
	"\aunknown\x10\x00\x12\f\n" +
	"\bsnapshot\x10\x01\x12\x10\n" +
	"\fqosRateLimit\x10\x02*j\n" +
	"\x0fIdpHealthStatus\x12\x1b\n" +
	"\x17IdpHealthStatus_Healthy\x10\x00\x12\x1d\n" +
	"\x19IdpHealthStatus_UnHealthy\x10\x01\x12\x1b\n" +
	"\x17IdpHealthStatus_Unknown\x10\x02*#\n" +
	"\aIDPType\x12\x0e\n" +
	"\n" +
	"unknownIdp\x10\x00\x12\b\n" +
	"\x04ADFS\x10\x01*W\n" +
	"\ffedAuthState\x12#\n" +
	"\x1fFederatedAuthenticationDisabled\x10\x00\x12\"\n" +
	"\x1eFederatedAuthenticationEnabled\x10\x012\xfa\xd7\x03\n" +
	"\bDurosAPI\x12\xbc\x01\n" +
	"\n" +
	"GetVersion\x12).lightbits.api.duros.v2.GetVersionRequest\x1a\x1f.lightbits.api.duros.v2.Version\"b\x92AH\n" +
	"\x12Cluster operations\x12\x10Product Version.\x1a Get product version information.\x82\xd3\xe4\x93\x02\x11\x12\x0f/api/v2/version\x12\xdf\x06\n" +
	"\fCreateVolume\x12+.lightbits.api.duros.v2.CreateVolumeRequest\x1a\x1e.lightbits.api.duros.v2.Volume\"\x81\x06\x92A\xb6\x05\n" +
	"\x11Volume operations\x12\x0eCreate volume.\x1a\xb7\x01A volume has a user-defined name, capacity, and a string-based Access Control List (ACL).\n" +
	"User can also select to enable compression and define IP-ACL (IP address-based control list).J\x8c\x02\n" +
	"\x03400\x12\x84\x02\n" +
	"\xf9\x01An invalid argument was provided, due to one of the following reasons: \n" +
	" a mandatory argument is missing, \n" +
	" name contains illegal characters, \n" +
	" size is not a positive integer, \n" +
	" replica count is outside of a valid range, \n" +
	" ACL or IP-ACL are invalid.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03409\x129\n" +
	"/A volume with the provided name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02A:\x01*Z\x14:\x01*\"\x0f/api/v2/volumes\"&/api/v2/projects/{projectName}/volumes\x12\xa4\b\n" +
	"\fDeleteVolume\x12+.lightbits.api.duros.v2.DeleteVolumeRequest\x1a,.lightbits.api.duros.v2.DeleteVolumeResponse\"\xb8\a\x92A\xe5\x06\n" +
	"\x11Volume operations\x12\x0eDelete volume.\x1a\xb7\x02Deletes a volume according to the provided UUID or Name.\n" +
	"Deletion of a volume is a long operation. The status of deletion can be queried by a GET operation on the volume. As long as the operation runs, the volume state is Deleting. Once the operation has completed, GET volume returns a NotFound error response.Jh\n" +
	"\x03400\x12a\n" +
	"WProvided invalid UUID, Name, or volume state does not allow deletion (Deleting/Failed).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03404\x129\n" +
	"/Volume with provided UUID or Name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JD\n" +
	"\x03409\x12=\n" +
	"3There is a user operation in progress on the volume\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03Jk\n" +
	"\x03503\x12d\n" +
	"ZVolume is in a temporary state that does not currently allow deletion (Creating/Updating).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02IZ\x18*\x16/api/v2/volumes/{UUID}*-/api/v2/projects/{projectName}/volumes/{UUID}\x12\xf9\x06\n" +
	"\vListVolumes\x12).lightbits.api.duros.v2.ListVolumeRequest\x1a+.lightbits.api.duros.v2.ListVolumesResponse\"\x91\x06\x92A\xcc\x05\n" +
	"\x11Volume operations\x12\rList volumes.\x1a\xfb\x03List can be filtered by failure domain. List can be partially returned by given offset UUID and size of the list. If offset is not provided, list is returned from the start. If offset UUID is provided, list starts from the next volume after the provided offset UUID. If limit is provided, length of the returned list is bounded by the limit. If limit is not provided, list is returned until the end. projectName is mandatory unless you are the admin. List can also be filtered by a specific source snapshot.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02;Z\x11\x12\x0f/api/v2/volumes\x12&/api/v2/projects/{projectName}/volumes\x12\xfd\x04\n" +
	"\n" +
	"ListEvents\x12).lightbits.api.duros.v2.ListEventsRequest\x1a*.lightbits.api.duros.v2.ListEventsResponse\"\x97\x04\x92A\xd4\x03\n" +
	"\x12Cluster operations\x12&Get all Lightbits events from cluster.\x1a=API to pull the events from the aggregated cluster event log.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03404\x12\x1c\n" +
	"\x12Project not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x85\x01\n" +
	"\x03501\x12~\n" +
	"tUnimplemented capability. Specify only a single parameter to filter events: componentType, ProjectName, or Severity.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x029Z\x10\x12\x0e/api/v2/events\x12%/api/v2/projects/{projectName}/events\x12\xa5\x03\n" +
	"\aGetHost\x12&.lightbits.api.duros.v2.GetHostRequest\x1a%.lightbits.api.duros.v2.ConnectedHost\"\xca\x02\x92A\x9e\x02\n" +
	"\x0fHost operations\x12\x1fGet connected host information.\x1a0Get connected host information given by hostNQN.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J0\n" +
	"\x03404\x12)\n" +
	"\x1fProvided host NQN is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\"\x12 /api/v2/connectedHosts/{hostNQN}\x12\xf1\x03\n" +
	"\tListHosts\x12(.lightbits.api.duros.v2.ListHostsRequest\x1a).lightbits.api.duros.v2.ListHostsResponse\"\x8e\x03\x92A\xec\x02\n" +
	"\x0fHost operations\x12\x1eGet a list of connected hosts.\x1aXList all hosts connected to a cluster, or only connected hosts associated with a volume.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J3\n" +
	"\x03404\x12,\n" +
	"\"Provided volume UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x18\x12\x16/api/v2/connectedHosts\x12\xe1\x03\n" +
	"\tGetVolume\x12(.lightbits.api.duros.v2.GetVolumeRequest\x1a\x1e.lightbits.api.duros.v2.Volume\"\x89\x03\x92A\xb6\x02\n" +
	"\x11Volume operations\x12\x17Get volume information.\x1a'Get volume information by provided UUIDJ\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J3\n" +
	"\x03404\x12,\n" +
	"\"Provided volume UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02IZ\x18\x12\x16/api/v2/volumes/{UUID}\x12-/api/v2/projects/{projectName}/volumes/{UUID}\x12\xe1\x04\n" +
	"\tListNodes\x12'.lightbits.api.duros.v2.ListNodeRequest\x1a).lightbits.api.duros.v2.ListNodesResponse\"\xff\x03\x92A\xe6\x03\n" +
	"\x0fNode operations\x12\x12Get list of nodes.\x1a\xdc\x01List Nodes. An option to filter is done by the following parameters: 1. Name - e.g., api/v2/nodes?Name=<Name> 2. UUID - e.g.,  api/v2/nodes?UUID=<UUID> 3. FailureDomain - e.g.,  api/v2/nodes?FailureDomain=<FailureDomain>JX\n" +
	"\x03400\x12Q\n" +
	"GInvalid argument, or several mutually exclusive arguments are provided.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x0f\x12\r/api/v2/nodes\x12\x8f\x03\n" +
	"\aGetNode\x12&.lightbits.api.duros.v2.GetNodeRequest\x1a%.lightbits.api.duros.v2.DurosNodeInfo\"\xb4\x02\x92A\x94\x02\n" +
	"\x0fNode operations\x12\x15Get node information.\x1a8Get node information identified by the UUID of the node.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J(\n" +
	"\x03404\x12!\n" +
	"\x17Node UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x16\x12\x14/api/v2/nodes/{UUID}\x12\xee\x04\n" +
	"\x0fListNvmeDevices\x12..lightbits.api.duros.v2.ListNvmeDevicesRequest\x1a/.lightbits.api.duros.v2.ListNvmeDevicesResponse\"\xf9\x03\x92A\xda\x03\n" +
	"\x16NVMe device operations\x12DRetrieve a list of NVMe devices, with optional filtering selections.\x1a\xf1\x01A request to list NVMe devices is exposed via this API. The list of NVMe devices can be filtered by the following parameters:  1. ServerUUID - e.g., api/v2/nvmeDevices?ServerUUID=<UUID> 2. NodeUUID - e.g., api/v2/nvmeDevices?NodeUUID=<UUID>.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x15\x12\x13/api/v2/nvmeDevices\x12\x94\x04\n" +
	"\rGetNvmeDevice\x12,.lightbits.api.duros.v2.GetNvmeDeviceRequest\x1a/.lightbits.api.duros.v2.UserNvmeDevicesResponse\"\xa3\x03\x92A\xfb\x02\n" +
	"\x16NVMe device operations\x128Retrieve a specific NVMe device with a filtering option.\x1axRequest NVMe device information according to it's serial number. Example usage: api/v2/nvmeDevices/15eb21c0-35ae-478d-b.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J%\n" +
	"\x03404\x12\x1e\n" +
	"\x14Serial is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1e\x12\x1c/api/v2/nvmeDevices/{Serial}\x12\xe6\x03\n" +
	"\tFetchLogs\x12\".lightbits.api.duros.v2.LogRequest\x1a\x14.google.api.HttpBody\"\x9c\x03\x92A\x84\x03\n" +
	"\x12Cluster operations\x12+Retrieve server logs and other information.\x1a\xb8\x01Retrieve all server logs. This command will trigger a dedicated Lightbits script that will package all server logs and information them into a tarball file then fetch the tarball file.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x0e\x12\f/api/v2/logs0\x01\x12\x8b\x03\n" +
	"\n" +
	"GetCluster\x12).lightbits.api.duros.v2.GetClusterRequest\x1a#.lightbits.api.duros.v2.ClusterInfo\"\xac\x02\x92A\x91\x02\n" +
	"\x12Cluster operations\x12\x1dRetrieve cluster information.\x1aTCluster information - e.g., cluster UUID and SubsystemNQN - is exposed via this API.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x11\x12\x0f/api/v2/cluster\x12\xa1\x03\n" +
	"\x0eGetClusterInfo\x12).lightbits.api.duros.v2.GetClusterRequest\x1a%.lightbits.api.duros.v2.ClusterInfoV2\"\xbc\x02\x92A\x9d\x02\n" +
	"\x12Cluster operations\x12\x1dRetrieve cluster information.\x1a`Cluster information for tenants - e.g., cluster UUID and SubsystemNQN - is exposed via this API.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x15\x12\x13/api/v2/clusterinfo\x12\xe8\x06\n" +
	"\x10UpdateNvmeDevice\x12/.lightbits.api.duros.v2.UpdateNvmeDeviceRequest\x1a0.lightbits.api.duros.v2.UpdateNvmeDeviceResponse\"\xf0\x05\x92A\xbf\x05\n" +
	"\x16NVMe device operations\x12\x1dUpdate NVMe device on a node.\x1aOUpdate NVMe device defined by serial number on a server defined by server UUID.J\x91\x02\n" +
	"\x03400\x12\x89\x02\n" +
	"\xfe\x01Empty serial or empty server UUID is provided, the device is already attached to another node, the number of node's managed devices reached the maximum, node is not listed as server's node for the server that the device belongs to, or node is not active.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J1\n" +
	"\x03404\x12*\n" +
	" Serial or server UUID not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JE\n" +
	"\x03409\x12>\n" +
	"4There is a user operation in progress on the device.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02':\x01*\"\"/api/v2/nvmeDevices/{serialNumber}\x12\xbd\a\n" +
	"\rAddNvmeDevice\x12,.lightbits.api.duros.v2.AddNvmeDeviceRequest\x1a-.lightbits.api.duros.v2.AddNvmeDeviceResponse\"\xce\x06\x92A\xac\x06\n" +
	"\x16NVMe device operations\x12\x1aAdd NVMe device to a node.\x1a\xbb\x01Add NVMe device identified by its serial number to a node identified by its UUID. If the NVMe device is already used by another node, or cannot be attached to the node, the command fails.J\x97\x02\n" +
	"\x03400\x12\x8f\x02\n" +
	"\x84\x02Empty serial or empty node UUID is provided, the device is already attached to another node, the number of node's managed devices reached the maximum, the node is not listed as the server's node for the server that device belongs to, or the node is not active.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J/\n" +
	"\x03404\x12(\n" +
	"\x1eSerial or node UUID not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JD\n" +
	"\x03409\x12=\n" +
	"3There is a user operation in progress on the device\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x18:\x01*\"\x13/api/v2/nvmeDevices\x12\x9d\a\n" +
	"\fUpdateVolume\x12+.lightbits.api.duros.v2.UpdateVolumeRequest\x1a,.lightbits.api.duros.v2.UpdateVolumeResponse\"\xb1\x06\x92A\xd8\x05\n" +
	"\x11Volume operations\x12\x0eUpdate volume.\x1auUpdate volume enables the change of the following attributes:\n" +
	" size\n" +
	" compression\n" +
	" ACL list\n" +
	" IP-ACL list\n" +
	" QoS\n" +
	" labels.Je\n" +
	"\x03400\x12^\n" +
	"TInvalid argument or a volume is in a state that cannot be updated (Deleting/Failed).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JG\n" +
	"\x03404\x12@\n" +
	"6Returned when the volume with given UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JE\n" +
	"\x03409\x12>\n" +
	"4There is a user operation in progress on the volume.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J>\n" +
	"\x03501\x127\n" +
	"-Unimplemented capability (updating capacity).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\\\n" +
	"\x03503\x12U\n" +
	"KVolume is in temporary state and cannot be updated now (Creating/Updating).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02O:\x01*Z\x1b:\x01*\x1a\x16/api/v2/volumes/{UUID}\x1a-/api/v2/projects/{projectName}/volumes/{UUID}\x12\xb8\x03\n" +
	"\tGetServer\x12(.lightbits.api.duros.v2.GetServerRequest\x1a\x1e.lightbits.api.duros.v2.Server\"\xe0\x02\x92A\xbe\x02\n" +
	"\x11Server operations\x124Retrieve specific server information, based on UUID.\x1a/Request server information, identified by UUID.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J:\n" +
	"\x03404\x123\n" +
	")Server with provided UUID does not exist.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x18\x12\x16/api/v2/servers/{UUID}\x12\x8d\x04\n" +
	"\vListServers\x12*.lightbits.api.duros.v2.ListServersRequest\x1a+.lightbits.api.duros.v2.ListServersResponse\"\xa4\x03\x92A\x89\x03\n" +
	"\x11Server operations\x129Retrieve servers list with optional filtering parameters.\x1a\xb0\x01Retrieve servers list. The results can be filtered by supplying the following filters: 1. Name - e.g., /api/v2/servers?Name=<Name> 2. UUID - e.g.,  /api/v2/servers?UUID=<UUID>.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x11\x12\x0f/api/v2/servers\x12\xa4\x05\n" +
	"\rUpgradeServer\x12,.lightbits.api.duros.v2.UpgradeServerRequest\x1a-.lightbits.api.duros.v2.UpgradeServerResponse\"\xb5\x04\x92A\x88\x04\n" +
	"\x12Upgrade operations\x12\x0fUpgrade server.\x1a\xa8\x01Upgrades server given by UUID with a package pointed by URI. Since upgrading a server is a long operation, the status of the upgrade shall be fetched from server objectJ%\n" +
	"\x03400\x12\x1e\n" +
	"\x14Invalid UUID or URI.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03404\x12\x18\n" +
	"\x0eUUID not found\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JE\n" +
	"\x03409\x12>\n" +
	"4There is a user operation in progress on the server.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02#:\x01*\"\x1e/api/v2/servers/{UUID}/upgrade\x12\xf5\x04\n" +
	"\x0eUpgradeCluster\x12-.lightbits.api.duros.v2.UpgradeClusterRequest\x1a..lightbits.api.duros.v2.UpgradeClusterResponse\"\x83\x04\x92A\xdd\x03\n" +
	"\x12Upgrade operations\x12\x10Upgrade cluster.\x1a\xcb\x01Upgrades servers in the cluster one by one. Only servers that do not cause loss of service are upgraded. The progress and status of the upgrade operation can be monitored by be polling the server object.J%\n" +
	"\x03400\x12\x1e\n" +
	"\x14Invalid UUID or URI.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J8\n" +
	"\x03404\x121\n" +
	"'One of the provided UUIDs is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1c:\x01*\"\x17/api/v2/cluster/upgrade\x12\xd3\x06\n" +
	"\x17EnableClusterEncryption\x126.lightbits.api.duros.v2.EnableClusterEncryptionRequest\x1a7.lightbits.api.duros.v2.EnableClusterEncryptionResponse\"\xc6\x05\x92A\x96\x05\n" +
	"\x15Encryption operations\x12 Enable Cluster level encryption.\x1a\xa1\x02Enables cluster-level encryption. Once enabled, each volume will be encrypted with a Data Encryption Key (DEK), which is in turn encrypted by a Key Encryption Key (KEK). In the body, users can select the KeyStore type: tpm or file. Note: cluster encryption cannot be disabled once enabled.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J;\n" +
	"\x03409\x124\n" +
	"*Encryption is already enabled or enabling.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J%\n" +
	"\x03412\x12\x1e\n" +
	"\x14Precondition failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J'\n" +
	"\x03500\x12 \n" +
	"\x16System internal error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03501\x12#\n" +
	"\x19Unimplemented capability.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02&:\x01*\"!/api/v2/cluster/encryption/enable\x12\x87\x05\n" +
	"\fCreateServer\x12+.lightbits.api.duros.v2.CreateServerRequest\x1a\x1e.lightbits.api.duros.v2.Server\"\xa9\x04\x92A\x8b\x04\n" +
	"\x11Server operations\x12\x0eCreate Server.\x1a\xd3\x01A request to create a new server. The required parameters for operation are:  1. serverEndpoints - URL list of the new server IP addresses as well as etcd ports for peer communication e.g.: http://10.0.0.1:2380.J-\n" +
	"\x03400\x12&\n" +
	"\x1cMultiple endpoints provided.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JY\n" +
	"\x03409\x12R\n" +
	"HServer with UUID or endpoint already exists (reuseIP flag was not used).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x14:\x01*\"\x0f/api/v2/servers\x12\xf6\b\n" +
	"\vReplaceNode\x12*.lightbits.api.duros.v2.ReplaceNodeRequest\x1a+.lightbits.api.duros.v2.ReplaceNodeResponse\"\x8d\b\x92A\xdb\a\n" +
	"\x0fNode operations\x12\rReplace Node.\x1a\xf3\x03The request is identified by the UUID of the replaced node (referred to as SrcNodeUUID).\n" +
	"The required parameters in the body are:\n" +
	"1. TargetNodeUUID - the UUID of the target node that replaces the src Node. The command will succeed only if srcNode is Inactive, and targetNode is Unattached. Users should disable the server of the srcNode (that will make the node Inactive), and assure that targetNode is Unattached (possibly as a new node without assigned PGs or by replacing its PG to another node).Jb\n" +
	"\x03400\x12[\n" +
	"QInvalid argument provided. Source and target nodes are not in the correct states.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J8\n" +
	"\x03404\x121\n" +
	"'One of the provided UUIDs is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JK\n" +
	"\x03409\x12D\n" +
	":There is a user operation in progress on one of the nodes.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J/\n" +
	"\x03429\x12(\n" +
	"\x1eToo many commands in progress.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02(:\x01*\"#/api/v2/nodes/{SrcNodeUUID}/replace\x12\xc9\x05\n" +
	"\fDeleteServer\x12+.lightbits.api.duros.v2.DeleteServerRequest\x1a,.lightbits.api.duros.v2.DeleteServerResponse\"\xdd\x04\x92A\xbb\x04\n" +
	"\x11Server operations\x12\x0eDelete Server.\x1a\xbd\x01A request to delete a server. This operation will delete a server (information) from the Lightbits cluster. The required parameters in the body are:  1. UUID - UUID of the server to delete.J5\n" +
	"\x03400\x12.\n" +
	"$Missing or Invalid UUID is provided.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J/\n" +
	"\x03404\x12(\n" +
	"\x1eServer with UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JE\n" +
	"\x03409\x12>\n" +
	"4There is a user operation in progress on the server.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x18*\x16/api/v2/servers/{UUID}\x12\xd8\x04\n" +
	"\fEnableServer\x12+.lightbits.api.duros.v2.EnableServerRequest\x1a\x1e.lightbits.api.duros.v2.Server\"\xfa\x03\x92A\xce\x03\n" +
	"\x11Server operations\x12\x0eEnable Server.\x1a\x87\x01Enable a disabled server. Enabling a server causes the server nodes to synchronize with their peers and rebuild the replicas they hold.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J/\n" +
	"\x03404\x12(\n" +
	"\x1eServer with UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JE\n" +
	"\x03409\x12>\n" +
	"4There is a user operation in progress on the server.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\":\x01*\"\x1d/api/v2/servers/{UUID}/enable\x12\x87\a\n" +
	"\rDisableServer\x12,.lightbits.api.duros.v2.DisableServerRequest\x1a-.lightbits.api.duros.v2.DisableServerResponse\"\x98\x06\x92A\xeb\x05\n" +
	"\x11Server operations\x12\x0fDisable server.\x1a\xca\x02Server is disabled from the cluster. Server nodes become Inactive and do not participate in data protection. If the 'evict' parameter is True, all data on the server is evicted from the server before it is disabled. Once a server is disabled, it can be enabled and added back to the cluster or removed from the cluster completely.Jx\n" +
	"\x03400\x12q\n" +
	"gBad request: Missing/Invalid UUID is provided or disable server can lead to risk of service loss state.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J/\n" +
	"\x03404\x12(\n" +
	"\x1eServer with UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JE\n" +
	"\x03409\x12>\n" +
	"4There is a user operation in progress on the server.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02#:\x01*\"\x1e/api/v2/servers/{UUID}/disable\x12\xb0\x05\n" +
	"\x11StartNodeInstance\x120.lightbits.api.duros.v2.StartNodeInstanceRequest\x1a1.lightbits.api.duros.v2.StartNodeInstanceResponse\"\xb5\x04\x92A\x88\x04\n" +
	"\x0fNode operations\x12\x1dStart a stopped node instance\x1a\xd5\x03This operation starts a specific node instance.\n" +
	"Starting all of the node's Lightbits services, including duroslight and the backend instance.\n" +
	"This is useful for dual-node servers where you want to start a single node instance without affecting the other node.\n" +
	"Only system administrators can execute this command.\n" +
	"Note that node maintenance operations (stop/start/restart) are a tech preview, for evaluative purposes only. They should not be used in production clusters.\x82\xd3\xe4\x93\x02#:\x01*\"\x1e/api/v2/nodes/{nodeUUID}/start\x12\xe9\x06\n" +
	"\x10StopNodeInstance\x12/.lightbits.api.duros.v2.StopNodeInstanceRequest\x1a0.lightbits.api.duros.v2.StopNodeInstanceResponse\"\xf1\x05\x92A\xc5\x05\n" +
	"\x0fNode operations\x12\x1cStop a running node instance\x1a\x93\x05This operation stops a specific node instance.\n" +
	"Stopping all of the node's Lightbits services, including duroslight and the backend instance.\n" +
	"This is useful for dual-node servers where you want to stop a single node instance without affecting the other node.\n" +
	"This operation is blocked if it could cause data unavailability. Use --force to override this check.\n" +
	"Please note that this is a potentially disruptive operation that should be used with care. Only system administrators can execute this command.\n" +
	"Note that node maintenance operations (stop/start/restart) are a tech preview, for evaluative purposes only. They should not be used in production clusters.\x82\xd3\xe4\x93\x02\":\x01*\"\x1d/api/v2/nodes/{nodeUUID}/stop\x12\xbe\a\n" +
	"\x13RestartNodeInstance\x122.lightbits.api.duros.v2.RestartNodeInstanceRequest\x1a3.lightbits.api.duros.v2.RestartNodeInstanceResponse\"\xbd\x06\x92A\x8e\x06\n" +
	"\x0fNode operations\x12\x1fRestart a running node instance\x1a\xd9\x05This operation restarts the node instance for a specific node by restarting only its own services.\n" +
	"This includes duroslight and the gftl backend instances (unless --consider-backend=false is specified).\n" +
	"This is useful for dual-node servers where you want to restart a single node instance without affecting the other node.\n" +
	"This operation will be blocked if it could cause data unavailability. Use --force to override this check.\n" +
	"Please note that this is a potentially disruptive operation that should be used with care. Only system administrators can execute this command.\n" +
	"Note that node maintenance operations (stop/start/restart) are a tech preview, for evaluative purposes only. They should not be used in production clusters.\x82\xd3\xe4\x93\x02%:\x01*\" /api/v2/nodes/{nodeUUID}/restart\x12\xce\x04\n" +
	"\rCreateProject\x12,.lightbits.api.duros.v2.CreateProjectRequest\x1a\x1f.lightbits.api.duros.v2.Project\"\xed\x03\x92A\xce\x03\n" +
	"\x12Project operations\x12\x0fCreate project.\x1aIA project has a name, a description, and a default QOS rate limit policy.J\x91\x01\n" +
	"\x03400\x12\x89\x01\n" +
	"\x7fProvided invalid argument with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	"name contains illegal characters.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03409\x129\n" +
	"/Resource with the provided name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x15:\x01*\"\x10/api/v2/projects\x12\xb4\x03\n" +
	"\rUpdateProject\x12,.lightbits.api.duros.v2.UpdateProjectRequest\x1a-.lightbits.api.duros.v2.UpdateProjectResponse\"\xc5\x02\x92A\x98\x02\n" +
	"\x12Project operations\x12\x1eUpdate Project Default Policy.\x1a)Update project's default resource policy.J/\n" +
	"\x03400\x12(\n" +
	"\x1eMandatory argument is missing.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02#:\x01*\x1a\x1e/api/v2/projects/{projectName}\x12\x95\x04\n" +
	"\rDeleteProject\x12,.lightbits.api.duros.v2.DeleteProjectRequest\x1a-.lightbits.api.duros.v2.DeleteProjectResponse\"\xa6\x03\x92A\x83\x03\n" +
	"\x12Project operations\x12\x0fDelete project.\x1a#Deletes project with provided name.JS\n" +
	"\x03400\x12L\n" +
	"BProvided invalid name or the project is not allowed to be deleted.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J9\n" +
	"\x03404\x122\n" +
	"(Project with provided name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x19*\x17/api/v2/projects/{name}\x12\xec\x02\n" +
	"\fListProjects\x12+.lightbits.api.duros.v2.ListProjectsRequest\x1a,.lightbits.api.duros.v2.ListProjectsResponse\"\x80\x02\x92A\xe4\x01\n" +
	"\x12Project operations\x12\x0eList projects.\x1a\x12list all projects.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x12\x12\x10/api/v2/projects\x12\x97\x03\n" +
	"\n" +
	"GetProject\x12).lightbits.api.duros.v2.GetProjectRequest\x1a\x1f.lightbits.api.duros.v2.Project\"\xbc\x02\x92A\x99\x02\n" +
	"\x12Project operations\x12\fGet project.\x1a\x13Get project by nameJ\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J4\n" +
	"\x03404\x12-\n" +
	"#Provided project name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x19\x12\x17/api/v2/projects/{name}\x12\xc3\x05\n" +
	"\x10CreateCredential\x12/.lightbits.api.duros.v2.CreateCredentialRequest\x1a\".lightbits.api.duros.v2.Credential\"\xd9\x04\x92A\xa0\x04\n" +
	"\x19Access control operations\x12\x12Create credential.\x1a(A credential has a name and description.J\xfa\x01\n" +
	"\x03400\x12\xf2\x01\n" +
	"\xe7\x01Provided invalid argument with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	"name contains illegal characters, \n" +
	"size is not a positive integer, \n" +
	"replica count is outside of a valid range, \n" +
	"ACL or IP-ACL is invalid.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03409\x129\n" +
	"/Resource with the provided name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02/:\x01*\"*/api/v2/projects/{projectName}/credentials\x12\xc5\x04\n" +
	"\x10DeleteCredential\x12/.lightbits.api.duros.v2.DeleteCredentialRequest\x1a0.lightbits.api.duros.v2.DeleteCredentialResponse\"\xcd\x03\x92A\x92\x03\n" +
	"\x19Access control operations\x12\x12Delete credential.\x1a$Deletes credential with provided ID.JV\n" +
	"\x03400\x12O\n" +
	"EProvided invalid name or the credential is not allowed to be deleted.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J:\n" +
	"\x03404\x123\n" +
	")Credential with provided ID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x021*//api/v2/projects/{projectName}/credentials/{ID}\x12\x98\x03\n" +
	"\x0fListCredentials\x12..lightbits.api.duros.v2.ListCredentialsRequest\x1a/.lightbits.api.duros.v2.ListCredentialsResponse\"\xa3\x02\x92A\xed\x01\n" +
	"\x19Access control operations\x12\x11List credentials.\x1a\x11List credentials.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02,\x12*/api/v2/projects/{projectName}/credentials\x12\xc5\x03\n" +
	"\rGetCredential\x12,.lightbits.api.duros.v2.GetCredentialRequest\x1a\".lightbits.api.duros.v2.Credential\"\xe1\x02\x92A\xa6\x02\n" +
	"\x19Access control operations\x12\x0fGet credential.\x1a\x15Get credential by ID.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03404\x12.\n" +
	"$Provided credential ID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x021\x12//api/v2/projects/{projectName}/credentials/{ID}\x12\xac\x03\n" +
	"\aGetRole\x12&.lightbits.api.duros.v2.GetRoleRequest\x1a'.lightbits.api.duros.v2.GetRoleResponse\"\xcf\x02\x92A\x98\x02\n" +
	"\x19Access control operations\x12\tGet role.\x1a\x11Get role by name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J1\n" +
	"\x03404\x12*\n" +
	" Provided role name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02-\x12+/api/v2/projects/{projectName}/roles/{name}\x12\x8c\x03\n" +
	"\tListRoles\x12(.lightbits.api.duros.v2.ListRolesRequest\x1a).lightbits.api.duros.v2.ListRolesResponse\"\xa9\x02\x92A\xf9\x01\n" +
	"\x19Access control operations\x12$List all roles defined in a project.\x1a\n" +
	"List rolesJ\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02&\x12$/api/v2/projects/{projectName}/roles\x12\xd6\x03\n" +
	"\x13CreateAdminEndpoint\x122.lightbits.api.duros.v2.CreateAdminEndpointRequest\x1a%.lightbits.api.duros.v2.AdminEndpoint\"\xe3\x02\x92A\xbe\x02\n" +
	"\x19Admin endpoint operations\x12\x16Create admin endpoint.\x1a7Allow access to a specified port for all specified IPs.J!\n" +
	"\x03400\x12\x1a\n" +
	"\x10Port is invalid.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J%\n" +
	"\x03409\x12\x1e\n" +
	"\x14Port already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1b:\x01*\"\x16/api/v2/adminEndpoints\x12\xbf\x05\n" +
	"\x13DeleteAdminEndpoint\x122.lightbits.api.duros.v2.DeleteAdminEndpointRequest\x1a3.lightbits.api.duros.v2.DeleteAdminEndpointResponse\"\xbe\x04\x92A\x95\x04\n" +
	"\x19Admin endpoint operations\x12\x16Delete admin endpoint.\x1a2Delete endpoint corresponding to a specified port.J!\n" +
	"\x03400\x12\x1a\n" +
	"\x10Port is invalid.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J=\n" +
	"\x03404\x126\n" +
	",Port does not have a corresponding endpoint.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JC\n" +
	"\x03409\x12<\n" +
	"2There is a user operation in progress on the port.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\\\n" +
	"\x03503\x12U\n" +
	"KTemporary state that does not currently allow deletion (Creating/Updating).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1f*\x1d/api/v2/adminEndpoints/{port}\x12\x9d\x03\n" +
	"\x12ListAdminEndpoints\x121.lightbits.api.duros.v2.ListAdminEndpointsRequest\x1a2.lightbits.api.duros.v2.ListAdminEndpointsResponse\"\x9f\x02\x92A\xfd\x01\n" +
	"\x19Admin endpoint operations\x12\x15List admin endpoints.\x1a\x1dList can be filtered by port.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x18\x12\x16/api/v2/adminEndpoints\x12\xa8\x05\n" +
	"\x13UpdateAdminEndpoint\x122.lightbits.api.duros.v2.UpdateAdminEndpointRequest\x1a%.lightbits.api.duros.v2.AdminEndpoint\"\xb5\x04\x92A\x89\x04\n" +
	"\x19Admin endpoint operations\x12\x16Update admin endpoint.\x1a6Update list of ips that may access the specified port.J!\n" +
	"\x03400\x12\x1a\n" +
	"\x10Port is invalid.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J=\n" +
	"\x03404\x126\n" +
	",Port does not have a corresponding endpoint.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JC\n" +
	"\x03409\x12<\n" +
	"2There is a user operation in progress on the port.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JL\n" +
	"\x03503\x12E\n" +
	";Temporary state; cannot be updated now (Creating/Updating).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\":\x01*\x1a\x1d/api/v2/adminEndpoints/{port}\x12\xe4\x03\n" +
	"\x10GetAdminEndpoint\x12/.lightbits.api.duros.v2.GetAdminEndpointRequest\x1a%.lightbits.api.duros.v2.AdminEndpoint\"\xf7\x02\x92A\xce\x02\n" +
	"\x19Admin endpoint operations\x12\x13Get admin endpoint.\x1a2Get an endpoint corresponding to a specified port.J!\n" +
	"\x03400\x12\x1a\n" +
	"\x10Port is invalid.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J=\n" +
	"\x03404\x126\n" +
	",Port does not have a corresponding endpoint.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1f\x12\x1d/api/v2/adminEndpoints/{port}\x12\xd5\x04\n" +
	"\x14CreateResourcePolicy\x123.lightbits.api.duros.v2.CreateResourcePolicyRequest\x1a&.lightbits.api.duros.v2.ResourcePolicy\"\xdf\x03\x92A\xa1\x03\n" +
	"\x11Policy operations\x12\x19Create a resource policy.\x1a\x12A resource policy.J\x91\x01\n" +
	"\x03400\x12\x89\x01\n" +
	"\x7fProvided invalid argument with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	"name contains illegal characters.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J[\n" +
	"\x03404\x12T\n" +
	"JReturned when the resource policy with a given resource UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03409\x129\n" +
	"/Resource with the provided name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x024:\x01*\"//api/v2/projects/{projectName}/resourcePolicies\x12\xe3\x04\n" +
	"\fCreatePolicy\x12+.lightbits.api.duros.v2.CreatePolicyRequest\x1a\x1e.lightbits.api.duros.v2.Policy\"\x85\x04\x92A\xe6\x03\n" +
	"\x11Policy operations\x12\x10Create a policy.\x1adA policy is a set of user-defined rules that should be applied to one or more objects in the system.J\xb1\x01\n" +
	"\x03400\x12\xa9\x01\n" +
	"\x9e\x01Provided invalid argument with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	" invalid argument is provided \n" +
	"name contains illegal characters.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J9\n" +
	"\x03404\x122\n" +
	"(One of the given projects was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J>\n" +
	"\x03409\x127\n" +
	"-Policy with the provided name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x15:\x01*\"\x10/api/v2/policies\x12\xd6\x04\n" +
	"\fUpdatePolicy\x12+.lightbits.api.duros.v2.UpdatePolicyRequest\x1a,.lightbits.api.duros.v2.UpdatePolicyResponse\"\xea\x03\x92A\xc4\x03\n" +
	"\x11Policy operations\x12\x10Update a policy.\x1a_Updates user pre-defined policy by overriding the existing properties with the given arguments.J\xbd\x01\n" +
	"\x03400\x12\xb5\x01\n" +
	"\xaa\x01Provided invalid argument(s) with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	"mutually exclusive arguments were provided \n" +
	"invalid argument is provided.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JP\n" +
	"\x03404\x12I\n" +
	"?The given policy was not found or the request is not supported.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1c:\x01*\x1a\x17/api/v2/policies/{UUID}\x12\x8f\x05\n" +
	"\x14UpdateResourcePolicy\x123.lightbits.api.duros.v2.UpdateResourcePolicyRequest\x1a4.lightbits.api.duros.v2.UpdateResourcePolicyResponse\"\x8b\x04\x92A\xc6\x03\n" +
	"\x11Policy operations\x12\x19Update a resource policy.\x1apUpdate resource policy enable the change of the following attributes:\n" +
	"retentionTime \n" +
	"schedulePolicy \n" +
	"descriptionJ\xab\x01\n" +
	"\x03400\x12\xa3\x01\n" +
	"\x98\x01Provided invalid argument with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	"name contains illegal characters, \n" +
	"invalid argument value.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JJ\n" +
	"\x03404\x12C\n" +
	"9Returned when the resource policy UUID/name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02;:\x01*\x1a6/api/v2/projects/{projectName}/resourcePolicies/{UUID}\x12\xdf\x02\n" +
	"\tGetPolicy\x12(.lightbits.api.duros.v2.GetPolicyRequest\x1a\x1e.lightbits.api.duros.v2.Policy\"\x87\x02\x92A\xe4\x01\n" +
	"\x11Policy operations\x12\vGet policy.\x1a/A request to get policy by either name or UUID.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JA\n" +
	"\x03404\x12:\n" +
	"0Returned when the policy UUID/name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x19\x12\x17/api/v2/policies/{UUID}\x12\x8e\x03\n" +
	"\fListPolicies\x12+.lightbits.api.duros.v2.ListPoliciesRequest\x1a,.lightbits.api.duros.v2.ListPoliciesResponse\"\xa2\x02\x92A\x86\x02\n" +
	"\x11Policy operations\x12\x0eList policies.\x1aNA request to list policies. The result can be filtered by either name or UUID.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JA\n" +
	"\x03404\x12:\n" +
	"0Returned when the policy UUID/name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x12\x12\x10/api/v2/policies\x12\xe0\x03\n" +
	"\x14ListResourcePolicies\x123.lightbits.api.duros.v2.ListResourcePoliciesRequest\x1a4.lightbits.api.duros.v2.ListResourcePoliciesResponse\"\xdc\x02\x92A\xa1\x02\n" +
	"\x11Policy operations\x12\x17List resource policies.\x1aWA request to list resource policies. The result can be filtered by either name or UUID.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JJ\n" +
	"\x03404\x12C\n" +
	"9Returned when the resource policy UUID/name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x021\x12//api/v2/projects/{projectName}/resourcePolicies\x12\xae\x03\n" +
	"\x11GetResourcePolicy\x120.lightbits.api.duros.v2.GetResourcePolicyRequest\x1a&.lightbits.api.duros.v2.ResourcePolicy\"\xbe\x02\x92A\xfc\x01\n" +
	"\x11Policy operations\x12\x14Get resource policy.\x1a5Get resource policy information by provided UUID/nameJ\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JJ\n" +
	"\x03404\x12C\n" +
	"9Returned when the resource policy UUID/name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x028\x126/api/v2/projects/{projectName}/resourcePolicies/{UUID}\x12\xc9\x03\n" +
	"\x14DeleteResourcePolicy\x123.lightbits.api.duros.v2.DeleteResourcePolicyRequest\x1a4.lightbits.api.duros.v2.DeleteResourcePolicyResponse\"\xc5\x02\x92A\x83\x02\n" +
	"\x11Policy operations\x12\x17Delete resource policy.\x1a9Delete resource policy information by provided UUID/name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JJ\n" +
	"\x03404\x12C\n" +
	"9Returned when the resource policy UUID/name is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x028*6/api/v2/projects/{projectName}/resourcePolicies/{UUID}\x12\xf2\x02\n" +
	"\fDeletePolicy\x12+.lightbits.api.duros.v2.DeletePolicyRequest\x1a,.lightbits.api.duros.v2.DeletePolicyResponse\"\x86\x02\x92A\xe3\x01\n" +
	"\x11Policy operations\x12\x0eDelete policy.\x1a2Delete policy information by provided policy UUID.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J:\n" +
	"\x03404\x123\n" +
	")The given policy to delete was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x19*\x17/api/v2/policies/{UUID}\x12\xdf\x05\n" +
	"\x0eCreateSnapshot\x12-.lightbits.api.duros.v2.CreateSnapshotRequest\x1a .lightbits.api.duros.v2.Snapshot\"\xfb\x04\x92A\xc4\x04\n" +
	"\x13Snapshot operations\x12\x10Create snapshot.\x1a Create a snapshot from a volume.J\x91\x01\n" +
	"\x03400\x12\x89\x01\n" +
	"\x7fProvided invalid argument with one of the following reasons: \n" +
	"mandatory argument is missing, \n" +
	"name contains illegal characters.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J[\n" +
	"\x03404\x12T\n" +
	"JReturned when the snapshot with the given source-volume UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03409\x129\n" +
	"/Resource with the provided name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J>\n" +
	"\x03501\x127\n" +
	"-Unimplemented capability (updating capacity).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02-:\x01*\"(/api/v2/projects/{projectName}/snapshots\x12\xba\x03\n" +
	"\vGetSnapshot\x12*.lightbits.api.duros.v2.GetSnapshotRequest\x1a .lightbits.api.duros.v2.Snapshot\"\xdc\x02\x92A\xa1\x02\n" +
	"\x13Snapshot operations\x12\rGet snapshot.\x1a\x1aGet snapshot by UUID/Name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J3\n" +
	"\x03404\x12,\n" +
	"\"Snapshot with UUID/Name not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x021\x12//api/v2/projects/{projectName}/snapshots/{UUID}\x12\x99\x03\n" +
	"\rListSnapshots\x12,.lightbits.api.duros.v2.ListSnapshotsRequest\x1a-.lightbits.api.duros.v2.ListSnapshotsResponse\"\xaa\x02\x92A\xf6\x01\n" +
	"\x13Snapshot operations\x12\x0fList snapshots.\x1a\"List can be filtered by UUID/Name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02*\x12(/api/v2/projects/{projectName}/snapshots\x12\xc4\a\n" +
	"\x0eDeleteSnapshot\x12-.lightbits.api.duros.v2.DeleteSnapshotRequest\x1a..lightbits.api.duros.v2.DeleteSnapshotResponse\"\xd2\x06\x92A\x97\x06\n" +
	"\x13Snapshot operations\x12\x10Delete snapshot.\x1a\xb1\x02Deletes snapshot with provided UUID.\n" +
	"Deletion of a snapshot is a long operation. The status of deletion can be queried with a GET operation on the snapshot. As long as the operation runs, the snapshot state is Deleting. When the operation has completed, GET snapshot will return a NotFound error response.Je\n" +
	"\x03400\x12^\n" +
	"TProvided invalid UUID or a snapshot state does not allow deletion (Deleting/Failed).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J:\n" +
	"\x03404\x123\n" +
	")Snapshot with provided UUID is not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JF\n" +
	"\x03409\x12?\n" +
	"5There is a user operation in progress on the snapshot\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x1f\n" +
	"\x03412\x12\x18\n" +
	"\x0eEtag mismatch.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J\x81\x01\n" +
	"\x03503\x12z\n" +
	"pSnapshot is in a temporary state that does not currently allow deletion (Creating/Updating and volume Updating).\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x021*//api/v2/projects/{projectName}/snapshots/{UUID}\x12\xdb\x03\n" +
	"\x0eGetFeatureFlag\x12-.lightbits.api.duros.v2.GetFeatureFlagRequest\x1a).lightbits.api.duros.v2.FeatureFlagStatus\"\xee\x02\x92A\xc7\x02\n" +
	")Cluster configuration/features operations\x12\x18Get feature flag status.\x1aTGet feature flag status enable/disable corresponding to the given feature flag name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1d\x12\x1b/api/v2/featureFlags/{name}\x12\xe0\x03\n" +
	"\x11EnableFeatureFlag\x120.lightbits.api.duros.v2.EnableFeatureFlagRequest\x1a..lightbits.api.duros.v2.SetFeatureFlagResponse\"\xe8\x02\x92A\xb7\x02\n" +
	")Cluster configuration/features operations\x12\x14Enable feature flag.\x1aHEnable feature flag status corresponding to the given feature flag name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02':\x01*\"\"/api/v2/featureFlags/{name}/enable\x12\x91\x04\n" +
	"\x12DisableFeatureFlag\x121.lightbits.api.duros.v2.DisableFeatureFlagRequest\x1a..lightbits.api.duros.v2.SetFeatureFlagResponse\"\x97\x03\x92A\xe5\x02\n" +
	")Cluster configuration/features operations\x12\x15Disable feature flag.\x1aIDisable feature flag status corresponding to the given feature flag name.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03501\x12#\n" +
	"\x19Unimplemented capability.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02(:\x01*\"#/api/v2/featureFlags/{name}/disable\x12\x99\x03\n" +
	"\x10ListFeatureFlags\x12/.lightbits.api.duros.v2.ListFeatureFlagsRequest\x1a0.lightbits.api.duros.v2.ListFeatureFlagsResponse\"\xa1\x02\x92A\x81\x02\n" +
	")Cluster configuration/features operations\x12\x13List feature flags.\x1a\x13List feature flags.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x16\x12\x14/api/v2/featureFlags\x12\xd2\x03\n" +
	"\x15GetClusterConfigParam\x124.lightbits.api.duros.v2.GetClusterConfigParamRequest\x1a*.lightbits.api.duros.v2.ClusterConfigParam\"\xd6\x02\x92A\xae\x02\n" +
	")Cluster configuration/features operations\x127Get a specific cluster configuration parameter's value.\x1a7Get a specific cluster configuration parameter's value.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J?\n" +
	"\x03404\x128\n" +
	".Cluster configuration parameter was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1e\x12\x1c/api/v2/clusterConfig/{name}\x12\xbf\x03\n" +
	"\x18UpdateClusterConfigParam\x127.lightbits.api.duros.v2.UpdateClusterConfigParamRequest\x1a8.lightbits.api.duros.v2.UpdateClusterConfigParamResponse\"\xaf\x02\x92A\xf8\x01\n" +
	")Cluster configuration/features operations\x12\x1cUpdate Cluster Config value.\x1a\x1cUpdate Cluster Config value.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J?\n" +
	"\x03404\x128\n" +
	".Cluster configuration parameter was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02-:\x01*\x1a(/api/v2/clusterConfig/{configParam.name}\x12\x8f\x03\n" +
	"\x17ListClusterConfigParams\x126.lightbits.api.duros.v2.ListClusterConfigParamsRequest\x1a7.lightbits.api.duros.v2.ListClusterConfigParamsResponse\"\x82\x02\x92A\xe1\x01\n" +
	")Cluster configuration/features operations\x121List all cluster configuration parameters values.\x1a1List all cluster configuration parameters values.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x17\x12\x15/api/v2/clusterConfig\x12\xc2\x04\n" +
	"\x0eRollbackVolume\x12-.lightbits.api.duros.v2.RollbackVolumeRequest\x1a..lightbits.api.duros.v2.RollbackVolumeResponse\"\xd0\x03\x92A\x8b\x03\n" +
	"\x11Volume operations\x12*Roll back a volume to a previous snapshot.\x1a*Roll back a volume to a previous snapshot.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J3\n" +
	"\x03404\x12,\n" +
	"\"Volume or snapshot UUID not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J=\n" +
	"\x03503\x126\n" +
	",Cannot roll volume back. Volume is deleting.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02;:\x01*\x1a6/api/v2/projects/{projectName}/volumes/{UUID}/rollback\x12\xc2\x05\n" +
	"\x11ListChangedBlocks\x120.lightbits.api.duros.v2.ListChangedBlocksRequest\x1a1.lightbits.api.duros.v2.ListChangedBlocksResponse\"\xc7\x04\x92A\xff\x03\n" +
	"\x13Snapshot operations\x12/List changed LBAs between a volume's snapshots.\x1aTList changed LBAs between a volume's snapshots (optionally list all snapshots LBAs).J\x82\x01\n" +
	"\x03400\x12{\n" +
	"qInvalid arguments. Snapshot UUIDs are identical or they are no on same chain or offset-lba exceeds snapshot size.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JT\n" +
	"\x03404\x12M\n" +
	"CFailed to find snapshot UUID or base snapshot UUID or project name.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03500\x12#\n" +
	"\x19Internal Lightbits error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02>\x12</api/v2/projects/{projectName}/snapshots/diff/{snapshotUUID}\x12\x98\x06\n" +
	"\x14RotateClusterRootKey\x123.lightbits.api.duros.v2.RotateClusterRootKeyRequest\x1a4.lightbits.api.duros.v2.RotateClusterRootKeyResponse\"\x94\x05\x92A\xe3\x04\n" +
	"\x15Encryption operations\x12.Rotate the cluster root encryption key (Mock).\x1a\xad\x01Rotate the Cluster Level Encryption Key (KEK). After the rotation, all of the DEKs will be encrypted with the new KEK and the new KEK will be stored securely in the cluster.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J1\n" +
	"\x03404\x12*\n" +
	" Rotation is already in progress.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J_\n" +
	"\x03409\x12X\n" +
	"NLast rotation occurred less than the defined interval period between rotations\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J%\n" +
	"\x03412\x12\x1e\n" +
	"\x14Precondition failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J'\n" +
	"\x03500\x12 \n" +
	"\x16System internal error.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03501\x12#\n" +
	"\x19Unimplemented capability.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02'\"%/api/v2/cluster/clusterRootKey/rotate\x12\xc6\x03\n" +
	"\x11GetClusterRootKey\x120.lightbits.api.duros.v2.GetClusterRootKeyRequest\x1a1.lightbits.api.duros.v2.GetClusterRootKeyResponse\"\xcb\x02\x92A\xa1\x02\n" +
	"\x15Encryption operations\x12 Get cluster root encryption key.\x1a\x82\x01Securely export the Cluster-Level Encryption Key (KEK). As a security measure, the exported key in the response will be encrypted.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03501\x12#\n" +
	"\x19Unimplemented capability.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02 \x12\x1e/api/v2/cluster/clusterRootkey\x12\xa5\x04\n" +
	"\x16CreateIdpConfiguration\x125.lightbits.api.duros.v2.CreateIDPConfigurationRequest\x1a(.lightbits.api.duros.v2.IDPConfiguration\"\xa9\x03\x92A\xfa\x02\n" +
	"#Federated authentication operations\x12\x1cCreate an IdP configuration.\x1a\xb4\x01Create a configuration for a remote Identity Provider (IdP) that could be used to authorize access to the Lightbits cluster. Currently only a single IdP configuration is supported.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02%:\x01*\" /api/v2/cluster/IdpConfiguration\x12\xe9\x03\n" +
	"\x16DeleteIdpConfiguration\x125.lightbits.api.duros.v2.DeleteIDPConfigurationRequest\x1a6.lightbits.api.duros.v2.DeleteIDPConfigurationResponse\"\xdf\x02\x92A\xac\x02\n" +
	"#Federated authentication operations\x12\x1cDelete an IdP configuration.\x1a\x1cDelete an IdP configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JI\n" +
	"\x03404\x12B\n" +
	"8IdP configuration with the specified name was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02)*'/api/v2/cluster/IdpConfiguration/{name}\x12\xd7\x03\n" +
	"\x16UpdateIdpConfiguration\x125.lightbits.api.duros.v2.UpdateIDPConfigurationRequest\x1a(.lightbits.api.duros.v2.IDPConfiguration\"\xdb\x02\x92A\xac\x02\n" +
	"#Federated authentication operations\x12\x1cUpdate an IdP configuration.\x1a\x1cUpdate an IdP configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JI\n" +
	"\x03404\x12B\n" +
	"8IdP configuration with the specified name was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02%:\x01*\x1a /api/v2/cluster/IdpConfiguration\x12\x92\x03\n" +
	"\x15ListIdpConfigurations\x124.lightbits.api.duros.v2.ListIDPConfigurationsRequest\x1a5.lightbits.api.duros.v2.ListIDPConfigurationsResponse\"\x8b\x02\x92A\xdf\x01\n" +
	"#Federated authentication operations\x12\x1bListing IdP configurations.\x1a\x1bListing IdP configurations.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\"\x12 /api/v2/cluster/IdpConfiguration\x12\xcf\x03\n" +
	"\x13GetIdpConfiguration\x122.lightbits.api.duros.v2.GetIDPConfigurationRequest\x1a(.lightbits.api.duros.v2.IDPConfiguration\"\xd9\x02\x92A\xa6\x02\n" +
	"#Federated authentication operations\x12\x19Get an IdP configuration.\x1a\x19Get an IdP configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JI\n" +
	"\x03404\x12B\n" +
	"8IdP configuration with the specified name was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02)\x12'/api/v2/cluster/IdpConfiguration/{name}\x12\x8f\x03\n" +
	"\x13CreateIdpClientConf\x122.lightbits.api.duros.v2.CreateIdpClientConfRequest\x1a%.lightbits.api.duros.v2.IdpClientConf\"\x9c\x02\x92A\xef\x01\n" +
	"#Federated authentication operations\x12#Create an idp-client-configuration.\x1a#Create an idp-client-configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02#:\x01*\"\x1e/api/v2/cluster/idpClientConfs\x12\xf3\x03\n" +
	"\x13DeleteIdpClientConf\x122.lightbits.api.duros.v2.DeleteIdpClientConfRequest\x1a3.lightbits.api.duros.v2.DeleteIdpClientConfResponse\"\xf2\x02\x92A\xc1\x02\n" +
	"#Federated authentication operations\x12#Delete an idp-client-configuration.\x1a#Delete an idp-client-configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JP\n" +
	"\x03404\x12I\n" +
	"?idp-client-configuration with the specified name was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02'*%/api/v2/cluster/idpClientConfs/{name}\x12\xe8\x03\n" +
	"\x13UpdateIdpClientConf\x122.lightbits.api.duros.v2.UpdateIdpClientConfRequest\x1a%.lightbits.api.duros.v2.IdpClientConf\"\xf5\x02\x92A\xc1\x02\n" +
	"#Federated authentication operations\x12#Update an idp-client-configuration.\x1a#Update an idp-client-configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JP\n" +
	"\x03404\x12I\n" +
	"?idp-client-configuration with the specified name was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02*:\x01*\x1a%/api/v2/cluster/idpClientConfs/{name}\x12\x95\x03\n" +
	"\x12ListIdpClientConfs\x121.lightbits.api.duros.v2.ListIdpClientConfsRequest\x1a2.lightbits.api.duros.v2.ListIdpClientConfsResponse\"\x97\x02\x92A\xed\x01\n" +
	"#Federated authentication operations\x12\"Listing idp-client-configurations.\x1a\"Listing idp-client-configurations.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02 \x12\x1e/api/v2/cluster/idpClientConfs\x12\xd9\x03\n" +
	"\x10GetIdpClientConf\x12/.lightbits.api.duros.v2.GetIdpClientConfRequest\x1a%.lightbits.api.duros.v2.IdpClientConf\"\xec\x02\x92A\xbb\x02\n" +
	"#Federated authentication operations\x12 Get an idp-client-configuration.\x1a Get an idp-client-configuration.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JP\n" +
	"\x03404\x12I\n" +
	"?idp-client-configuration with the specified name was not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02'\x12%/api/v2/cluster/idpClientConfs/{name}\x12\xc9\x03\n" +
	"\x12CreateAuthMapEntry\x121.lightbits.api.duros.v2.CreateAuthMapEntryRequest\x1a$.lightbits.api.duros.v2.AuthMapEntry\"\xd9\x02\x92A\xb2\x02\n" +
	"#Federated authentication operations\x12\"Create an authorization map entry.\x1agCreate an authorization map entry that maps a clientID/claim/group to an access right (scope and role).J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1d:\x01*\"\x18/api/v2/cluster/authMaps\x12\xfc\x03\n" +
	"\x12UpdateAuthMapEntry\x121.lightbits.api.duros.v2.UpdateAuthMapEntryRequest\x1a$.lightbits.api.duros.v2.AuthMapEntry\"\x8c\x03\x92A\xde\x02\n" +
	"#Federated authentication operations\x12\"update an authorization map entry.\x1agUpdate an authorization map entry that maps a clientID/claim/group to an access right (scope and role).J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03404\x12#\n" +
	"\x19Auth map entry not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02$:\x01*\x1a\x1f/api/v2/cluster/authMaps/{name}\x12\x87\x04\n" +
	"\x12DeleteAuthMapEntry\x121.lightbits.api.duros.v2.DeleteAuthMapEntryRequest\x1a2.lightbits.api.duros.v2.DeleteAuthMapEntryResponse\"\x89\x03\x92A\xde\x02\n" +
	"#Federated authentication operations\x12\"Delete an authorization map entry.\x1agDelete an authorization map entry that maps a clientID/claim/group to an access right (scope and role).J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03404\x12#\n" +
	"\x19Auth map entry not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02!*\x1f/api/v2/cluster/authMaps/{name}\x12\xed\x03\n" +
	"\x0fGetAuthMapEntry\x12..lightbits.api.duros.v2.GetAuthMapEntryRequest\x1a$.lightbits.api.duros.v2.AuthMapEntry\"\x83\x03\x92A\xd8\x02\n" +
	"#Federated authentication operations\x12\x1fGet an authorization map entry.\x1adGet an authorization map entry that maps a clientID/claim/group to an access right (scope and role).J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J*\n" +
	"\x03404\x12#\n" +
	"\x19Auth map entry not found.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02!\x12\x1f/api/v2/cluster/authMaps/{name}\x12\xc7\x03\n" +
	"\x12ListAuthMapEntries\x121.lightbits.api.duros.v2.ListAuthMapEntriesRequest\x1a2.lightbits.api.duros.v2.ListAuthMapEntriesResponse\"\xc9\x02\x92A\xa5\x02\n" +
	"#Federated authentication operations\x12#List all authorization map entries.\x1aYList all map entries between a clientID/claim/group and an access right (scope and role).J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x1a\x12\x18/api/v2/cluster/authMaps\x12\xb9\x06\n" +
	"\x17EnableClusterInBandAuth\x126.lightbits.api.duros.v2.EnableClusterInBandAuthRequest\x1a7.lightbits.api.duros.v2.EnableClusterInBandAuthResponse\"\xac\x05\x92A\xfc\x04\n" +
	"!In-Band authentication operations\x12-Enable In-Band cluster authentication (Beta).\x1a\xcb\x03Enables NVMe-oF In-Band Authentication. This allows a Lightbits cluster to selectively restrict the set of NVMe hosts (clients) that are allowed to connect to the NVMe target (Lightbits cluster), and also (optionally), restrict the set NVMe targets that a given NVMe host will trust and connect to. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02&:\x01*\"!/api/v2/cluster/inBandAuth/enable\x12\xaf\x05\n" +
	"\x18DisableClusterInBandAuth\x127.lightbits.api.duros.v2.DisableClusterInBandAuthRequest\x1a8.lightbits.api.duros.v2.DisableClusterInBandAuthResponse\"\x9f\x04\x92A\xee\x03\n" +
	"!In-Band authentication operations\x12.Disable In-Band cluster authentication (Beta).\x1a\xbc\x02Disables NVMe-oF In Band Authentication. Hosts can connect to a Lightbits cluster without establishing trust (the default Lightbits cluster configuration). In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02':\x01*\"\"/api/v2/cluster/inBandAuth/disable\x12\x8c\a\n" +
	"\x11CreateTrustedHost\x120.lightbits.api.duros.v2.CreateTrustedHostRequest\x1a#.lightbits.api.duros.v2.TrustedHost\"\x9f\x06\x92A\xe5\x05\n" +
	"!In-Band authentication operations\x12\x1fCreate a trusted host resource.\x1a\xc9\x03Create a trusted host resource with configuration parameters needed for authentication and NVMe connectivity. When In-Band Authentication is enabled, only trusted hosts can connect to a Lightbits cluster. For each trusted host, an associated Lightbits resource must be created using this command. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JR\n" +
	"\x03409\x12K\n" +
	"AHost with the provided host name and project name already exists.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x020:\x01*\"+/api/v2/projects/{projectName}/trustedHosts\x12\xf2\x04\n" +
	"\x11DeleteTrustedHost\x120.lightbits.api.duros.v2.DeleteTrustedHostRequest\x1a1.lightbits.api.duros.v2.DeleteTrustedHostResponse\"\xf7\x03\x92A\xb9\x03\n" +
	"!In-Band authentication operations\x12\x16Delete a trusted host.\x1a\xc5\x01Delete a trusted host configuration. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J3\n" +
	"\x03404\x12,\n" +
	"\"Failed to find host name/project .\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x024*2/api/v2/projects/{projectName}/trustedHosts/{name}\x12\xcf\x04\n" +
	"\x0eGetTrustedHost\x12-.lightbits.api.duros.v2.GetTrustedHostRequest\x1a#.lightbits.api.duros.v2.TrustedHost\"\xe8\x03\x92A\xaa\x03\n" +
	"!In-Band authentication operations\x12\vGet a host.\x1a\xc2\x01Get a trusted host configuration. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J2\n" +
	"\x03404\x12+\n" +
	"!Failed to find host name/project.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x024\x122/api/v2/projects/{projectName}/trustedHosts/{name}\x12\x9a\x05\n" +
	"\x10ListTrustedHosts\x12/.lightbits.api.duros.v2.ListTrustedHostsRequest\x1a0.lightbits.api.duros.v2.ListTrustedHostsResponse\"\xa2\x04\x92A\xda\x03\n" +
	"!In-Band authentication operations\x12.Return a list of trusted hosts configurations.\x1a\xcf\x01Return a list of trusted hosts configurations. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J2\n" +
	"\x03404\x12+\n" +
	"!Failed to find host name/project.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02>Z\x0f\x12\r/api/v2/hosts\x12+/api/v2/projects/{projectName}/trustedHosts\x12\xfb\x04\n" +
	"\x11UpdateTrustedHost\x120.lightbits.api.duros.v2.UpdateTrustedHostRequest\x1a#.lightbits.api.duros.v2.TrustedHost\"\x8e\x04\x92A\xcd\x03\n" +
	"!In-Band authentication operations\x12\x0eUpdate a host.\x1a\xe2\x01Update a trusted host configuration, optionally modifying labels. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J2\n" +
	"\x03404\x12+\n" +
	"!Failed to find host name/project.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x027:\x01*\x1a2/api/v2/projects/{projectName}/trustedHosts/{name}\x12\xa1\b\n" +
	"\x14SetTrustedHostSecret\x124.lightbits.api.duros.v2.SetTrustedHostSecretsRequest\x1a5.lightbits.api.duros.v2.SetTrustedHostSecretsResponse\"\x9b\a\x92A\xd4\x06\n" +
	"!In-Band authentication operations\x12\x1bSet the secrets for a host.\x1a\x81\x05Set hosts secrets for a trusted host to allow trusted connectivity between a Lightbits cluster and hosts, as part of In-Band Authentication support. Specifying a host secret is mandatory for trusted connect of this host to the Lightbits cluster, Specifying a target secret - either explicitly or by using auto-gen mode - is optional, allowing only a trusted Lightbits cluster to connect to the host, If no target secret is specified, the target secret type will be set to disable. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J2\n" +
	"\x03404\x12+\n" +
	"!Failed to find host name/project.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02=:\x01*\x1a8/api/v2/projects/{projectName}/trustedHostSecrets/{name}\x12\xff\x04\n" +
	"\x14GetTrustedHostSecret\x124.lightbits.api.duros.v2.GetTrustedHostSecretsRequest\x1a5.lightbits.api.duros.v2.GetTrustedHostSecretsResponse\"\xf9\x03\x92A\xb5\x03\n" +
	"!In-Band authentication operations\x12\x16Get secrets of a host.\x1a\xe7\x01Get a trusted host secrets required for authentication and connection. In-Band Authentication functionality and its APIs are under development, available for evaluation purposes only. They should not be used in production clusters.J#\n" +
	"\x03400\x12\x1c\n" +
	"\x12Invalid arguments.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J2\n" +
	"\x03404\x12+\n" +
	"!Failed to find host name/project.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02:\x128/api/v2/projects/{projectName}/trustedHostSecrets/{name}\x12\xa1\x03\n" +
	"\x1dEnableFederatedAuthentication\x12<.lightbits.api.duros.v2.EnableFederatedAuthenticationRequest\x1a=.lightbits.api.duros.v2.EnableFederatedAuthenticationResponse\"\x82\x02\x92A\xc5\x01\n" +
	"#Federated authentication operations\x12 Enable Federated Authentication.\x1a Enable Federated Authentication.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x023:\x01*\"./api/v2/cluster/federatedAuthentication/enable\x12\xa7\x03\n" +
	"\x1eDisableFederatedAuthentication\x12=.lightbits.api.duros.v2.DisableFederatedAuthenticationRequest\x1a>.lightbits.api.duros.v2.DisableFederatedAuthenticationResponse\"\x85\x02\x92A\xc7\x01\n" +
	"#Federated authentication operations\x12!Disable Federated Authentication.\x1a!Disable Federated Authentication.J5\n" +
	"\x03401\x12.\n" +
	"$Unauthorized: authentication failed.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J#\n" +
	"\x03403\x12\x1c\n" +
	"\x12Permission denied.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x024:\x01*\"//api/v2/cluster/federatedAuthentication/disable\x12\xda\x03\n" +
	"\aCFLogin\x12&.lightbits.api.duros.v2.CFLoginRequest\x1a'.lightbits.api.duros.v2.CFLoginResponse\"\xfd\x02\x92A\xe2\x02\n" +
	"\x12Cluster Federation\x12 Login to the cluster federation.\x1a\x92\x01Login to the cluster federation service. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JB\n" +
	"\x03500\x12;\n" +
	"1Internal error in the cluster-federation service.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03b\x0f\n" +
	"\r\n" +
	"\tBasicAuth\x12\x00\x82\xd3\xe4\x93\x02\x11\"\x0f/api/v2/cflogin\x12\x8c\x03\n" +
	"\fListClusters\x12+.lightbits.api.duros.v2.ListClustersRequest\x1a,.lightbits.api.duros.v2.ListClustersResponse\"\xa0\x02\x92A\x84\x02\n" +
	"\x12Cluster Federation\x12\x0eList clusters.\x1a\x9b\x01List clusters attached to the cluster-federation. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x12\x12\x10/api/v2/clusters\x12\x86\x04\n" +
	"\rDetachCluster\x12,.lightbits.api.duros.v2.DetachClusterRequest\x1a-.lightbits.api.duros.v2.DetachClusterResponse\"\x97\x03\x92A\xf5\x02\n" +
	"\x12Cluster Federation\x12\x1bDetach an existing cluster.\x1a\x97\x01Detaches an existing cluster from the system. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JB\n" +
	"\x03500\x12;\n" +
	"1Internal error in the cluster-federation service.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x18*\x16/api/v2/clusters/{cid}\x12\xf5\x03\n" +
	"\rAttachCluster\x12,.lightbits.api.duros.v2.AttachClusterRequest\x1a-.lightbits.api.duros.v2.AttachClusterResponse\"\x86\x03\x92A\xe7\x02\n" +
	"\x12Cluster Federation\x12\x15Attach a new cluster.\x1a\x8f\x01Attaches a new cluster to the system. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JB\n" +
	"\x03500\x12;\n" +
	"1Internal error in the cluster-federation service.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x15:\x01*\"\x10/api/v2/clusters\x12\xd6\x03\n" +
	"\x17GetCFServiceCredentials\x126.lightbits.api.duros.v2.GetCFServiceCredentialsRequest\x1a7.lightbits.api.duros.v2.GetCFServiceCredentialsResponse\"\xc9\x02\x92A\x9f\x02\n" +
	"\x12Cluster Federation\x12*Get cluster-federation service credentials\x1a\x9a\x01Gets the cluster-federation service credentials. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02 \x12\x1e/api/v2/cf-service-credentials\x12\xf0\x03\n" +
	"\rListWorkflows\x12,.lightbits.api.duros.v2.ListWorkflowsRequest\x1a-.lightbits.api.duros.v2.ListWorkflowsResponse\"\x81\x03\x92A\xe4\x02\n" +
	"\x12Cluster Federation\x12\x0eList workflows\x1a\x93\x01List the running and completed workflows. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JB\n" +
	"\x03500\x12;\n" +
	"1Internal error in the cluster-federation service.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02\x13\x12\x11/api/v2/workflows\x12\xfa\x03\n" +
	"\vGetWorkflow\x12*.lightbits.api.duros.v2.GetWorkflowRequest\x1a+.lightbits.api.duros.v2.GetWorkflowResponse\"\x91\x03\x92A\xe7\x02\n" +
	"\x12Cluster Federation\x12\x17Get a specific workflow\x1a\x8d\x01Gets a specific workflow by its ID. This API is currently unavailable. It is reserved for future support of cluster federation functionality.J\"\n" +
	"\x03400\x12\x1b\n" +
	"\x11Invalid argument.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03J@\n" +
	"\x03401\x129\n" +
	"/Authentication required / Authentication failed\x12\x06\n" +
	"\x04\x9a\x02\x01\x03JB\n" +
	"\x03500\x12;\n" +
	"1Internal error in the cluster-federation service.\x12\x06\n" +
	"\x04\x9a\x02\x01\x03\x82\xd3\xe4\x93\x02 \x12\x1e/api/v2/workflows/{workflowId}B\rZ\vduros/v2;v2b\x06proto3"

var (
	file_lightbits_api_duros_v2_durosapiv2_proto_rawDescOnce sync.Once
	file_lightbits_api_duros_v2_durosapiv2_proto_rawDescData []byte
)

func file_lightbits_api_duros_v2_durosapiv2_proto_rawDescGZIP() []byte {
	file_lightbits_api_duros_v2_durosapiv2_proto_rawDescOnce.Do(func() {
		file_lightbits_api_duros_v2_durosapiv2_proto_rawDescData = protoimpl.X.CompressGZIP(unsafe.Slice(unsafe.StringData(file_lightbits_api_duros_v2_durosapiv2_proto_rawDesc), len(file_lightbits_api_duros_v2_durosapiv2_proto_rawDesc)))
	})
	return file_lightbits_api_duros_v2_durosapiv2_proto_rawDescData
}

var file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes = make([]protoimpl.EnumInfo, 35)
var file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes = make([]protoimpl.MessageInfo, 194)
var file_lightbits_api_duros_v2_durosapiv2_proto_goTypes = []any{
	(CredsType)(0),                                   // 0: lightbits.api.duros.v2.CredsType
	(CredsKind)(0),                                   // 1: lightbits.api.duros.v2.CredsKind
	(ProtectionStateEnum)(0),                         // 2: lightbits.api.duros.v2.ProtectionStateEnum
	(PolicyVisibility)(0),                            // 3: lightbits.api.duros.v2.PolicyVisibility
	(PolicyType)(0),                                  // 4: lightbits.api.duros.v2.PolicyType
	(IdpHealthStatus)(0),                             // 5: lightbits.api.duros.v2.IdpHealthStatus
	(IDPType)(0),                                     // 6: lightbits.api.duros.v2.IDPType
	(FedAuthState)(0),                                // 7: lightbits.api.duros.v2.fedAuthState
	(CreateVolumeRequest_SectorSizeEnum)(0),          // 8: lightbits.api.duros.v2.CreateVolumeRequest.SectorSizeEnum
	(EnableClusterEncryptionRequest_KeyStore)(0),     // 9: lightbits.api.duros.v2.EnableClusterEncryptionRequest.KeyStore
	(UserNvmeDevicesResponse_StateEnum)(0),           // 10: lightbits.api.duros.v2.UserNvmeDevicesResponse.StateEnum
	(UserNvmeDevicesResponse_DeviceUsageEnum)(0),     // 11: lightbits.api.duros.v2.UserNvmeDevicesResponse.DeviceUsageEnum
	(DurosNodeInfo_State)(0),                         // 12: lightbits.api.duros.v2.DurosNodeInfo.State
	(DurosNodeInfo_StatusEnum)(0),                    // 13: lightbits.api.duros.v2.DurosNodeInfo.StatusEnum
	(ClusterLastUpgrade_UpgradeStatusEnum)(0),        // 14: lightbits.api.duros.v2.ClusterLastUpgrade.UpgradeStatusEnum
	(ClusterInfo_AuthenticationMode)(0),              // 15: lightbits.api.duros.v2.ClusterInfo.AuthenticationMode
	(ClusterHealth_State)(0),                         // 16: lightbits.api.duros.v2.ClusterHealth.State
	(Volume_StateEnum)(0),                            // 17: lightbits.api.duros.v2.Volume.StateEnum
	(Volume_ProtocolEnum)(0),                         // 18: lightbits.api.duros.v2.Volume.ProtocolEnum
	(ServerEvictionStatus_StatusEnum)(0),             // 19: lightbits.api.duros.v2.ServerEvictionStatus.StatusEnum
	(ServerLastUpgrade_UpgradeStatusEnum)(0),         // 20: lightbits.api.duros.v2.ServerLastUpgrade.UpgradeStatusEnum
	(Server_UpgradeStatusEnum)(0),                    // 21: lightbits.api.duros.v2.Server.UpgradeStatusEnum
	(Server_RiskOfServiceLossEnum)(0),                // 22: lightbits.api.duros.v2.Server.RiskOfServiceLossEnum
	(Server_ServerStateEnum)(0),                      // 23: lightbits.api.duros.v2.Server.ServerStateEnum
	(Snapshot_StateEnum)(0),                          // 24: lightbits.api.duros.v2.Snapshot.StateEnum
	(ResourcePolicy_State)(0),                        // 25: lightbits.api.duros.v2.ResourcePolicy.State
	(Policy_State)(0),                                // 26: lightbits.api.duros.v2.Policy.State
	(LabelValueKeyPair_Key)(0),                       // 27: lightbits.api.duros.v2.LabelValueKeyPair.Key
	(LabelMatchExpression_Operator)(0),               // 28: lightbits.api.duros.v2.LabelMatchExpression.Operator
	(Event_EventType)(0),                             // 29: lightbits.api.duros.v2.Event.EventType
	(Event_EventReportingService)(0),                 // 30: lightbits.api.duros.v2.Event.EventReportingService
	(Event_EventSeverity)(0),                         // 31: lightbits.api.duros.v2.Event.EventSeverity
	(ClusterEncryptionStatus_State)(0),               // 32: lightbits.api.duros.v2.ClusterEncryptionStatus.State
	(ClusterEncryptionStatus_RotationState)(0),       // 33: lightbits.api.duros.v2.ClusterEncryptionStatus.RotationState
	(IDPConfiguration_IDPConfigurationState)(0),      // 34: lightbits.api.duros.v2.IDPConfiguration.IDPConfigurationState
	(*LogRequest)(nil),                               // 35: lightbits.api.duros.v2.LogRequest
	(*AdminEndpoint)(nil),                            // 36: lightbits.api.duros.v2.AdminEndpoint
	(*GetAdminEndpointRequest)(nil),                  // 37: lightbits.api.duros.v2.GetAdminEndpointRequest
	(*ListAdminEndpointsResponse)(nil),               // 38: lightbits.api.duros.v2.ListAdminEndpointsResponse
	(*ListAdminEndpointsRequest)(nil),                // 39: lightbits.api.duros.v2.ListAdminEndpointsRequest
	(*CreateAdminEndpointRequest)(nil),               // 40: lightbits.api.duros.v2.CreateAdminEndpointRequest
	(*UpdateAdminEndpointRequest)(nil),               // 41: lightbits.api.duros.v2.UpdateAdminEndpointRequest
	(*DeleteAdminEndpointRequest)(nil),               // 42: lightbits.api.duros.v2.DeleteAdminEndpointRequest
	(*DeleteAdminEndpointResponse)(nil),              // 43: lightbits.api.duros.v2.DeleteAdminEndpointResponse
	(*CreateCredentialRequest)(nil),                  // 44: lightbits.api.duros.v2.CreateCredentialRequest
	(*Credential)(nil),                               // 45: lightbits.api.duros.v2.Credential
	(*DeleteCredentialRequest)(nil),                  // 46: lightbits.api.duros.v2.DeleteCredentialRequest
	(*DeleteCredentialResponse)(nil),                 // 47: lightbits.api.duros.v2.DeleteCredentialResponse
	(*ListCredentialsRequest)(nil),                   // 48: lightbits.api.duros.v2.ListCredentialsRequest
	(*ListCredentialsResponse)(nil),                  // 49: lightbits.api.duros.v2.ListCredentialsResponse
	(*GetCredentialRequest)(nil),                     // 50: lightbits.api.duros.v2.GetCredentialRequest
	(*DefaultPolicy)(nil),                            // 51: lightbits.api.duros.v2.DefaultPolicy
	(*CreateProjectRequest)(nil),                     // 52: lightbits.api.duros.v2.CreateProjectRequest
	(*Project)(nil),                                  // 53: lightbits.api.duros.v2.Project
	(*DeleteProjectRequest)(nil),                     // 54: lightbits.api.duros.v2.DeleteProjectRequest
	(*DeleteProjectResponse)(nil),                    // 55: lightbits.api.duros.v2.DeleteProjectResponse
	(*ListProjectsRequest)(nil),                      // 56: lightbits.api.duros.v2.ListProjectsRequest
	(*ListProjectsResponse)(nil),                     // 57: lightbits.api.duros.v2.ListProjectsResponse
	(*GetProjectRequest)(nil),                        // 58: lightbits.api.duros.v2.GetProjectRequest
	(*StringList)(nil),                               // 59: lightbits.api.duros.v2.StringList
	(*GetVersionRequest)(nil),                        // 60: lightbits.api.duros.v2.GetVersionRequest
	(*CreateVolumeRequest)(nil),                      // 61: lightbits.api.duros.v2.CreateVolumeRequest
	(*DeleteVolumeRequest)(nil),                      // 62: lightbits.api.duros.v2.DeleteVolumeRequest
	(*DeleteVolumeResponse)(nil),                     // 63: lightbits.api.duros.v2.DeleteVolumeResponse
	(*EnableServerRequest)(nil),                      // 64: lightbits.api.duros.v2.EnableServerRequest
	(*DisableServerRequest)(nil),                     // 65: lightbits.api.duros.v2.DisableServerRequest
	(*DeleteServerRequest)(nil),                      // 66: lightbits.api.duros.v2.DeleteServerRequest
	(*ReplaceNodeRequest)(nil),                       // 67: lightbits.api.duros.v2.ReplaceNodeRequest
	(*CreateServerRequest)(nil),                      // 68: lightbits.api.duros.v2.CreateServerRequest
	(*UpdateVolumeRequest)(nil),                      // 69: lightbits.api.duros.v2.UpdateVolumeRequest
	(*UpgradeServerRequest)(nil),                     // 70: lightbits.api.duros.v2.UpgradeServerRequest
	(*UpgradeClusterRequest)(nil),                    // 71: lightbits.api.duros.v2.UpgradeClusterRequest
	(*EnableClusterEncryptionRequest)(nil),           // 72: lightbits.api.duros.v2.EnableClusterEncryptionRequest
	(*GetClusterRequest)(nil),                        // 73: lightbits.api.duros.v2.GetClusterRequest
	(*UpdateNvmeDeviceRequest)(nil),                  // 74: lightbits.api.duros.v2.UpdateNvmeDeviceRequest
	(*AddNvmeDeviceRequest)(nil),                     // 75: lightbits.api.duros.v2.AddNvmeDeviceRequest
	(*GetHostRequest)(nil),                           // 76: lightbits.api.duros.v2.GetHostRequest
	(*ListHostsRequest)(nil),                         // 77: lightbits.api.duros.v2.ListHostsRequest
	(*ListHostsResponse)(nil),                        // 78: lightbits.api.duros.v2.ListHostsResponse
	(*ListNodeRequest)(nil),                          // 79: lightbits.api.duros.v2.ListNodeRequest
	(*ListEventsRequest)(nil),                        // 80: lightbits.api.duros.v2.ListEventsRequest
	(*ListEventsResponse)(nil),                       // 81: lightbits.api.duros.v2.ListEventsResponse
	(*GetVolumeRequest)(nil),                         // 82: lightbits.api.duros.v2.GetVolumeRequest
	(*GetNodeRequest)(nil),                           // 83: lightbits.api.duros.v2.GetNodeRequest
	(*ListVolumeRequest)(nil),                        // 84: lightbits.api.duros.v2.ListVolumeRequest
	(*ListNvmeDevicesRequest)(nil),                   // 85: lightbits.api.duros.v2.ListNvmeDevicesRequest
	(*GetNvmeDeviceRequest)(nil),                     // 86: lightbits.api.duros.v2.GetNvmeDeviceRequest
	(*ListNvmeDevicesResponse)(nil),                  // 87: lightbits.api.duros.v2.ListNvmeDevicesResponse
	(*ConnectedHost)(nil),                            // 88: lightbits.api.duros.v2.ConnectedHost
	(*UserNvmeDevicesResponse)(nil),                  // 89: lightbits.api.duros.v2.UserNvmeDevicesResponse
	(*DurosNodeInfo)(nil),                            // 90: lightbits.api.duros.v2.DurosNodeInfo
	(*JournalRaidDevice)(nil),                        // 91: lightbits.api.duros.v2.JournalRaidDevice
	(*JournalNvmeDevice)(nil),                        // 92: lightbits.api.duros.v2.JournalNvmeDevice
	(*ListNodesResponse)(nil),                        // 93: lightbits.api.duros.v2.ListNodesResponse
	(*ListVolumesResponse)(nil),                      // 94: lightbits.api.duros.v2.ListVolumesResponse
	(*UpdateNvmeDeviceResponse)(nil),                 // 95: lightbits.api.duros.v2.UpdateNvmeDeviceResponse
	(*AddNvmeDeviceResponse)(nil),                    // 96: lightbits.api.duros.v2.AddNvmeDeviceResponse
	(*UpdateVolumeResponse)(nil),                     // 97: lightbits.api.duros.v2.UpdateVolumeResponse
	(*UpgradeServerResponse)(nil),                    // 98: lightbits.api.duros.v2.UpgradeServerResponse
	(*UpgradeClusterResponse)(nil),                   // 99: lightbits.api.duros.v2.UpgradeClusterResponse
	(*EnableClusterEncryptionResponse)(nil),          // 100: lightbits.api.duros.v2.EnableClusterEncryptionResponse
	(*ReplaceNodeResponse)(nil),                      // 101: lightbits.api.duros.v2.ReplaceNodeResponse
	(*DeleteServerResponse)(nil),                     // 102: lightbits.api.duros.v2.DeleteServerResponse
	(*DisableServerResponse)(nil),                    // 103: lightbits.api.duros.v2.DisableServerResponse
	(*StartNodeInstanceRequest)(nil),                 // 104: lightbits.api.duros.v2.StartNodeInstanceRequest
	(*StartNodeInstanceResponse)(nil),                // 105: lightbits.api.duros.v2.StartNodeInstanceResponse
	(*StopNodeInstanceRequest)(nil),                  // 106: lightbits.api.duros.v2.StopNodeInstanceRequest
	(*StopNodeInstanceResponse)(nil),                 // 107: lightbits.api.duros.v2.StopNodeInstanceResponse
	(*RestartNodeInstanceRequest)(nil),               // 108: lightbits.api.duros.v2.RestartNodeInstanceRequest
	(*RestartNodeInstanceResponse)(nil),              // 109: lightbits.api.duros.v2.RestartNodeInstanceResponse
	(*ListServersRequest)(nil),                       // 110: lightbits.api.duros.v2.ListServersRequest
	(*GetServerRequest)(nil),                         // 111: lightbits.api.duros.v2.GetServerRequest
	(*ListServersResponse)(nil),                      // 112: lightbits.api.duros.v2.ListServersResponse
	(*ClusterUpgradeStatusResponse)(nil),             // 113: lightbits.api.duros.v2.ClusterUpgradeStatusResponse
	(*ListUpgradeStatusResponse)(nil),                // 114: lightbits.api.duros.v2.ListUpgradeStatusResponse
	(*Version)(nil),                                  // 115: lightbits.api.duros.v2.Version
	(*ClusterLastUpgrade)(nil),                       // 116: lightbits.api.duros.v2.ClusterLastUpgrade
	(*ClusterInfo)(nil),                              // 117: lightbits.api.duros.v2.ClusterInfo
	(*ClusterInfoV2)(nil),                            // 118: lightbits.api.duros.v2.ClusterInfoV2
	(*ClusterHealth)(nil),                            // 119: lightbits.api.duros.v2.ClusterHealth
	(*Volume)(nil),                                   // 120: lightbits.api.duros.v2.Volume
	(*ServerEvictionStatus)(nil),                     // 121: lightbits.api.duros.v2.ServerEvictionStatus
	(*ServerLastUpgrade)(nil),                        // 122: lightbits.api.duros.v2.ServerLastUpgrade
	(*Server)(nil),                                   // 123: lightbits.api.duros.v2.Server
	(*GetRoleRequest)(nil),                           // 124: lightbits.api.duros.v2.GetRoleRequest
	(*GetRoleResponse)(nil),                          // 125: lightbits.api.duros.v2.GetRoleResponse
	(*Role)(nil),                                     // 126: lightbits.api.duros.v2.Role
	(*ListRolesRequest)(nil),                         // 127: lightbits.api.duros.v2.ListRolesRequest
	(*ListRolesResponse)(nil),                        // 128: lightbits.api.duros.v2.ListRolesResponse
	(*Snapshot)(nil),                                 // 129: lightbits.api.duros.v2.Snapshot
	(*DeleteSnapshotRequest)(nil),                    // 130: lightbits.api.duros.v2.DeleteSnapshotRequest
	(*CreateSnapshotRequest)(nil),                    // 131: lightbits.api.duros.v2.CreateSnapshotRequest
	(*ListSnapshotsRequest)(nil),                     // 132: lightbits.api.duros.v2.ListSnapshotsRequest
	(*GetSnapshotRequest)(nil),                       // 133: lightbits.api.duros.v2.GetSnapshotRequest
	(*ListSnapshotsResponse)(nil),                    // 134: lightbits.api.duros.v2.ListSnapshotsResponse
	(*DeleteSnapshotResponse)(nil),                   // 135: lightbits.api.duros.v2.DeleteSnapshotResponse
	(*FeatureFlagStatus)(nil),                        // 136: lightbits.api.duros.v2.FeatureFlagStatus
	(*GetFeatureFlagRequest)(nil),                    // 137: lightbits.api.duros.v2.GetFeatureFlagRequest
	(*EnableFeatureFlagRequest)(nil),                 // 138: lightbits.api.duros.v2.EnableFeatureFlagRequest
	(*DisableFeatureFlagRequest)(nil),                // 139: lightbits.api.duros.v2.DisableFeatureFlagRequest
	(*SetFeatureFlagResponse)(nil),                   // 140: lightbits.api.duros.v2.SetFeatureFlagResponse
	(*ListFeatureFlagsRequest)(nil),                  // 141: lightbits.api.duros.v2.ListFeatureFlagsRequest
	(*ListFeatureFlagsResponse)(nil),                 // 142: lightbits.api.duros.v2.ListFeatureFlagsResponse
	(*CreateResourcePolicyRequest)(nil),              // 143: lightbits.api.duros.v2.CreateResourcePolicyRequest
	(*CreatePolicyRequest)(nil),                      // 144: lightbits.api.duros.v2.CreatePolicyRequest
	(*UpdatePolicyRequest)(nil),                      // 145: lightbits.api.duros.v2.UpdatePolicyRequest
	(*UpdatePolicyResponse)(nil),                     // 146: lightbits.api.duros.v2.UpdatePolicyResponse
	(*ResourcePolicy)(nil),                           // 147: lightbits.api.duros.v2.ResourcePolicy
	(*Policy)(nil),                                   // 148: lightbits.api.duros.v2.Policy
	(*UpdateResourcePolicyRequest)(nil),              // 149: lightbits.api.duros.v2.UpdateResourcePolicyRequest
	(*UpdateResourcePolicyResponse)(nil),             // 150: lightbits.api.duros.v2.UpdateResourcePolicyResponse
	(*ListPoliciesRequest)(nil),                      // 151: lightbits.api.duros.v2.ListPoliciesRequest
	(*ListPoliciesResponse)(nil),                     // 152: lightbits.api.duros.v2.ListPoliciesResponse
	(*ListResourcePoliciesRequest)(nil),              // 153: lightbits.api.duros.v2.ListResourcePoliciesRequest
	(*ListResourcePoliciesResponse)(nil),             // 154: lightbits.api.duros.v2.ListResourcePoliciesResponse
	(*GetPolicyRequest)(nil),                         // 155: lightbits.api.duros.v2.GetPolicyRequest
	(*GetResourcePolicyRequest)(nil),                 // 156: lightbits.api.duros.v2.GetResourcePolicyRequest
	(*DeleteResourcePolicyRequest)(nil),              // 157: lightbits.api.duros.v2.DeleteResourcePolicyRequest
	(*DeleteResourcePolicyResponse)(nil),             // 158: lightbits.api.duros.v2.DeleteResourcePolicyResponse
	(*DeletePolicyRequest)(nil),                      // 159: lightbits.api.duros.v2.DeletePolicyRequest
	(*DeletePolicyResponse)(nil),                     // 160: lightbits.api.duros.v2.DeletePolicyResponse
	(*GetClusterConfigParamRequest)(nil),             // 161: lightbits.api.duros.v2.GetClusterConfigParamRequest
	(*ClusterConfigParam)(nil),                       // 162: lightbits.api.duros.v2.ClusterConfigParam
	(*UpdateClusterConfigParamRequest)(nil),          // 163: lightbits.api.duros.v2.UpdateClusterConfigParamRequest
	(*RollbackVolumeRequest)(nil),                    // 164: lightbits.api.duros.v2.RollbackVolumeRequest
	(*RollbackVolumeResponse)(nil),                   // 165: lightbits.api.duros.v2.RollbackVolumeResponse
	(*UpdateClusterConfigParamResponse)(nil),         // 166: lightbits.api.duros.v2.UpdateClusterConfigParamResponse
	(*ListClusterConfigParamsRequest)(nil),           // 167: lightbits.api.duros.v2.ListClusterConfigParamsRequest
	(*ListClusterConfigParamsResponse)(nil),          // 168: lightbits.api.duros.v2.ListClusterConfigParamsResponse
	(*LabelValueKeyPair)(nil),                        // 169: lightbits.api.duros.v2.LabelValueKeyPair
	(*LabelMatchExpression)(nil),                     // 170: lightbits.api.duros.v2.LabelMatchExpression
	(*ComponentVolumeInfo)(nil),                      // 171: lightbits.api.duros.v2.ComponentVolumeInfo
	(*VolumeComponentInfoList)(nil),                  // 172: lightbits.api.duros.v2.VolumeComponentInfoList
	(*ComponentVolumesInfo)(nil),                     // 173: lightbits.api.duros.v2.ComponentVolumesInfo
	(*ComponentNodeInfo)(nil),                        // 174: lightbits.api.duros.v2.ComponentNodeInfo
	(*ComponentClusterInfo)(nil),                     // 175: lightbits.api.duros.v2.ComponentClusterInfo
	(*ComponentNVMeSSDInfo)(nil),                     // 176: lightbits.api.duros.v2.ComponentNVMeSSDInfo
	(*ComponentServerInfo)(nil),                      // 177: lightbits.api.duros.v2.ComponentServerInfo
	(*ComponentDataIntegrityInfo)(nil),               // 178: lightbits.api.duros.v2.ComponentDataIntegrityInfo
	(*LBARange)(nil),                                 // 179: lightbits.api.duros.v2.LBARange
	(*ListChangedBlocksRequest)(nil),                 // 180: lightbits.api.duros.v2.ListChangedBlocksRequest
	(*ListChangedBlocksResponse)(nil),                // 181: lightbits.api.duros.v2.ListChangedBlocksResponse
	(*Event)(nil),                                    // 182: lightbits.api.duros.v2.Event
	(*QoSRateLimitPolicy)(nil),                       // 183: lightbits.api.duros.v2.QoSRateLimitPolicy
	(*DefaultGlobalResourcePolicy)(nil),              // 184: lightbits.api.duros.v2.DefaultGlobalResourcePolicy
	(*UpdateProjectRequest)(nil),                     // 185: lightbits.api.duros.v2.UpdateProjectRequest
	(*UpdateProjectResponse)(nil),                    // 186: lightbits.api.duros.v2.UpdateProjectResponse
	(*ClusterEncryptionStatus)(nil),                  // 187: lightbits.api.duros.v2.ClusterEncryptionStatus
	(*IdpHealthInfo)(nil),                            // 188: lightbits.api.duros.v2.IdpHealthInfo
	(*FederatedAuthenticationStatus)(nil),            // 189: lightbits.api.duros.v2.FederatedAuthenticationStatus
	(*RotateClusterRootKeyRequest)(nil),              // 190: lightbits.api.duros.v2.RotateClusterRootKeyRequest
	(*RotateClusterRootKeyResponse)(nil),             // 191: lightbits.api.duros.v2.RotateClusterRootKeyResponse
	(*GetClusterRootKeyRequest)(nil),                 // 192: lightbits.api.duros.v2.GetClusterRootKeyRequest
	(*GetClusterRootKeyResponse)(nil),                // 193: lightbits.api.duros.v2.GetClusterRootKeyResponse
	(*IDPConfiguration)(nil),                         // 194: lightbits.api.duros.v2.IDPConfiguration
	(*CreateIDPConfigurationRequest)(nil),            // 195: lightbits.api.duros.v2.CreateIDPConfigurationRequest
	(*UpdateIDPConfigurationRequest)(nil),            // 196: lightbits.api.duros.v2.UpdateIDPConfigurationRequest
	(*ListIDPConfigurationsRequest)(nil),             // 197: lightbits.api.duros.v2.ListIDPConfigurationsRequest
	(*ListIDPConfigurationsResponse)(nil),            // 198: lightbits.api.duros.v2.ListIDPConfigurationsResponse
	(*GetIDPConfigurationRequest)(nil),               // 199: lightbits.api.duros.v2.GetIDPConfigurationRequest
	(*DeleteIDPConfigurationRequest)(nil),            // 200: lightbits.api.duros.v2.DeleteIDPConfigurationRequest
	(*DeleteIDPConfigurationResponse)(nil),           // 201: lightbits.api.duros.v2.DeleteIDPConfigurationResponse
	(*IdpClientConf)(nil),                            // 202: lightbits.api.duros.v2.IdpClientConf
	(*CreateIdpClientConfRequest)(nil),               // 203: lightbits.api.duros.v2.CreateIdpClientConfRequest
	(*UpdateIdpClientConfRequest)(nil),               // 204: lightbits.api.duros.v2.UpdateIdpClientConfRequest
	(*GetIdpClientConfRequest)(nil),                  // 205: lightbits.api.duros.v2.GetIdpClientConfRequest
	(*DeleteIdpClientConfRequest)(nil),               // 206: lightbits.api.duros.v2.DeleteIdpClientConfRequest
	(*DeleteIdpClientConfResponse)(nil),              // 207: lightbits.api.duros.v2.DeleteIdpClientConfResponse
	(*ListIdpClientConfsRequest)(nil),                // 208: lightbits.api.duros.v2.ListIdpClientConfsRequest
	(*ListIdpClientConfsResponse)(nil),               // 209: lightbits.api.duros.v2.ListIdpClientConfsResponse
	(*AuthMapEntry)(nil),                             // 210: lightbits.api.duros.v2.AuthMapEntry
	(*CreateAuthMapEntryRequest)(nil),                // 211: lightbits.api.duros.v2.CreateAuthMapEntryRequest
	(*UpdateAuthMapEntryRequest)(nil),                // 212: lightbits.api.duros.v2.UpdateAuthMapEntryRequest
	(*DeleteAuthMapEntryRequest)(nil),                // 213: lightbits.api.duros.v2.DeleteAuthMapEntryRequest
	(*GetAuthMapEntryRequest)(nil),                   // 214: lightbits.api.duros.v2.GetAuthMapEntryRequest
	(*ListAuthMapEntriesRequest)(nil),                // 215: lightbits.api.duros.v2.ListAuthMapEntriesRequest
	(*DeleteAuthMapEntryResponse)(nil),               // 216: lightbits.api.duros.v2.DeleteAuthMapEntryResponse
	(*ListAuthMapEntriesResponse)(nil),               // 217: lightbits.api.duros.v2.ListAuthMapEntriesResponse
	(*EnableFederatedAuthenticationRequest)(nil),     // 218: lightbits.api.duros.v2.EnableFederatedAuthenticationRequest
	(*EnableFederatedAuthenticationResponse)(nil),    // 219: lightbits.api.duros.v2.EnableFederatedAuthenticationResponse
	(*DisableFederatedAuthenticationRequest)(nil),    // 220: lightbits.api.duros.v2.DisableFederatedAuthenticationRequest
	(*DisableFederatedAuthenticationResponse)(nil),   // 221: lightbits.api.duros.v2.DisableFederatedAuthenticationResponse
	(*GetFederatedAuthenticationStatusResponse)(nil), // 222: lightbits.api.duros.v2.GetFederatedAuthenticationStatusResponse
	nil,                                     // 223: lightbits.api.duros.v2.ListFeatureFlagsResponse.FeatureFlagsEntry
	nil,                                     // 224: lightbits.api.duros.v2.ComponentVolumesInfo.ProjectVolumesMapEntry
	(*QoSRateLimitPolicy_QoSLimitIOPS)(nil), // 225: lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitIOPS
	(*QoSRateLimitPolicy_QoSLimitBW)(nil),   // 226: lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitBW
	(*QoSRateLimitPolicy_QoSLimitIOPSPerGB)(nil), // 227: lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitIOPSPerGB
	(*GetClusterRootKeyResponse_KeyObject)(nil),  // 228: lightbits.api.duros.v2.GetClusterRootKeyResponse.KeyObject
	(*Label)(nil),                            // 229: lightbits.api.duros.v2.Label
	(*durationpb.Duration)(nil),              // 230: google.protobuf.Duration
	(*ProxyInfo)(nil),                        // 231: lightbits.api.duros.v2.ProxyInfo
	(*timestamppb.Timestamp)(nil),            // 232: google.protobuf.Timestamp
	(*NvmeDeviceStatisticsApi)(nil),          // 233: lightbits.api.duros.v2.NvmeDeviceStatisticsApi
	(*NodeStatisticsApi)(nil),                // 234: lightbits.api.duros.v2.NodeStatisticsApi
	(*ClusterStatisticsApi)(nil),             // 235: lightbits.api.duros.v2.ClusterStatisticsApi
	(*VolumeStatisticsApi)(nil),              // 236: lightbits.api.duros.v2.VolumeStatisticsApi
	(*SnapshotStatisticsApi)(nil),            // 237: lightbits.api.duros.v2.SnapshotStatisticsApi
	(*SchedulePolicy)(nil),                   // 238: lightbits.api.duros.v2.SchedulePolicy
	(AuthorizationMode)(0),                   // 239: lightbits.api.duros.v2.AuthorizationMode
	(*EnableClusterInBandAuthRequest)(nil),   // 240: lightbits.api.duros.v2.EnableClusterInBandAuthRequest
	(*DisableClusterInBandAuthRequest)(nil),  // 241: lightbits.api.duros.v2.DisableClusterInBandAuthRequest
	(*CreateTrustedHostRequest)(nil),         // 242: lightbits.api.duros.v2.CreateTrustedHostRequest
	(*DeleteTrustedHostRequest)(nil),         // 243: lightbits.api.duros.v2.DeleteTrustedHostRequest
	(*GetTrustedHostRequest)(nil),            // 244: lightbits.api.duros.v2.GetTrustedHostRequest
	(*ListTrustedHostsRequest)(nil),          // 245: lightbits.api.duros.v2.ListTrustedHostsRequest
	(*UpdateTrustedHostRequest)(nil),         // 246: lightbits.api.duros.v2.UpdateTrustedHostRequest
	(*SetTrustedHostSecretsRequest)(nil),     // 247: lightbits.api.duros.v2.SetTrustedHostSecretsRequest
	(*GetTrustedHostSecretsRequest)(nil),     // 248: lightbits.api.duros.v2.GetTrustedHostSecretsRequest
	(*CFLoginRequest)(nil),                   // 249: lightbits.api.duros.v2.CFLoginRequest
	(*ListClustersRequest)(nil),              // 250: lightbits.api.duros.v2.ListClustersRequest
	(*DetachClusterRequest)(nil),             // 251: lightbits.api.duros.v2.DetachClusterRequest
	(*AttachClusterRequest)(nil),             // 252: lightbits.api.duros.v2.AttachClusterRequest
	(*GetCFServiceCredentialsRequest)(nil),   // 253: lightbits.api.duros.v2.GetCFServiceCredentialsRequest
	(*ListWorkflowsRequest)(nil),             // 254: lightbits.api.duros.v2.ListWorkflowsRequest
	(*GetWorkflowRequest)(nil),               // 255: lightbits.api.duros.v2.GetWorkflowRequest
	(*httpbody.HttpBody)(nil),                // 256: google.api.HttpBody
	(*EnableClusterInBandAuthResponse)(nil),  // 257: lightbits.api.duros.v2.EnableClusterInBandAuthResponse
	(*DisableClusterInBandAuthResponse)(nil), // 258: lightbits.api.duros.v2.DisableClusterInBandAuthResponse
	(*TrustedHost)(nil),                      // 259: lightbits.api.duros.v2.TrustedHost
	(*DeleteTrustedHostResponse)(nil),        // 260: lightbits.api.duros.v2.DeleteTrustedHostResponse
	(*ListTrustedHostsResponse)(nil),         // 261: lightbits.api.duros.v2.ListTrustedHostsResponse
	(*SetTrustedHostSecretsResponse)(nil),    // 262: lightbits.api.duros.v2.SetTrustedHostSecretsResponse
	(*GetTrustedHostSecretsResponse)(nil),    // 263: lightbits.api.duros.v2.GetTrustedHostSecretsResponse
	(*CFLoginResponse)(nil),                  // 264: lightbits.api.duros.v2.CFLoginResponse
	(*ListClustersResponse)(nil),             // 265: lightbits.api.duros.v2.ListClustersResponse
	(*DetachClusterResponse)(nil),            // 266: lightbits.api.duros.v2.DetachClusterResponse
	(*AttachClusterResponse)(nil),            // 267: lightbits.api.duros.v2.AttachClusterResponse
	(*GetCFServiceCredentialsResponse)(nil),  // 268: lightbits.api.duros.v2.GetCFServiceCredentialsResponse
	(*ListWorkflowsResponse)(nil),            // 269: lightbits.api.duros.v2.ListWorkflowsResponse
	(*GetWorkflowResponse)(nil),              // 270: lightbits.api.duros.v2.GetWorkflowResponse
}
var file_lightbits_api_duros_v2_durosapiv2_proto_depIdxs = []int32{
	36,  // 0: lightbits.api.duros.v2.ListAdminEndpointsResponse.adminEndpoints:type_name -> lightbits.api.duros.v2.AdminEndpoint
	0,   // 1: lightbits.api.duros.v2.CreateCredentialRequest.type:type_name -> lightbits.api.duros.v2.CredsType
	0,   // 2: lightbits.api.duros.v2.Credential.type:type_name -> lightbits.api.duros.v2.CredsType
	1,   // 3: lightbits.api.duros.v2.Credential.kind:type_name -> lightbits.api.duros.v2.CredsKind
	45,  // 4: lightbits.api.duros.v2.ListCredentialsResponse.credentials:type_name -> lightbits.api.duros.v2.Credential
	4,   // 5: lightbits.api.duros.v2.DefaultPolicy.policyType:type_name -> lightbits.api.duros.v2.PolicyType
	51,  // 6: lightbits.api.duros.v2.CreateProjectRequest.defaultPolicies:type_name -> lightbits.api.duros.v2.DefaultPolicy
	51,  // 7: lightbits.api.duros.v2.Project.defaultPolicies:type_name -> lightbits.api.duros.v2.DefaultPolicy
	53,  // 8: lightbits.api.duros.v2.ListProjectsResponse.projects:type_name -> lightbits.api.duros.v2.Project
	59,  // 9: lightbits.api.duros.v2.CreateVolumeRequest.acl:type_name -> lightbits.api.duros.v2.StringList
	59,  // 10: lightbits.api.duros.v2.CreateVolumeRequest.IPAcl:type_name -> lightbits.api.duros.v2.StringList
	8,   // 11: lightbits.api.duros.v2.CreateVolumeRequest.sectorSize:type_name -> lightbits.api.duros.v2.CreateVolumeRequest.SectorSizeEnum
	170, // 12: lightbits.api.duros.v2.CreateVolumeRequest.placementRestrictions:type_name -> lightbits.api.duros.v2.LabelMatchExpression
	229, // 13: lightbits.api.duros.v2.CreateVolumeRequest.labels:type_name -> lightbits.api.duros.v2.Label
	230, // 14: lightbits.api.duros.v2.DisableServerRequest.permanentFailureTimeout:type_name -> google.protobuf.Duration
	59,  // 15: lightbits.api.duros.v2.UpdateVolumeRequest.acl:type_name -> lightbits.api.duros.v2.StringList
	59,  // 16: lightbits.api.duros.v2.UpdateVolumeRequest.IPAcl:type_name -> lightbits.api.duros.v2.StringList
	229, // 17: lightbits.api.duros.v2.UpdateVolumeRequest.labels:type_name -> lightbits.api.duros.v2.Label
	231, // 18: lightbits.api.duros.v2.UpgradeServerRequest.ProxyInfo:type_name -> lightbits.api.duros.v2.ProxyInfo
	231, // 19: lightbits.api.duros.v2.UpgradeClusterRequest.ProxyInfo:type_name -> lightbits.api.duros.v2.ProxyInfo
	9,   // 20: lightbits.api.duros.v2.EnableClusterEncryptionRequest.keyStore:type_name -> lightbits.api.duros.v2.EnableClusterEncryptionRequest.KeyStore
	88,  // 21: lightbits.api.duros.v2.ListHostsResponse.connectedHosts:type_name -> lightbits.api.duros.v2.ConnectedHost
	182, // 22: lightbits.api.duros.v2.ListEventsResponse.events:type_name -> lightbits.api.duros.v2.Event
	11,  // 23: lightbits.api.duros.v2.ListNvmeDevicesRequest.deviceUsages:type_name -> lightbits.api.duros.v2.UserNvmeDevicesResponse.DeviceUsageEnum
	89,  // 24: lightbits.api.duros.v2.ListNvmeDevicesResponse.NvmeDevices:type_name -> lightbits.api.duros.v2.UserNvmeDevicesResponse
	10,  // 25: lightbits.api.duros.v2.UserNvmeDevicesResponse.state:type_name -> lightbits.api.duros.v2.UserNvmeDevicesResponse.StateEnum
	232, // 26: lightbits.api.duros.v2.UserNvmeDevicesResponse.failureTime:type_name -> google.protobuf.Timestamp
	232, // 27: lightbits.api.duros.v2.UserNvmeDevicesResponse.rebuildCompletionTime:type_name -> google.protobuf.Timestamp
	233, // 28: lightbits.api.duros.v2.UserNvmeDevicesResponse.statistics:type_name -> lightbits.api.duros.v2.NvmeDeviceStatisticsApi
	11,  // 29: lightbits.api.duros.v2.UserNvmeDevicesResponse.deviceUsage:type_name -> lightbits.api.duros.v2.UserNvmeDevicesResponse.DeviceUsageEnum
	12,  // 30: lightbits.api.duros.v2.DurosNodeInfo.state:type_name -> lightbits.api.duros.v2.DurosNodeInfo.State
	13,  // 31: lightbits.api.duros.v2.DurosNodeInfo.status:type_name -> lightbits.api.duros.v2.DurosNodeInfo.StatusEnum
	234, // 32: lightbits.api.duros.v2.DurosNodeInfo.statistics:type_name -> lightbits.api.duros.v2.NodeStatisticsApi
	92,  // 33: lightbits.api.duros.v2.DurosNodeInfo.journalNvmeDevice:type_name -> lightbits.api.duros.v2.JournalNvmeDevice
	91,  // 34: lightbits.api.duros.v2.DurosNodeInfo.journalRaidDevice:type_name -> lightbits.api.duros.v2.JournalRaidDevice
	90,  // 35: lightbits.api.duros.v2.ListNodesResponse.nodes:type_name -> lightbits.api.duros.v2.DurosNodeInfo
	120, // 36: lightbits.api.duros.v2.ListVolumesResponse.volumes:type_name -> lightbits.api.duros.v2.Volume
	22,  // 37: lightbits.api.duros.v2.ListServersRequest.RiskOfServiceLoss:type_name -> lightbits.api.duros.v2.Server.RiskOfServiceLossEnum
	123, // 38: lightbits.api.duros.v2.ListServersResponse.servers:type_name -> lightbits.api.duros.v2.Server
	117, // 39: lightbits.api.duros.v2.ClusterUpgradeStatusResponse.cluster:type_name -> lightbits.api.duros.v2.ClusterInfo
	123, // 40: lightbits.api.duros.v2.ListUpgradeStatusResponse.servers:type_name -> lightbits.api.duros.v2.Server
	14,  // 41: lightbits.api.duros.v2.ClusterLastUpgrade.Status:type_name -> lightbits.api.duros.v2.ClusterLastUpgrade.UpgradeStatusEnum
	232, // 42: lightbits.api.duros.v2.ClusterLastUpgrade.StartTime:type_name -> google.protobuf.Timestamp
	232, // 43: lightbits.api.duros.v2.ClusterLastUpgrade.EndTime:type_name -> google.protobuf.Timestamp
	235, // 44: lightbits.api.duros.v2.ClusterInfo.statistics:type_name -> lightbits.api.duros.v2.ClusterStatisticsApi
	119, // 45: lightbits.api.duros.v2.ClusterInfo.health:type_name -> lightbits.api.duros.v2.ClusterHealth
	116, // 46: lightbits.api.duros.v2.ClusterInfo.lastUpgrade:type_name -> lightbits.api.duros.v2.ClusterLastUpgrade
	15,  // 47: lightbits.api.duros.v2.ClusterInfo.inBandAuthMode:type_name -> lightbits.api.duros.v2.ClusterInfo.AuthenticationMode
	187, // 48: lightbits.api.duros.v2.ClusterInfo.encryptionStatus:type_name -> lightbits.api.duros.v2.ClusterEncryptionStatus
	189, // 49: lightbits.api.duros.v2.ClusterInfo.federatedAuthenticationStatus:type_name -> lightbits.api.duros.v2.FederatedAuthenticationStatus
	116, // 50: lightbits.api.duros.v2.ClusterInfoV2.lastUpgrade:type_name -> lightbits.api.duros.v2.ClusterLastUpgrade
	187, // 51: lightbits.api.duros.v2.ClusterInfoV2.encryptionStatus:type_name -> lightbits.api.duros.v2.ClusterEncryptionStatus
	15,  // 52: lightbits.api.duros.v2.ClusterInfoV2.inBandAuthMode:type_name -> lightbits.api.duros.v2.ClusterInfo.AuthenticationMode
	16,  // 53: lightbits.api.duros.v2.ClusterHealth.state:type_name -> lightbits.api.duros.v2.ClusterHealth.State
	17,  // 54: lightbits.api.duros.v2.Volume.state:type_name -> lightbits.api.duros.v2.Volume.StateEnum
	2,   // 55: lightbits.api.duros.v2.Volume.protectionState:type_name -> lightbits.api.duros.v2.ProtectionStateEnum
	59,  // 56: lightbits.api.duros.v2.Volume.acl:type_name -> lightbits.api.duros.v2.StringList
	236, // 57: lightbits.api.duros.v2.Volume.statistics:type_name -> lightbits.api.duros.v2.VolumeStatisticsApi
	59,  // 58: lightbits.api.duros.v2.Volume.IPAcl:type_name -> lightbits.api.duros.v2.StringList
	170, // 59: lightbits.api.duros.v2.Volume.placementRestrictions:type_name -> lightbits.api.duros.v2.LabelMatchExpression
	232, // 60: lightbits.api.duros.v2.Volume.creationTime:type_name -> google.protobuf.Timestamp
	229, // 61: lightbits.api.duros.v2.Volume.labels:type_name -> lightbits.api.duros.v2.Label
	19,  // 62: lightbits.api.duros.v2.ServerEvictionStatus.status:type_name -> lightbits.api.duros.v2.ServerEvictionStatus.StatusEnum
	232, // 63: lightbits.api.duros.v2.ServerEvictionStatus.startTime:type_name -> google.protobuf.Timestamp
	232, // 64: lightbits.api.duros.v2.ServerEvictionStatus.endTime:type_name -> google.protobuf.Timestamp
	20,  // 65: lightbits.api.duros.v2.ServerLastUpgrade.Status:type_name -> lightbits.api.duros.v2.ServerLastUpgrade.UpgradeStatusEnum
	232, // 66: lightbits.api.duros.v2.ServerLastUpgrade.StartTime:type_name -> google.protobuf.Timestamp
	232, // 67: lightbits.api.duros.v2.ServerLastUpgrade.EndTime:type_name -> google.protobuf.Timestamp
	22,  // 68: lightbits.api.duros.v2.Server.RiskOfServiceLossState:type_name -> lightbits.api.duros.v2.Server.RiskOfServiceLossEnum
	23,  // 69: lightbits.api.duros.v2.Server.state:type_name -> lightbits.api.duros.v2.Server.ServerStateEnum
	21,  // 70: lightbits.api.duros.v2.Server.UpgradeStatus:type_name -> lightbits.api.duros.v2.Server.UpgradeStatusEnum
	122, // 71: lightbits.api.duros.v2.Server.LastUpgrade:type_name -> lightbits.api.duros.v2.ServerLastUpgrade
	121, // 72: lightbits.api.duros.v2.Server.LastEviction:type_name -> lightbits.api.duros.v2.ServerEvictionStatus
	16,  // 73: lightbits.api.duros.v2.Server.health:type_name -> lightbits.api.duros.v2.ClusterHealth.State
	230, // 74: lightbits.api.duros.v2.Server.ServerPermanenetFailureTimeout:type_name -> google.protobuf.Duration
	126, // 75: lightbits.api.duros.v2.GetRoleResponse.role:type_name -> lightbits.api.duros.v2.Role
	126, // 76: lightbits.api.duros.v2.ListRolesResponse.roles:type_name -> lightbits.api.duros.v2.Role
	24,  // 77: lightbits.api.duros.v2.Snapshot.state:type_name -> lightbits.api.duros.v2.Snapshot.StateEnum
	232, // 78: lightbits.api.duros.v2.Snapshot.creationTime:type_name -> google.protobuf.Timestamp
	230, // 79: lightbits.api.duros.v2.Snapshot.retentionTime:type_name -> google.protobuf.Duration
	59,  // 80: lightbits.api.duros.v2.Snapshot.acl:type_name -> lightbits.api.duros.v2.StringList
	59,  // 81: lightbits.api.duros.v2.Snapshot.IPAcl:type_name -> lightbits.api.duros.v2.StringList
	237, // 82: lightbits.api.duros.v2.Snapshot.statistics:type_name -> lightbits.api.duros.v2.SnapshotStatisticsApi
	229, // 83: lightbits.api.duros.v2.Snapshot.labels:type_name -> lightbits.api.duros.v2.Label
	230, // 84: lightbits.api.duros.v2.CreateSnapshotRequest.retentionTime:type_name -> google.protobuf.Duration
	129, // 85: lightbits.api.duros.v2.ListSnapshotsResponse.snapshots:type_name -> lightbits.api.duros.v2.Snapshot
	223, // 86: lightbits.api.duros.v2.ListFeatureFlagsResponse.featureFlags:type_name -> lightbits.api.duros.v2.ListFeatureFlagsResponse.FeatureFlagsEntry
	238, // 87: lightbits.api.duros.v2.CreateResourcePolicyRequest.schedulePolicy:type_name -> lightbits.api.duros.v2.SchedulePolicy
	183, // 88: lightbits.api.duros.v2.CreatePolicyRequest.qoSRateLimitPolicy:type_name -> lightbits.api.duros.v2.QoSRateLimitPolicy
	183, // 89: lightbits.api.duros.v2.UpdatePolicyRequest.qoSRateLimitPolicy:type_name -> lightbits.api.duros.v2.QoSRateLimitPolicy
	238, // 90: lightbits.api.duros.v2.ResourcePolicy.schedulePolicy:type_name -> lightbits.api.duros.v2.SchedulePolicy
	25,  // 91: lightbits.api.duros.v2.ResourcePolicy.state:type_name -> lightbits.api.duros.v2.ResourcePolicy.State
	26,  // 92: lightbits.api.duros.v2.Policy.state:type_name -> lightbits.api.duros.v2.Policy.State
	183, // 93: lightbits.api.duros.v2.Policy.QoSRateLimitPolicy:type_name -> lightbits.api.duros.v2.QoSRateLimitPolicy
	238, // 94: lightbits.api.duros.v2.UpdateResourcePolicyRequest.schedulePolicy:type_name -> lightbits.api.duros.v2.SchedulePolicy
	148, // 95: lightbits.api.duros.v2.ListPoliciesResponse.policies:type_name -> lightbits.api.duros.v2.Policy
	147, // 96: lightbits.api.duros.v2.ListResourcePoliciesResponse.resourcePolicies:type_name -> lightbits.api.duros.v2.ResourcePolicy
	184, // 97: lightbits.api.duros.v2.ListResourcePoliciesResponse.defaultResourcePolicies:type_name -> lightbits.api.duros.v2.DefaultGlobalResourcePolicy
	162, // 98: lightbits.api.duros.v2.UpdateClusterConfigParamRequest.configParam:type_name -> lightbits.api.duros.v2.ClusterConfigParam
	162, // 99: lightbits.api.duros.v2.ListClusterConfigParamsResponse.values:type_name -> lightbits.api.duros.v2.ClusterConfigParam
	27,  // 100: lightbits.api.duros.v2.LabelValueKeyPair.key:type_name -> lightbits.api.duros.v2.LabelValueKeyPair.Key
	28,  // 101: lightbits.api.duros.v2.LabelMatchExpression.operator:type_name -> lightbits.api.duros.v2.LabelMatchExpression.Operator
	169, // 102: lightbits.api.duros.v2.LabelMatchExpression.labelValueKeyPairs:type_name -> lightbits.api.duros.v2.LabelValueKeyPair
	171, // 103: lightbits.api.duros.v2.VolumeComponentInfoList.VolumeComponentInfoList:type_name -> lightbits.api.duros.v2.ComponentVolumeInfo
	224, // 104: lightbits.api.duros.v2.ComponentVolumesInfo.ProjectVolumesMap:type_name -> lightbits.api.duros.v2.ComponentVolumesInfo.ProjectVolumesMapEntry
	179, // 105: lightbits.api.duros.v2.ListChangedBlocksResponse.lbaRanges:type_name -> lightbits.api.duros.v2.LBARange
	232, // 106: lightbits.api.duros.v2.Event.Time:type_name -> google.protobuf.Timestamp
	29,  // 107: lightbits.api.duros.v2.Event.Type:type_name -> lightbits.api.duros.v2.Event.EventType
	31,  // 108: lightbits.api.duros.v2.Event.Severity:type_name -> lightbits.api.duros.v2.Event.EventSeverity
	30,  // 109: lightbits.api.duros.v2.Event.ReportingService:type_name -> lightbits.api.duros.v2.Event.EventReportingService
	173, // 110: lightbits.api.duros.v2.Event.ComponentVolumesInfo:type_name -> lightbits.api.duros.v2.ComponentVolumesInfo
	176, // 111: lightbits.api.duros.v2.Event.ComponentNVMeSSDInfo:type_name -> lightbits.api.duros.v2.ComponentNVMeSSDInfo
	174, // 112: lightbits.api.duros.v2.Event.ComponentNodeInfo:type_name -> lightbits.api.duros.v2.ComponentNodeInfo
	177, // 113: lightbits.api.duros.v2.Event.ComponentServerInfo:type_name -> lightbits.api.duros.v2.ComponentServerInfo
	175, // 114: lightbits.api.duros.v2.Event.ComponentClusterInfo:type_name -> lightbits.api.duros.v2.ComponentClusterInfo
	178, // 115: lightbits.api.duros.v2.Event.ComponentDataIntegrityInfo:type_name -> lightbits.api.duros.v2.ComponentDataIntegrityInfo
	3,   // 116: lightbits.api.duros.v2.QoSRateLimitPolicy.policyVisibility:type_name -> lightbits.api.duros.v2.PolicyVisibility
	225, // 117: lightbits.api.duros.v2.QoSRateLimitPolicy.limitIOPS:type_name -> lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitIOPS
	226, // 118: lightbits.api.duros.v2.QoSRateLimitPolicy.limitBw:type_name -> lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitBW
	227, // 119: lightbits.api.duros.v2.QoSRateLimitPolicy.limitIOPSPerGB:type_name -> lightbits.api.duros.v2.QoSRateLimitPolicy.QoSLimitIOPSPerGB
	4,   // 120: lightbits.api.duros.v2.DefaultGlobalResourcePolicy.policyType:type_name -> lightbits.api.duros.v2.PolicyType
	51,  // 121: lightbits.api.duros.v2.UpdateProjectRequest.defaultPolicies:type_name -> lightbits.api.duros.v2.DefaultPolicy
	32,  // 122: lightbits.api.duros.v2.ClusterEncryptionStatus.encryptionState:type_name -> lightbits.api.duros.v2.ClusterEncryptionStatus.State
	232, // 123: lightbits.api.duros.v2.ClusterEncryptionStatus.kekUpdateDate:type_name -> google.protobuf.Timestamp
	33,  // 124: lightbits.api.duros.v2.ClusterEncryptionStatus.rotationState:type_name -> lightbits.api.duros.v2.ClusterEncryptionStatus.RotationState
	5,   // 125: lightbits.api.duros.v2.IdpHealthInfo.idpHealthStatus:type_name -> lightbits.api.duros.v2.IdpHealthStatus
	232, // 126: lightbits.api.duros.v2.IdpHealthInfo.timestamp:type_name -> google.protobuf.Timestamp
	188, // 127: lightbits.api.duros.v2.FederatedAuthenticationStatus.idpHealthInfos:type_name -> lightbits.api.duros.v2.IdpHealthInfo
	228, // 128: lightbits.api.duros.v2.GetClusterRootKeyResponse.key:type_name -> lightbits.api.duros.v2.GetClusterRootKeyResponse.KeyObject
	34,  // 129: lightbits.api.duros.v2.IDPConfiguration.state:type_name -> lightbits.api.duros.v2.IDPConfiguration.IDPConfigurationState
	6,   // 130: lightbits.api.duros.v2.IDPConfiguration.type:type_name -> lightbits.api.duros.v2.IDPType
	231, // 131: lightbits.api.duros.v2.IDPConfiguration.proxyInfo:type_name -> lightbits.api.duros.v2.ProxyInfo
	6,   // 132: lightbits.api.duros.v2.CreateIDPConfigurationRequest.type:type_name -> lightbits.api.duros.v2.IDPType
	231, // 133: lightbits.api.duros.v2.CreateIDPConfigurationRequest.proxyInfo:type_name -> lightbits.api.duros.v2.ProxyInfo
	6,   // 134: lightbits.api.duros.v2.UpdateIDPConfigurationRequest.type:type_name -> lightbits.api.duros.v2.IDPType
	231, // 135: lightbits.api.duros.v2.UpdateIDPConfigurationRequest.proxyInfo:type_name -> lightbits.api.duros.v2.ProxyInfo
	194, // 136: lightbits.api.duros.v2.ListIDPConfigurationsResponse.idpConfigurations:type_name -> lightbits.api.duros.v2.IDPConfiguration
	239, // 137: lightbits.api.duros.v2.IdpClientConf.authzMode:type_name -> lightbits.api.duros.v2.AuthorizationMode
	239, // 138: lightbits.api.duros.v2.CreateIdpClientConfRequest.authzMode:type_name -> lightbits.api.duros.v2.AuthorizationMode
	202, // 139: lightbits.api.duros.v2.ListIdpClientConfsResponse.idpClientConfigurations:type_name -> lightbits.api.duros.v2.IdpClientConf
	210, // 140: lightbits.api.duros.v2.ListAuthMapEntriesResponse.authMapEntries:type_name -> lightbits.api.duros.v2.AuthMapEntry
	7,   // 141: lightbits.api.duros.v2.GetFederatedAuthenticationStatusResponse.federatedAuthenticationState:type_name -> lightbits.api.duros.v2.fedAuthState
	136, // 142: lightbits.api.duros.v2.ListFeatureFlagsResponse.FeatureFlagsEntry.value:type_name -> lightbits.api.duros.v2.FeatureFlagStatus
	172, // 143: lightbits.api.duros.v2.ComponentVolumesInfo.ProjectVolumesMapEntry.value:type_name -> lightbits.api.duros.v2.VolumeComponentInfoList
	60,  // 144: lightbits.api.duros.v2.DurosAPI.GetVersion:input_type -> lightbits.api.duros.v2.GetVersionRequest
	61,  // 145: lightbits.api.duros.v2.DurosAPI.CreateVolume:input_type -> lightbits.api.duros.v2.CreateVolumeRequest
	62,  // 146: lightbits.api.duros.v2.DurosAPI.DeleteVolume:input_type -> lightbits.api.duros.v2.DeleteVolumeRequest
	84,  // 147: lightbits.api.duros.v2.DurosAPI.ListVolumes:input_type -> lightbits.api.duros.v2.ListVolumeRequest
	80,  // 148: lightbits.api.duros.v2.DurosAPI.ListEvents:input_type -> lightbits.api.duros.v2.ListEventsRequest
	76,  // 149: lightbits.api.duros.v2.DurosAPI.GetHost:input_type -> lightbits.api.duros.v2.GetHostRequest
	77,  // 150: lightbits.api.duros.v2.DurosAPI.ListHosts:input_type -> lightbits.api.duros.v2.ListHostsRequest
	82,  // 151: lightbits.api.duros.v2.DurosAPI.GetVolume:input_type -> lightbits.api.duros.v2.GetVolumeRequest
	79,  // 152: lightbits.api.duros.v2.DurosAPI.ListNodes:input_type -> lightbits.api.duros.v2.ListNodeRequest
	83,  // 153: lightbits.api.duros.v2.DurosAPI.GetNode:input_type -> lightbits.api.duros.v2.GetNodeRequest
	85,  // 154: lightbits.api.duros.v2.DurosAPI.ListNvmeDevices:input_type -> lightbits.api.duros.v2.ListNvmeDevicesRequest
	86,  // 155: lightbits.api.duros.v2.DurosAPI.GetNvmeDevice:input_type -> lightbits.api.duros.v2.GetNvmeDeviceRequest
	35,  // 156: lightbits.api.duros.v2.DurosAPI.FetchLogs:input_type -> lightbits.api.duros.v2.LogRequest
	73,  // 157: lightbits.api.duros.v2.DurosAPI.GetCluster:input_type -> lightbits.api.duros.v2.GetClusterRequest
	73,  // 158: lightbits.api.duros.v2.DurosAPI.GetClusterInfo:input_type -> lightbits.api.duros.v2.GetClusterRequest
	74,  // 159: lightbits.api.duros.v2.DurosAPI.UpdateNvmeDevice:input_type -> lightbits.api.duros.v2.UpdateNvmeDeviceRequest
	75,  // 160: lightbits.api.duros.v2.DurosAPI.AddNvmeDevice:input_type -> lightbits.api.duros.v2.AddNvmeDeviceRequest
	69,  // 161: lightbits.api.duros.v2.DurosAPI.UpdateVolume:input_type -> lightbits.api.duros.v2.UpdateVolumeRequest
	111, // 162: lightbits.api.duros.v2.DurosAPI.GetServer:input_type -> lightbits.api.duros.v2.GetServerRequest
	110, // 163: lightbits.api.duros.v2.DurosAPI.ListServers:input_type -> lightbits.api.duros.v2.ListServersRequest
	70,  // 164: lightbits.api.duros.v2.DurosAPI.UpgradeServer:input_type -> lightbits.api.duros.v2.UpgradeServerRequest
	71,  // 165: lightbits.api.duros.v2.DurosAPI.UpgradeCluster:input_type -> lightbits.api.duros.v2.UpgradeClusterRequest
	72,  // 166: lightbits.api.duros.v2.DurosAPI.EnableClusterEncryption:input_type -> lightbits.api.duros.v2.EnableClusterEncryptionRequest
	68,  // 167: lightbits.api.duros.v2.DurosAPI.CreateServer:input_type -> lightbits.api.duros.v2.CreateServerRequest
	67,  // 168: lightbits.api.duros.v2.DurosAPI.ReplaceNode:input_type -> lightbits.api.duros.v2.ReplaceNodeRequest
	66,  // 169: lightbits.api.duros.v2.DurosAPI.DeleteServer:input_type -> lightbits.api.duros.v2.DeleteServerRequest
	64,  // 170: lightbits.api.duros.v2.DurosAPI.EnableServer:input_type -> lightbits.api.duros.v2.EnableServerRequest
	65,  // 171: lightbits.api.duros.v2.DurosAPI.DisableServer:input_type -> lightbits.api.duros.v2.DisableServerRequest
	104, // 172: lightbits.api.duros.v2.DurosAPI.StartNodeInstance:input_type -> lightbits.api.duros.v2.StartNodeInstanceRequest
	106, // 173: lightbits.api.duros.v2.DurosAPI.StopNodeInstance:input_type -> lightbits.api.duros.v2.StopNodeInstanceRequest
	108, // 174: lightbits.api.duros.v2.DurosAPI.RestartNodeInstance:input_type -> lightbits.api.duros.v2.RestartNodeInstanceRequest
	52,  // 175: lightbits.api.duros.v2.DurosAPI.CreateProject:input_type -> lightbits.api.duros.v2.CreateProjectRequest
	185, // 176: lightbits.api.duros.v2.DurosAPI.UpdateProject:input_type -> lightbits.api.duros.v2.UpdateProjectRequest
	54,  // 177: lightbits.api.duros.v2.DurosAPI.DeleteProject:input_type -> lightbits.api.duros.v2.DeleteProjectRequest
	56,  // 178: lightbits.api.duros.v2.DurosAPI.ListProjects:input_type -> lightbits.api.duros.v2.ListProjectsRequest
	58,  // 179: lightbits.api.duros.v2.DurosAPI.GetProject:input_type -> lightbits.api.duros.v2.GetProjectRequest
	44,  // 180: lightbits.api.duros.v2.DurosAPI.CreateCredential:input_type -> lightbits.api.duros.v2.CreateCredentialRequest
	46,  // 181: lightbits.api.duros.v2.DurosAPI.DeleteCredential:input_type -> lightbits.api.duros.v2.DeleteCredentialRequest
	48,  // 182: lightbits.api.duros.v2.DurosAPI.ListCredentials:input_type -> lightbits.api.duros.v2.ListCredentialsRequest
	50,  // 183: lightbits.api.duros.v2.DurosAPI.GetCredential:input_type -> lightbits.api.duros.v2.GetCredentialRequest
	124, // 184: lightbits.api.duros.v2.DurosAPI.GetRole:input_type -> lightbits.api.duros.v2.GetRoleRequest
	127, // 185: lightbits.api.duros.v2.DurosAPI.ListRoles:input_type -> lightbits.api.duros.v2.ListRolesRequest
	40,  // 186: lightbits.api.duros.v2.DurosAPI.CreateAdminEndpoint:input_type -> lightbits.api.duros.v2.CreateAdminEndpointRequest
	42,  // 187: lightbits.api.duros.v2.DurosAPI.DeleteAdminEndpoint:input_type -> lightbits.api.duros.v2.DeleteAdminEndpointRequest
	39,  // 188: lightbits.api.duros.v2.DurosAPI.ListAdminEndpoints:input_type -> lightbits.api.duros.v2.ListAdminEndpointsRequest
	41,  // 189: lightbits.api.duros.v2.DurosAPI.UpdateAdminEndpoint:input_type -> lightbits.api.duros.v2.UpdateAdminEndpointRequest
	37,  // 190: lightbits.api.duros.v2.DurosAPI.GetAdminEndpoint:input_type -> lightbits.api.duros.v2.GetAdminEndpointRequest
	143, // 191: lightbits.api.duros.v2.DurosAPI.CreateResourcePolicy:input_type -> lightbits.api.duros.v2.CreateResourcePolicyRequest
	144, // 192: lightbits.api.duros.v2.DurosAPI.CreatePolicy:input_type -> lightbits.api.duros.v2.CreatePolicyRequest
	145, // 193: lightbits.api.duros.v2.DurosAPI.UpdatePolicy:input_type -> lightbits.api.duros.v2.UpdatePolicyRequest
	149, // 194: lightbits.api.duros.v2.DurosAPI.UpdateResourcePolicy:input_type -> lightbits.api.duros.v2.UpdateResourcePolicyRequest
	155, // 195: lightbits.api.duros.v2.DurosAPI.GetPolicy:input_type -> lightbits.api.duros.v2.GetPolicyRequest
	151, // 196: lightbits.api.duros.v2.DurosAPI.ListPolicies:input_type -> lightbits.api.duros.v2.ListPoliciesRequest
	153, // 197: lightbits.api.duros.v2.DurosAPI.ListResourcePolicies:input_type -> lightbits.api.duros.v2.ListResourcePoliciesRequest
	156, // 198: lightbits.api.duros.v2.DurosAPI.GetResourcePolicy:input_type -> lightbits.api.duros.v2.GetResourcePolicyRequest
	157, // 199: lightbits.api.duros.v2.DurosAPI.DeleteResourcePolicy:input_type -> lightbits.api.duros.v2.DeleteResourcePolicyRequest
	159, // 200: lightbits.api.duros.v2.DurosAPI.DeletePolicy:input_type -> lightbits.api.duros.v2.DeletePolicyRequest
	131, // 201: lightbits.api.duros.v2.DurosAPI.CreateSnapshot:input_type -> lightbits.api.duros.v2.CreateSnapshotRequest
	133, // 202: lightbits.api.duros.v2.DurosAPI.GetSnapshot:input_type -> lightbits.api.duros.v2.GetSnapshotRequest
	132, // 203: lightbits.api.duros.v2.DurosAPI.ListSnapshots:input_type -> lightbits.api.duros.v2.ListSnapshotsRequest
	130, // 204: lightbits.api.duros.v2.DurosAPI.DeleteSnapshot:input_type -> lightbits.api.duros.v2.DeleteSnapshotRequest
	137, // 205: lightbits.api.duros.v2.DurosAPI.GetFeatureFlag:input_type -> lightbits.api.duros.v2.GetFeatureFlagRequest
	138, // 206: lightbits.api.duros.v2.DurosAPI.EnableFeatureFlag:input_type -> lightbits.api.duros.v2.EnableFeatureFlagRequest
	139, // 207: lightbits.api.duros.v2.DurosAPI.DisableFeatureFlag:input_type -> lightbits.api.duros.v2.DisableFeatureFlagRequest
	141, // 208: lightbits.api.duros.v2.DurosAPI.ListFeatureFlags:input_type -> lightbits.api.duros.v2.ListFeatureFlagsRequest
	161, // 209: lightbits.api.duros.v2.DurosAPI.GetClusterConfigParam:input_type -> lightbits.api.duros.v2.GetClusterConfigParamRequest
	163, // 210: lightbits.api.duros.v2.DurosAPI.UpdateClusterConfigParam:input_type -> lightbits.api.duros.v2.UpdateClusterConfigParamRequest
	167, // 211: lightbits.api.duros.v2.DurosAPI.ListClusterConfigParams:input_type -> lightbits.api.duros.v2.ListClusterConfigParamsRequest
	164, // 212: lightbits.api.duros.v2.DurosAPI.RollbackVolume:input_type -> lightbits.api.duros.v2.RollbackVolumeRequest
	180, // 213: lightbits.api.duros.v2.DurosAPI.ListChangedBlocks:input_type -> lightbits.api.duros.v2.ListChangedBlocksRequest
	190, // 214: lightbits.api.duros.v2.DurosAPI.RotateClusterRootKey:input_type -> lightbits.api.duros.v2.RotateClusterRootKeyRequest
	192, // 215: lightbits.api.duros.v2.DurosAPI.GetClusterRootKey:input_type -> lightbits.api.duros.v2.GetClusterRootKeyRequest
	195, // 216: lightbits.api.duros.v2.DurosAPI.CreateIdpConfiguration:input_type -> lightbits.api.duros.v2.CreateIDPConfigurationRequest
	200, // 217: lightbits.api.duros.v2.DurosAPI.DeleteIdpConfiguration:input_type -> lightbits.api.duros.v2.DeleteIDPConfigurationRequest
	196, // 218: lightbits.api.duros.v2.DurosAPI.UpdateIdpConfiguration:input_type -> lightbits.api.duros.v2.UpdateIDPConfigurationRequest
	197, // 219: lightbits.api.duros.v2.DurosAPI.ListIdpConfigurations:input_type -> lightbits.api.duros.v2.ListIDPConfigurationsRequest
	199, // 220: lightbits.api.duros.v2.DurosAPI.GetIdpConfiguration:input_type -> lightbits.api.duros.v2.GetIDPConfigurationRequest
	203, // 221: lightbits.api.duros.v2.DurosAPI.CreateIdpClientConf:input_type -> lightbits.api.duros.v2.CreateIdpClientConfRequest
	206, // 222: lightbits.api.duros.v2.DurosAPI.DeleteIdpClientConf:input_type -> lightbits.api.duros.v2.DeleteIdpClientConfRequest
	204, // 223: lightbits.api.duros.v2.DurosAPI.UpdateIdpClientConf:input_type -> lightbits.api.duros.v2.UpdateIdpClientConfRequest
	208, // 224: lightbits.api.duros.v2.DurosAPI.ListIdpClientConfs:input_type -> lightbits.api.duros.v2.ListIdpClientConfsRequest
	205, // 225: lightbits.api.duros.v2.DurosAPI.GetIdpClientConf:input_type -> lightbits.api.duros.v2.GetIdpClientConfRequest
	211, // 226: lightbits.api.duros.v2.DurosAPI.CreateAuthMapEntry:input_type -> lightbits.api.duros.v2.CreateAuthMapEntryRequest
	212, // 227: lightbits.api.duros.v2.DurosAPI.UpdateAuthMapEntry:input_type -> lightbits.api.duros.v2.UpdateAuthMapEntryRequest
	213, // 228: lightbits.api.duros.v2.DurosAPI.DeleteAuthMapEntry:input_type -> lightbits.api.duros.v2.DeleteAuthMapEntryRequest
	214, // 229: lightbits.api.duros.v2.DurosAPI.GetAuthMapEntry:input_type -> lightbits.api.duros.v2.GetAuthMapEntryRequest
	215, // 230: lightbits.api.duros.v2.DurosAPI.ListAuthMapEntries:input_type -> lightbits.api.duros.v2.ListAuthMapEntriesRequest
	240, // 231: lightbits.api.duros.v2.DurosAPI.EnableClusterInBandAuth:input_type -> lightbits.api.duros.v2.EnableClusterInBandAuthRequest
	241, // 232: lightbits.api.duros.v2.DurosAPI.DisableClusterInBandAuth:input_type -> lightbits.api.duros.v2.DisableClusterInBandAuthRequest
	242, // 233: lightbits.api.duros.v2.DurosAPI.CreateTrustedHost:input_type -> lightbits.api.duros.v2.CreateTrustedHostRequest
	243, // 234: lightbits.api.duros.v2.DurosAPI.DeleteTrustedHost:input_type -> lightbits.api.duros.v2.DeleteTrustedHostRequest
	244, // 235: lightbits.api.duros.v2.DurosAPI.GetTrustedHost:input_type -> lightbits.api.duros.v2.GetTrustedHostRequest
	245, // 236: lightbits.api.duros.v2.DurosAPI.ListTrustedHosts:input_type -> lightbits.api.duros.v2.ListTrustedHostsRequest
	246, // 237: lightbits.api.duros.v2.DurosAPI.UpdateTrustedHost:input_type -> lightbits.api.duros.v2.UpdateTrustedHostRequest
	247, // 238: lightbits.api.duros.v2.DurosAPI.SetTrustedHostSecret:input_type -> lightbits.api.duros.v2.SetTrustedHostSecretsRequest
	248, // 239: lightbits.api.duros.v2.DurosAPI.GetTrustedHostSecret:input_type -> lightbits.api.duros.v2.GetTrustedHostSecretsRequest
	218, // 240: lightbits.api.duros.v2.DurosAPI.EnableFederatedAuthentication:input_type -> lightbits.api.duros.v2.EnableFederatedAuthenticationRequest
	220, // 241: lightbits.api.duros.v2.DurosAPI.DisableFederatedAuthentication:input_type -> lightbits.api.duros.v2.DisableFederatedAuthenticationRequest
	249, // 242: lightbits.api.duros.v2.DurosAPI.CFLogin:input_type -> lightbits.api.duros.v2.CFLoginRequest
	250, // 243: lightbits.api.duros.v2.DurosAPI.ListClusters:input_type -> lightbits.api.duros.v2.ListClustersRequest
	251, // 244: lightbits.api.duros.v2.DurosAPI.DetachCluster:input_type -> lightbits.api.duros.v2.DetachClusterRequest
	252, // 245: lightbits.api.duros.v2.DurosAPI.AttachCluster:input_type -> lightbits.api.duros.v2.AttachClusterRequest
	253, // 246: lightbits.api.duros.v2.DurosAPI.GetCFServiceCredentials:input_type -> lightbits.api.duros.v2.GetCFServiceCredentialsRequest
	254, // 247: lightbits.api.duros.v2.DurosAPI.ListWorkflows:input_type -> lightbits.api.duros.v2.ListWorkflowsRequest
	255, // 248: lightbits.api.duros.v2.DurosAPI.GetWorkflow:input_type -> lightbits.api.duros.v2.GetWorkflowRequest
	115, // 249: lightbits.api.duros.v2.DurosAPI.GetVersion:output_type -> lightbits.api.duros.v2.Version
	120, // 250: lightbits.api.duros.v2.DurosAPI.CreateVolume:output_type -> lightbits.api.duros.v2.Volume
	63,  // 251: lightbits.api.duros.v2.DurosAPI.DeleteVolume:output_type -> lightbits.api.duros.v2.DeleteVolumeResponse
	94,  // 252: lightbits.api.duros.v2.DurosAPI.ListVolumes:output_type -> lightbits.api.duros.v2.ListVolumesResponse
	81,  // 253: lightbits.api.duros.v2.DurosAPI.ListEvents:output_type -> lightbits.api.duros.v2.ListEventsResponse
	88,  // 254: lightbits.api.duros.v2.DurosAPI.GetHost:output_type -> lightbits.api.duros.v2.ConnectedHost
	78,  // 255: lightbits.api.duros.v2.DurosAPI.ListHosts:output_type -> lightbits.api.duros.v2.ListHostsResponse
	120, // 256: lightbits.api.duros.v2.DurosAPI.GetVolume:output_type -> lightbits.api.duros.v2.Volume
	93,  // 257: lightbits.api.duros.v2.DurosAPI.ListNodes:output_type -> lightbits.api.duros.v2.ListNodesResponse
	90,  // 258: lightbits.api.duros.v2.DurosAPI.GetNode:output_type -> lightbits.api.duros.v2.DurosNodeInfo
	87,  // 259: lightbits.api.duros.v2.DurosAPI.ListNvmeDevices:output_type -> lightbits.api.duros.v2.ListNvmeDevicesResponse
	89,  // 260: lightbits.api.duros.v2.DurosAPI.GetNvmeDevice:output_type -> lightbits.api.duros.v2.UserNvmeDevicesResponse
	256, // 261: lightbits.api.duros.v2.DurosAPI.FetchLogs:output_type -> google.api.HttpBody
	117, // 262: lightbits.api.duros.v2.DurosAPI.GetCluster:output_type -> lightbits.api.duros.v2.ClusterInfo
	118, // 263: lightbits.api.duros.v2.DurosAPI.GetClusterInfo:output_type -> lightbits.api.duros.v2.ClusterInfoV2
	95,  // 264: lightbits.api.duros.v2.DurosAPI.UpdateNvmeDevice:output_type -> lightbits.api.duros.v2.UpdateNvmeDeviceResponse
	96,  // 265: lightbits.api.duros.v2.DurosAPI.AddNvmeDevice:output_type -> lightbits.api.duros.v2.AddNvmeDeviceResponse
	97,  // 266: lightbits.api.duros.v2.DurosAPI.UpdateVolume:output_type -> lightbits.api.duros.v2.UpdateVolumeResponse
	123, // 267: lightbits.api.duros.v2.DurosAPI.GetServer:output_type -> lightbits.api.duros.v2.Server
	112, // 268: lightbits.api.duros.v2.DurosAPI.ListServers:output_type -> lightbits.api.duros.v2.ListServersResponse
	98,  // 269: lightbits.api.duros.v2.DurosAPI.UpgradeServer:output_type -> lightbits.api.duros.v2.UpgradeServerResponse
	99,  // 270: lightbits.api.duros.v2.DurosAPI.UpgradeCluster:output_type -> lightbits.api.duros.v2.UpgradeClusterResponse
	100, // 271: lightbits.api.duros.v2.DurosAPI.EnableClusterEncryption:output_type -> lightbits.api.duros.v2.EnableClusterEncryptionResponse
	123, // 272: lightbits.api.duros.v2.DurosAPI.CreateServer:output_type -> lightbits.api.duros.v2.Server
	101, // 273: lightbits.api.duros.v2.DurosAPI.ReplaceNode:output_type -> lightbits.api.duros.v2.ReplaceNodeResponse
	102, // 274: lightbits.api.duros.v2.DurosAPI.DeleteServer:output_type -> lightbits.api.duros.v2.DeleteServerResponse
	123, // 275: lightbits.api.duros.v2.DurosAPI.EnableServer:output_type -> lightbits.api.duros.v2.Server
	103, // 276: lightbits.api.duros.v2.DurosAPI.DisableServer:output_type -> lightbits.api.duros.v2.DisableServerResponse
	105, // 277: lightbits.api.duros.v2.DurosAPI.StartNodeInstance:output_type -> lightbits.api.duros.v2.StartNodeInstanceResponse
	107, // 278: lightbits.api.duros.v2.DurosAPI.StopNodeInstance:output_type -> lightbits.api.duros.v2.StopNodeInstanceResponse
	109, // 279: lightbits.api.duros.v2.DurosAPI.RestartNodeInstance:output_type -> lightbits.api.duros.v2.RestartNodeInstanceResponse
	53,  // 280: lightbits.api.duros.v2.DurosAPI.CreateProject:output_type -> lightbits.api.duros.v2.Project
	186, // 281: lightbits.api.duros.v2.DurosAPI.UpdateProject:output_type -> lightbits.api.duros.v2.UpdateProjectResponse
	55,  // 282: lightbits.api.duros.v2.DurosAPI.DeleteProject:output_type -> lightbits.api.duros.v2.DeleteProjectResponse
	57,  // 283: lightbits.api.duros.v2.DurosAPI.ListProjects:output_type -> lightbits.api.duros.v2.ListProjectsResponse
	53,  // 284: lightbits.api.duros.v2.DurosAPI.GetProject:output_type -> lightbits.api.duros.v2.Project
	45,  // 285: lightbits.api.duros.v2.DurosAPI.CreateCredential:output_type -> lightbits.api.duros.v2.Credential
	47,  // 286: lightbits.api.duros.v2.DurosAPI.DeleteCredential:output_type -> lightbits.api.duros.v2.DeleteCredentialResponse
	49,  // 287: lightbits.api.duros.v2.DurosAPI.ListCredentials:output_type -> lightbits.api.duros.v2.ListCredentialsResponse
	45,  // 288: lightbits.api.duros.v2.DurosAPI.GetCredential:output_type -> lightbits.api.duros.v2.Credential
	125, // 289: lightbits.api.duros.v2.DurosAPI.GetRole:output_type -> lightbits.api.duros.v2.GetRoleResponse
	128, // 290: lightbits.api.duros.v2.DurosAPI.ListRoles:output_type -> lightbits.api.duros.v2.ListRolesResponse
	36,  // 291: lightbits.api.duros.v2.DurosAPI.CreateAdminEndpoint:output_type -> lightbits.api.duros.v2.AdminEndpoint
	43,  // 292: lightbits.api.duros.v2.DurosAPI.DeleteAdminEndpoint:output_type -> lightbits.api.duros.v2.DeleteAdminEndpointResponse
	38,  // 293: lightbits.api.duros.v2.DurosAPI.ListAdminEndpoints:output_type -> lightbits.api.duros.v2.ListAdminEndpointsResponse
	36,  // 294: lightbits.api.duros.v2.DurosAPI.UpdateAdminEndpoint:output_type -> lightbits.api.duros.v2.AdminEndpoint
	36,  // 295: lightbits.api.duros.v2.DurosAPI.GetAdminEndpoint:output_type -> lightbits.api.duros.v2.AdminEndpoint
	147, // 296: lightbits.api.duros.v2.DurosAPI.CreateResourcePolicy:output_type -> lightbits.api.duros.v2.ResourcePolicy
	148, // 297: lightbits.api.duros.v2.DurosAPI.CreatePolicy:output_type -> lightbits.api.duros.v2.Policy
	146, // 298: lightbits.api.duros.v2.DurosAPI.UpdatePolicy:output_type -> lightbits.api.duros.v2.UpdatePolicyResponse
	150, // 299: lightbits.api.duros.v2.DurosAPI.UpdateResourcePolicy:output_type -> lightbits.api.duros.v2.UpdateResourcePolicyResponse
	148, // 300: lightbits.api.duros.v2.DurosAPI.GetPolicy:output_type -> lightbits.api.duros.v2.Policy
	152, // 301: lightbits.api.duros.v2.DurosAPI.ListPolicies:output_type -> lightbits.api.duros.v2.ListPoliciesResponse
	154, // 302: lightbits.api.duros.v2.DurosAPI.ListResourcePolicies:output_type -> lightbits.api.duros.v2.ListResourcePoliciesResponse
	147, // 303: lightbits.api.duros.v2.DurosAPI.GetResourcePolicy:output_type -> lightbits.api.duros.v2.ResourcePolicy
	158, // 304: lightbits.api.duros.v2.DurosAPI.DeleteResourcePolicy:output_type -> lightbits.api.duros.v2.DeleteResourcePolicyResponse
	160, // 305: lightbits.api.duros.v2.DurosAPI.DeletePolicy:output_type -> lightbits.api.duros.v2.DeletePolicyResponse
	129, // 306: lightbits.api.duros.v2.DurosAPI.CreateSnapshot:output_type -> lightbits.api.duros.v2.Snapshot
	129, // 307: lightbits.api.duros.v2.DurosAPI.GetSnapshot:output_type -> lightbits.api.duros.v2.Snapshot
	134, // 308: lightbits.api.duros.v2.DurosAPI.ListSnapshots:output_type -> lightbits.api.duros.v2.ListSnapshotsResponse
	135, // 309: lightbits.api.duros.v2.DurosAPI.DeleteSnapshot:output_type -> lightbits.api.duros.v2.DeleteSnapshotResponse
	136, // 310: lightbits.api.duros.v2.DurosAPI.GetFeatureFlag:output_type -> lightbits.api.duros.v2.FeatureFlagStatus
	140, // 311: lightbits.api.duros.v2.DurosAPI.EnableFeatureFlag:output_type -> lightbits.api.duros.v2.SetFeatureFlagResponse
	140, // 312: lightbits.api.duros.v2.DurosAPI.DisableFeatureFlag:output_type -> lightbits.api.duros.v2.SetFeatureFlagResponse
	142, // 313: lightbits.api.duros.v2.DurosAPI.ListFeatureFlags:output_type -> lightbits.api.duros.v2.ListFeatureFlagsResponse
	162, // 314: lightbits.api.duros.v2.DurosAPI.GetClusterConfigParam:output_type -> lightbits.api.duros.v2.ClusterConfigParam
	166, // 315: lightbits.api.duros.v2.DurosAPI.UpdateClusterConfigParam:output_type -> lightbits.api.duros.v2.UpdateClusterConfigParamResponse
	168, // 316: lightbits.api.duros.v2.DurosAPI.ListClusterConfigParams:output_type -> lightbits.api.duros.v2.ListClusterConfigParamsResponse
	165, // 317: lightbits.api.duros.v2.DurosAPI.RollbackVolume:output_type -> lightbits.api.duros.v2.RollbackVolumeResponse
	181, // 318: lightbits.api.duros.v2.DurosAPI.ListChangedBlocks:output_type -> lightbits.api.duros.v2.ListChangedBlocksResponse
	191, // 319: lightbits.api.duros.v2.DurosAPI.RotateClusterRootKey:output_type -> lightbits.api.duros.v2.RotateClusterRootKeyResponse
	193, // 320: lightbits.api.duros.v2.DurosAPI.GetClusterRootKey:output_type -> lightbits.api.duros.v2.GetClusterRootKeyResponse
	194, // 321: lightbits.api.duros.v2.DurosAPI.CreateIdpConfiguration:output_type -> lightbits.api.duros.v2.IDPConfiguration
	201, // 322: lightbits.api.duros.v2.DurosAPI.DeleteIdpConfiguration:output_type -> lightbits.api.duros.v2.DeleteIDPConfigurationResponse
	194, // 323: lightbits.api.duros.v2.DurosAPI.UpdateIdpConfiguration:output_type -> lightbits.api.duros.v2.IDPConfiguration
	198, // 324: lightbits.api.duros.v2.DurosAPI.ListIdpConfigurations:output_type -> lightbits.api.duros.v2.ListIDPConfigurationsResponse
	194, // 325: lightbits.api.duros.v2.DurosAPI.GetIdpConfiguration:output_type -> lightbits.api.duros.v2.IDPConfiguration
	202, // 326: lightbits.api.duros.v2.DurosAPI.CreateIdpClientConf:output_type -> lightbits.api.duros.v2.IdpClientConf
	207, // 327: lightbits.api.duros.v2.DurosAPI.DeleteIdpClientConf:output_type -> lightbits.api.duros.v2.DeleteIdpClientConfResponse
	202, // 328: lightbits.api.duros.v2.DurosAPI.UpdateIdpClientConf:output_type -> lightbits.api.duros.v2.IdpClientConf
	209, // 329: lightbits.api.duros.v2.DurosAPI.ListIdpClientConfs:output_type -> lightbits.api.duros.v2.ListIdpClientConfsResponse
	202, // 330: lightbits.api.duros.v2.DurosAPI.GetIdpClientConf:output_type -> lightbits.api.duros.v2.IdpClientConf
	210, // 331: lightbits.api.duros.v2.DurosAPI.CreateAuthMapEntry:output_type -> lightbits.api.duros.v2.AuthMapEntry
	210, // 332: lightbits.api.duros.v2.DurosAPI.UpdateAuthMapEntry:output_type -> lightbits.api.duros.v2.AuthMapEntry
	216, // 333: lightbits.api.duros.v2.DurosAPI.DeleteAuthMapEntry:output_type -> lightbits.api.duros.v2.DeleteAuthMapEntryResponse
	210, // 334: lightbits.api.duros.v2.DurosAPI.GetAuthMapEntry:output_type -> lightbits.api.duros.v2.AuthMapEntry
	217, // 335: lightbits.api.duros.v2.DurosAPI.ListAuthMapEntries:output_type -> lightbits.api.duros.v2.ListAuthMapEntriesResponse
	257, // 336: lightbits.api.duros.v2.DurosAPI.EnableClusterInBandAuth:output_type -> lightbits.api.duros.v2.EnableClusterInBandAuthResponse
	258, // 337: lightbits.api.duros.v2.DurosAPI.DisableClusterInBandAuth:output_type -> lightbits.api.duros.v2.DisableClusterInBandAuthResponse
	259, // 338: lightbits.api.duros.v2.DurosAPI.CreateTrustedHost:output_type -> lightbits.api.duros.v2.TrustedHost
	260, // 339: lightbits.api.duros.v2.DurosAPI.DeleteTrustedHost:output_type -> lightbits.api.duros.v2.DeleteTrustedHostResponse
	259, // 340: lightbits.api.duros.v2.DurosAPI.GetTrustedHost:output_type -> lightbits.api.duros.v2.TrustedHost
	261, // 341: lightbits.api.duros.v2.DurosAPI.ListTrustedHosts:output_type -> lightbits.api.duros.v2.ListTrustedHostsResponse
	259, // 342: lightbits.api.duros.v2.DurosAPI.UpdateTrustedHost:output_type -> lightbits.api.duros.v2.TrustedHost
	262, // 343: lightbits.api.duros.v2.DurosAPI.SetTrustedHostSecret:output_type -> lightbits.api.duros.v2.SetTrustedHostSecretsResponse
	263, // 344: lightbits.api.duros.v2.DurosAPI.GetTrustedHostSecret:output_type -> lightbits.api.duros.v2.GetTrustedHostSecretsResponse
	219, // 345: lightbits.api.duros.v2.DurosAPI.EnableFederatedAuthentication:output_type -> lightbits.api.duros.v2.EnableFederatedAuthenticationResponse
	221, // 346: lightbits.api.duros.v2.DurosAPI.DisableFederatedAuthentication:output_type -> lightbits.api.duros.v2.DisableFederatedAuthenticationResponse
	264, // 347: lightbits.api.duros.v2.DurosAPI.CFLogin:output_type -> lightbits.api.duros.v2.CFLoginResponse
	265, // 348: lightbits.api.duros.v2.DurosAPI.ListClusters:output_type -> lightbits.api.duros.v2.ListClustersResponse
	266, // 349: lightbits.api.duros.v2.DurosAPI.DetachCluster:output_type -> lightbits.api.duros.v2.DetachClusterResponse
	267, // 350: lightbits.api.duros.v2.DurosAPI.AttachCluster:output_type -> lightbits.api.duros.v2.AttachClusterResponse
	268, // 351: lightbits.api.duros.v2.DurosAPI.GetCFServiceCredentials:output_type -> lightbits.api.duros.v2.GetCFServiceCredentialsResponse
	269, // 352: lightbits.api.duros.v2.DurosAPI.ListWorkflows:output_type -> lightbits.api.duros.v2.ListWorkflowsResponse
	270, // 353: lightbits.api.duros.v2.DurosAPI.GetWorkflow:output_type -> lightbits.api.duros.v2.GetWorkflowResponse
	249, // [249:354] is the sub-list for method output_type
	144, // [144:249] is the sub-list for method input_type
	144, // [144:144] is the sub-list for extension type_name
	144, // [144:144] is the sub-list for extension extendee
	0,   // [0:144] is the sub-list for field type_name
}

func init() { file_lightbits_api_duros_v2_durosapiv2_proto_init() }
func file_lightbits_api_duros_v2_durosapiv2_proto_init() {
	if File_lightbits_api_duros_v2_durosapiv2_proto != nil {
		return
	}
	file_lightbits_api_duros_v2_statisticsapiv2_proto_init()
	file_lightbits_api_duros_v2_schedule_policy_proto_init()
	file_lightbits_api_duros_v2_security_proto_init()
	file_lightbits_api_duros_v2_labels_proto_init()
	file_lightbits_api_duros_v2_authz_mode_proto_init()
	file_lightbits_api_duros_v2_proxy_info_proto_init()
	file_lightbits_api_duros_v2_cf_proto_init()
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[26].OneofWrappers = []any{
		(*CreateVolumeRequest_QosPolicyUUID)(nil),
		(*CreateVolumeRequest_QosPolicyName)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[34].OneofWrappers = []any{
		(*UpdateVolumeRequest_QosPolicyUUID)(nil),
		(*UpdateVolumeRequest_QosPolicyName)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[55].OneofWrappers = []any{
		(*DurosNodeInfo_JournalDeviceNotFound)(nil),
		(*DurosNodeInfo_JournalNvmeDevice)(nil),
		(*DurosNodeInfo_JournalRaidDevice)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[109].OneofWrappers = []any{
		(*CreatePolicyRequest_QoSRateLimitPolicy)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[110].OneofWrappers = []any{
		(*UpdatePolicyRequest_QoSRateLimitPolicy)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[113].OneofWrappers = []any{
		(*Policy_QoSRateLimitPolicy)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[147].OneofWrappers = []any{
		(*Event_ComponentVolumesInfo)(nil),
		(*Event_ComponentNVMeSSDInfo)(nil),
		(*Event_ComponentNodeInfo)(nil),
		(*Event_ComponentServerInfo)(nil),
		(*Event_ComponentClusterInfo)(nil),
		(*Event_ComponentDataIntegrityInfo)(nil),
	}
	file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes[148].OneofWrappers = []any{
		(*QoSRateLimitPolicy_LimitIOPS)(nil),
		(*QoSRateLimitPolicy_LimitBw)(nil),
		(*QoSRateLimitPolicy_LimitIOPSPerGB)(nil),
	}
	type x struct{}
	out := protoimpl.TypeBuilder{
		File: protoimpl.DescBuilder{
			GoPackagePath: reflect.TypeOf(x{}).PkgPath(),
			RawDescriptor: unsafe.Slice(unsafe.StringData(file_lightbits_api_duros_v2_durosapiv2_proto_rawDesc), len(file_lightbits_api_duros_v2_durosapiv2_proto_rawDesc)),
			NumEnums:      35,
			NumMessages:   194,
			NumExtensions: 0,
			NumServices:   1,
		},
		GoTypes:           file_lightbits_api_duros_v2_durosapiv2_proto_goTypes,
		DependencyIndexes: file_lightbits_api_duros_v2_durosapiv2_proto_depIdxs,
		EnumInfos:         file_lightbits_api_duros_v2_durosapiv2_proto_enumTypes,
		MessageInfos:      file_lightbits_api_duros_v2_durosapiv2_proto_msgTypes,
	}.Build()
	File_lightbits_api_duros_v2_durosapiv2_proto = out.File
	file_lightbits_api_duros_v2_durosapiv2_proto_goTypes = nil
	file_lightbits_api_duros_v2_durosapiv2_proto_depIdxs = nil
}
